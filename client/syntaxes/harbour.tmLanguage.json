{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "Harbour",
	"patterns": [
		{
			"include": "#c_code"
		},
		{
			"include": "#comments"
		},
		{
			"include": "#constants"
		},
		{
			"include": "#strings"
		},
		{
			"include": "#keywords"
		},
		{
			"include": "#numbers"
		}
	],
	"repository": {
		"numbers": {
			"patterns": [
				{
					"match": "(?i)\\b[0-9]+(\\.[0-9]+)?(?i:e[0-9]+)?\\b",
					"name": "constant.numeric.harbour"
				},
				{
					"match": "(?i)\\b0x[0-9a-f]+\\b",
					"name": "constant.numeric.exadecimal.harbour"
				}
			]
		},
		"comments": {
			"patterns": [
				{
					"name": "comment.block.harbour",
					"begin": "/\\*",
					"end": "\\*/"
				},
				{
					"name": "comment.singleline.slash.harbour",
					"match": "//(.*)"
				},
				{
					"name": "comment.singleline.ampersand.harbour",
					"match": "&&(.*)"
				},
				{
					"name": "comment.startline.note.harbour",
					"match": "^\\s*NOTE\\s+(.*)"
				},
				{
					"name": "comment.startline.asterisk.harbour",
					"match": "^\\s*\\*(.*)"
				}
			]
		},
		"keywords": {
			"patterns": [{
				"name": "keyword.control.harbour",
				"match": "\\b(?i:if|ELSEIF|ELSE|end\\s*(if|while|case|do|switch|class)?|next|do|while|switch|case|endcase|otherwise|default|exit|loop)\\b"
			},
			{
				"name": "for.control.harbour",
				"match": "\\b(?i:(for)\\s+(?:(?!to)[^\r\n])*(to))\\b",
				"captures": {
					"1": {"name": "keyword.control.for.harbour" },
					"2": {"name": "keyword.control.for.harbour" }
				}		
			},
			{
				"name": "foreach.control.harbour",
				"match": "\\b(?i:(for\\s+each)\\s+(?:(?!in)[^\r\n])*(in))\\b",
				"captures": {
					"1": {"name": "keyword.control.foreach.harbour" },
					"2": {"name": "keyword.control.foreach.harbour" }
				}		
			},			
			{
				"name": "keyword.function.harbour",				
				"match": "\\b(?i:static|retu(rn?)?|method|proc(e(d(u(re?)?)?)?)?|func(t(i(on?)?)?)?)\\b"
			},
			{
				"name": "keyword.declarations.harbour",
				"match": "\\b(?i:local|private|public|field|thread|memvar|parameter)\\b"
			},
			{
				"name": "keyword.reserved.harbour",
				"match": "(?i)\\b(nil)\\b"
			},
			{
				"name": "meta.function.harbour",
				"match": "\\b(?i:([a-z_][a-z_0-9]+)\\s*\\()",
				"captures": {
					"1": { "name": "entity.name.function.harbour" }
				}
			},
			{
				"name": "keyword.classes.harbour",
				"match": "\\b(?i:(end)?class(data)?|method|data|message|init|constructor|destructor|hidden:|exported:)\\b"
			},
			{
				"name": "keyword.operator.logical.harbour",
				"match": "(?i)(\\.(T|F|and|or|not)\\.)"
			},
			{
				"name": "meta.preprocessor.include.harbour",
				"begin": "(?i:^\\s*#include\\s)",
				"end": "(?=//|&&|/\\*)|(?<!;)(?=\\n)",
				"patterns": [
					{
						"include": "#strings"
					},
					{
						"name": "string.quoted.angle.harbour",
						"begin": "<",
						"end": ">"
					}
				]
			},
			{
				"name": "meta.preprocessor.various.harbour",
				"match": "(?i)(^\\s*#[a-zA-z]+)"
			}]
		},
		"constants": {
			"patterns": [
				{
					"name": "constant.language.date.quoted.harbour",
					"match": "[dD]\"\\d{4}[-/\\.](?:0\\d|1[0-2])[-/\\.](?:[0-2]\\d|3[0-1])\""
				},
				{
					"name": "constant.language.time.quoted.harbour",
					"match": "[tT]\"(?:\\d{4}[-/\\.](?:0\\d|1[0-2])[-/\\.](?:[0-2]\\d|3[0-1]))?\\s*(?:(?:[0-1]?\\d|2[0-3])(?::[0-5]?\\d(?::[0-5]?\\d(?:\\.\\d{1,3})?)?)?)?\""
				},
				{
					"name": "constant.language.time.curly.harbour",
					"match": "\\{\\^\\s*(?:\\d{4}[-/\\.](?:0\\d|1[0-2])[-/\\.](?:[0-2]\\d|3[0-1]))?\\s*(?:(?:[0-1]?\\d|2[0-3])(?::[0-5]?\\d(?::[0-5]?\\d(?:\\.\\d{1,3})?)?)?)?\\s*\\}"
				}
			]
		},
		"escapes": {
			"patterns": [
				{
					"name": "constant.character.escape.harbour",
					"match": "\\\\u\\h{4}|\\\\U\\h{8}"
				},
				{
					"name": "constant.character.escape.harbour",
					"match": "\\\\['\"?\\\\abfnrtv]"
				},
				{
					"name": "constant.character.escape.harbour",
					"match": "\\\\[0-7]{1,3}"
				},
				{
					"name": "constant.character.escape.harbour",
					"match": "\\\\x\\h+"
				}
			]
		},
		"strings": {
			"patterns": [
				{
					"match": "(?i:^\\s*(#pragma)\\s+(__c?streaminclude)\\s+(\"[^\"]+\")\\s+\\|([^\\n]*))$",
					"captures": {
						"1": { "name": "meta.preprocessor.command.harbour"},
						"2": { "name": "keyword.text.harbor" },
						"3": { "name": "string.quoted.double.harbour" },
						"4": { "patterns":[
							{"include":"source.harbour"},
							{ 
								"name": "variable.string.replace.harbour", 
								"match": "%s" 
							}]}
					}
				},
				{
					"begin": "(?i:^\\s*(TEXT(?:\\s+INTO\\s+([a-z0-9_]+)(?:\\s*(?:WRAP\\s+([a-z0-9_]+)|TRIMMED))*|TO\\s+(?:PRINTER|FILE\\s+(.*)))?))\\s*$",
					"end": "(?i:^\\s*(#pragma)\\s+(__endtext)|(ENDTEXT)\\s*$)",
					"contentName": "string.multiline.harbour",
					"beginCaptures": {
						"1": { "name": "meta.preprocessor.command.harbour" },
						"2": { "name": "variable.text.harbor" },
						"3": { "patterns": [
							{"include":"source.harbour"},
							{
								"name": "variable.string.replace.harbour",
								"match": "%s"
							}
						] },
						"4": { "patterns": [
							{"include":"source.harbour"},
							{
								"name": "variable.string.replace.harbour",
								"match": "%s"
							}
						] }
					},
					"endCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.text.harbor" },
						"3": { "name": "meta.preprocessor.command.harbour" }
					}
				},
				{
					"begin": "(?i:^\\s*(#pragma)\\s+(__text|__stream)(?:\\s+\\|([^\n]*))*)$",
					"end": "(?i:^\\s*(#pragma)\\s+(__endtext)|(ENDTEXT))",
					"contentName": "string.multiline.harbour",
					"beginCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.text.harbor" },
						"3": { "patterns": [
							{"include":"source.harbour"},
							{
								"name": "variable.string.replace.harbour",
								"match": "%s"
							}
						] }
					},
					"endCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.text.harbor" },
						"3": { "name": "meta.preprocessor.command.harbour" }
					}
				},
				{
					"begin": "(?i:^\\s*(#pragma)\\s+(__cstream)(?:\\s*\\|([^\n]*))*)",
					"end": "(?i:^\\s*(#pragma)\\s+(__endtext)|(ENDTEXT))",
					"contentName": "string.multiline.harbour",
					"beginCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.text.harbor" },
						"3": { "patterns": [
							{"include":"source.harbour"},
							{
								"name": "variable.string.replace.harbour",
								"match": "%s"
							}
						] }
					},
					"endCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.text.harbor" },
						"3": { "name": "meta.preprocessor.command.harbour" }
					},
					"patterns": [{"include":"#escapes"}]
				},
				{
					"name": "string.escaped.harbour",
					"begin": "[eE]\"",
					"end": "\"|\\n",
					"patterns": [{"include":"#escapes"}]
				},
				{
					"name": "string.quoted.double.harbour",
					"begin": "\"",
					"end": "\"|\\n"
				},
				{
					"name": "string.quoted.single.harbour",
					"begin": "'",
					"end": "'|\\n"
				},
				{
					"name": "string.square.harbour",
					"begin": "(?<![a-zA-Z0-9_\\]\\(\\)])\\s*\\[",
					"end": "\\]|\\n"
				}
			]
		},
		"c_code": {
			"patterns": [
				{
					"begin": "(?i:^\\s*(#pragma)\\s+(BEGINDUMP))",
					"end": "(?i:^\\s*(#pragma)\\s+(ENDDUMP))",
					"contentName": "source.c.embedded.harbour",
					"beginCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.dump.harbor" }
					},
					"endCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.dump.harbor" }
					},
					"patterns": [
						{
							"include": "source.c"
						},
						{
							"match": "\\b(HB_FUNC|hb_ret[a-z]+|hb_par[a-z]+)\\s*\\(",
							"name": "keyword.connection.harbor"
						}
					]
				}
			]
		}
	},
	"scopeName": "source.harbour"
}
