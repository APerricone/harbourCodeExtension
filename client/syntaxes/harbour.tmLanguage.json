{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "Harbour",
	"patterns": [
		{
			"include": "#c_code"
		},
		{
			"include": "#comments"
		},
		{
			"include": "#constants"
		},
		{
			"include": "#strings"
		},
		{
			"include": "#keywords"
		},
		{
			"include": "#numbers"
		}
	],
	"repository": {
		"numbers": {
			"patterns": [
				{
					"match": "(?i)\\b[0-9]+(\\.[0-9]+)?(?i:e[0-9]+)?\\b",
					"name": "constant.numeric.harbour"
				},
				{
					"match": "(?i)\\b0x[0-9a-f]+\\b",
					"name": "constant.numeric.exadecimal.harbour"
				}
			]
		},
		"comments": {
			"patterns": [
				{
					"name": "comment.block.harbour",
					"begin": "/\\*",
					"end": "\\*/"
				},
				{
					"name": "comment.singleline.slash.harbour",
					"match": "//(.*)"
				},
				{
					"name": "comment.singleline.ampersand.harbour",
					"match": "&&(.*)"
				},
				{
					"name": "comment.startline.note.harbour",
					"match": "^\\s*NOTE\\s+(.*)"
				},
				{
					"name": "comment.startline.asterisk.harbour",
					"match": "^\\s*\\*(.*)"
				}
			]
		},
		"keywords": {
			"patterns": [{
				"name": "keyword.control.harbour",
				"match": "\\b(?i:if|ELSEIF|ELSE|end\\s*(if|while|case|do|switch|class|sequence)?|next|do|while|switch|case|endcase|otherwise|default|exit|loop|try|catch|begin\\s+sequence(\\s+with)?|recover(\\s+using)?|try|catch|finally)\\b"
			},
			{
				"name": "for.control.harbour",
				"begin": "\\b(?i:for(?:\\s+each)?)\\b",
				"end": "\\b(?i:to|in|(?=//|&&|/\\*)|$)\\b",
				"beginCaptures": {"0": {"name": "keyword.control.for.harbour"}},
				"endCaptures": {"0": {"name": "keyword.control.for.harbour"}},
				"patterns": [{"include": "source.harbour"}]
			},			
			{
				"name": "keyword.function.harbour",				
				"match": "\\b(?i:static|retu(rn?)?|method|proc(e(d(u(re?)?)?)?)?|func(t(i(on?)?)?)?)\\b"
			},
			{
				"name": "keyword.declarations.harbour",
				"match": "\\b(?i:local|private|public|field|thread|memvar|parameter)\\b"
			},
			{
				"name": "storage.type.harbour",
				"match": "\\b(?i:as\\s+(?:character|numeric|date|logical|codeblock|array|nil))\\b"
			},
			{
				"name": "keyword.reserved.harbour",
				"match": "(?i)\\b(iif|nil)\\b"
			},
			{
				"name": "meta.function.harbour",
				"match": "\\b(?i:([a-z_][a-z_0-9]+)\\s*\\()",
				"captures": {
					"1": { "name": "entity.name.function.harbour" }
				}
			},
			{
				"name": "keyword.classes.harbour",
				"match": "\\b(?i:(end)?class(data)?|method|data|message|init|constructor|destructor|hidden:|exported:)\\b"
			},
			{
				"name": "keyword.object.harbour",
				"match": "\\b(?i:with\\s+object|end(?:\\s+with)?)\\b"
			},
			{
				"name": "keyword.operator.logical.harbour",
				"match": "(?i)(\\.(T|F|and|or|not)\\.)"
			},
			{
				"name": "meta.preprocessor.include.harbour",
				"begin": "(?i:^\\s*#include\\s)",
				"end": "(?=//|&&|/\\*)|$",
				"patterns": [
					{
						"include": "#strings"
					},
					{
						"name": "string.quoted.angle.harbour",
						"begin": "<",
						"end": ">|$"
					}
				]
			},
			{
				"name": "meta.preprocessor.various.harbour",
				"match": "(?i)(^\\s*#[a-zA-z]+)"
			}]
		},
		"constants": {
			"patterns": [
				{
					"name": "constant.language.datetime.quoted.harbour",
					"match": "[tTdD]\"[^\"]*\""
				},
				{
					"name": "constant.language.datetime.curly.harbour",
					"match": "\\{\\^[^\\}]*\\}"
				}
			]
		},
		"escapes": {
			"name": "constant.character.escape.harbour",
			"patterns": [
				{
					"match": "\\\\u\\h{4}|\\\\U\\h{8}"
				},
				{
					"match": "\\\\['\"?\\\\abfnrtv]"
				},
				{
					"match": "\\\\[0-7]{1,3}"
				},
				{
					"match": "\\\\x\\h+"
				}
			]
		},
		"strings": {
			"patterns": [
				{
					"match": "(?i:^\\s*(#pragma)\\s+(__c?streaminclude)\\s+(\"[^\"]+\")\\s+\\|([^\\n]*))$",
					"captures": {
						"1": { "name": "meta.preprocessor.command.harbour"},
						"2": { "name": "keyword.text.harbor" },
						"3": { "name": "string.quoted.double.harbour" },
						"4": { "patterns":[
							{"include":"source.harbour"},
							{ 
								"name": "variable.string.replace.harbour", 
								"match": "%s" 
							}]}
					}
				},
				{
					"begin": "(?i:^\\s*(TEXT(?:\\s+INTO\\s+([a-z0-9_]+)(?:\\s*(?:WRAP\\s+([a-z0-9_]+)|TRIMMED))*|TO\\s+(?:PRINTER|FILE\\s+(.*)))?))\\s*$",
					"end": "(?i:^\\s*(#pragma)\\s+(__endtext)|(ENDTEXT)\\s*$)",
					"contentName": "string.multiline.harbour",
					"beginCaptures": {
						"1": { "name": "meta.preprocessor.command.harbour" },
						"2": { "name": "variable.text.harbor" },
						"3": { "patterns": [
							{"include":"source.harbour"},
							{
								"name": "variable.string.replace.harbour",
								"match": "%s"
							}
						] },
						"4": { "patterns": [
							{"include":"source.harbour"},
							{
								"name": "variable.string.replace.harbour",
								"match": "%s"
							}
						] }
					},
					"endCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.text.harbor" },
						"3": { "name": "meta.preprocessor.command.harbour" }
					}
				},
				{
					"begin": "(?i:^\\s*(#pragma)\\s+(__text|__stream)(?:\\s+\\|([^\n]*))*)$",
					"end": "(?i:^\\s*(#pragma)\\s+(__endtext)|(ENDTEXT))",
					"contentName": "string.multiline.harbour",
					"beginCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.text.harbor" },
						"3": { "patterns": [
							{"include":"source.harbour"},
							{
								"name": "variable.string.replace.harbour",
								"match": "%s"
							}
						] }
					},
					"endCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.text.harbor" },
						"3": { "name": "meta.preprocessor.command.harbour" }
					}
				},
				{
					"begin": "(?i:^\\s*(#pragma)\\s+(__cstream)(?:\\s*\\|([^\n]*))*)",
					"end": "(?i:^\\s*(#pragma)\\s+(__endtext)|(ENDTEXT))",
					"contentName": "string.multiline.harbour",
					"beginCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.text.harbor" },
						"3": { "patterns": [
							{"include":"source.harbour"},
							{
								"name": "variable.string.replace.harbour",
								"match": "%s"
							}
						] }
					},
					"endCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.text.harbor" },
						"3": { "name": "meta.preprocessor.command.harbour" }
					},
					"patterns": [{"include":"#escapes"}]
				},
				{
					"name": "string.escaped.harbour",
					"begin": "[eE]\"",
					"end": "\"|$",
					"patterns": [{"include":"#escapes"}]
				},
				{
					"name": "string.quoted.double.harbour",
					"begin": "\"",
					"end": "\"|$"
				},
				{
					"name": "string.quoted.single.harbour",
					"begin": "'",
					"end": "'|$"
				},
				{
					"name": "string.square.harbour",
					"begin": "(?<![a-zA-Z0-9_\\]\\(\\)])\\s*\\[",
					"end": "\\]|$"
				}
			]
		},
		"c_code": {
			"patterns": [
					{
					"begin": "(?i:^\\s*(#pragma)\\s+(BEGINDUMP))",
					"end": "(?i:^\\s*(#pragma)\\s+(ENDDUMP))",
					"contentName": "source.c.embedded.harbour",
					"beginCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.dump.harbor" }
					},
					"endCaptures": {
						"1": { "name": "meta.preprocessor.pragma.harbour" },
						"2": { "name": "keyword.dump.harbor" }
					},
					"patterns": [
						{
							"include": "source.c"
						},
						{
							"match": "\\b(HB_FUNC|hb_ret[a-z]+|hb_par[a-z]+)\\s*\\(",
							"name": "keyword.connection.harbor"
						}
					]
				}
			]
		}
	},
	"scopeName": "source.harbour"
}
