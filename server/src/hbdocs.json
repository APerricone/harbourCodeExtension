[
 {
  "label": "__AtPrompt( <nRow>, <nCol>, <cPrompt>, [<xMsg>] ) --> .F.",
  "documentation": "Display a menu item on screen and define a message",
  "arguments": [
   {
    "label": "<nRow>",
    "documentation": "is the row number to display the menu <cPrompt>. Value could range from zero to MaxRow()."
   },
   {
    "label": "<nCol>",
    "documentation": "is the column number to display the menu <cPrompt>. Value could range from zero to MaxCol()."
   },
   {
    "label": "<cPrompt>",
    "documentation": "is the menu item character string to display."
   },
   {
    "label": "<xMsg>",
    "documentation": "define a message to display each time this menu item is highlighted. <xMsg> could be a character string or code block that is evaluated to a character string. If <xMsg> is not specified or of the wrong type, an empty string (\"\") would be used."
   }
  ],
  "name": "__AtPrompt",
  "return": {
   "name": "",
   "help": "__AtPrompt() always return .F."
  }
 },
 {
  "label": "__dbCopyStruct( <cFileName>, [<aFieldList>] )",
  "documentation": "Create a new database based on current database structure",
  "arguments": [
   {
    "label": "<cFileName>",
    "documentation": "is the name of the new database file to create. `.dbf` is the default extension if none is given."
   },
   {
    "label": "<aFieldList>",
    "documentation": "is an array where each element is a field name. Names could be specified as uppercase or lowercase."
   }
  ],
  "name": "__dbCopyStruct"
 },
 {
  "label": "__dbCopyXStruct( <cFileName> ) --> lSuccess",
  "documentation": "Copy current database structure into a definition file",
  "arguments": [
   {
    "label": "<cFileName>",
    "documentation": "is the name of target definition file to create. `.dbf` is the default extension if none is given."
   }
  ],
  "name": "__dbCopyXStruct",
  "return": {
   "name": "",
   "help": "__dbCopyXStruct() returns .F. if no database is *used* in the current work-area, .T. on success, or a run-time error if the file create operation had failed."
  }
 },
 {
  "label": "__dbCreate( <cFileName>, [<cFileFrom>], [<cRDDName>], [<lNew>], [<cAlias>] ) --> lUsed",
  "documentation": "Create structure extended file or use one to create new file",
  "arguments": [
   {
    "label": "<cFileName>",
    "documentation": "is the target file name to create and then open. `.dbf` is the default extension if none is given."
   },
   {
    "label": "<cFileFrom>",
    "documentation": "is an optional structure extended file name from which the target file <cFileName> is going to be built. If omitted, a new empty structure extended file with the name <cFileName> is created and opened in the current work-area."
   },
   {
    "label": "<cRDDName>",
    "documentation": "is RDD name to create target with. If omitted, the default RDD is used."
   },
   {
    "label": "<lNew>",
    "documentation": "is an optional logical expression, (.T.) opens the target file name <cFileName> in the next available unused work-area and makes it the current work-area. (.F.) opens the target file in the current work-area. Default value is (.F.). The value of <lNew> is ignored if"
   },
   {
    "label": "<cFileFrom>",
    "documentation": "is not specified."
   },
   {
    "label": "<cAlias>",
    "documentation": "is an optional alias to USE the target file with. If not specified, alias is based on the root name of <cFileName>."
   }
  ],
  "name": "__dbCreate",
  "return": {
   "name": "",
   "help": "__dbCreate() returns (.T.) if there is database *used* in the current work-area (this might be the newly selected work-area), or (.F.) if there is no database *used*. Note that on success a (.T.) would be returned, but on failure you probably end up with a run-time error and not a (.F.) value."
  }
 },
 {
  "label": "__dbDelim( <lExport>, <xcFile>, [<xcDelim>], [<aFields>], [<bFor>], [<bWhile>], [<nNext>], [<nRecord>], <lRest>  )",
  "documentation": "Copies the contents of a database to a delimited text file or appends the contents of a delimited text file to a database.",
  "arguments": [
   {
    "label": "<lExport>",
    "documentation": "If set to .T., copies records to a delimited file. If set to .F., append records from a delimited file."
   },
   {
    "label": "<xcFile>",
    "documentation": "The name of the text file to copy to or append from. If a file extension is not specified, \".txt\" is used by default."
   },
   {
    "label": "<xcDelim>",
    "documentation": "Either the character to use as the character field delimiter (only the first character is used). or `\"BLANK\"` (not case sensitive), which eliminates the character field delimiters and sets the field separator to a single space instead of a comma."
   },
   {
    "label": "<aFields>",
    "documentation": "An array of field names to limit the processing to. If not specified, or if empty, then all fields are processed."
   },
   {
    "label": "<bFor>",
    "documentation": "An optional code block containing a FOR expression that will reduce the number of records to be processed."
   },
   {
    "label": "<bWhile>",
    "documentation": "An optional code block containing a WHILE expression that will reduce the number of records to be processed."
   },
   {
    "label": "<nNext>",
    "documentation": "If present, but nRecord is not present, specifies to process this number of records, starting with the current record. A value of 0 means to process no records."
   },
   {
    "label": "<nRecord>",
    "documentation": "If present, specifies the only record to process. A value of 0 means to process no records. Overrides <nNext> and <lRest>."
   },
   {
    "label": "<lRest>",
    "documentation": "If <lExport> is .T., then if <lRest> is set to .T. and there are no"
   },
   {
    "label": "<nRecord>",
    "documentation": ", <nNext>, or <bWhile> arguments, processes all records from current to last."
   }
  ],
  "name": "__dbDelim"
 },
 {
  "label": "__dbSDF( <lExport>, <xcFile>, [<aFields>], [<bFor>], [<bWhile>], [<nNext>], [<nRecord>], <lRest> )",
  "documentation": "Copies the contents of a database to an SDF text file or appends the contents of an SDF text file to a database.",
  "arguments": [
   {
    "label": "<lExport>",
    "documentation": "If set to .T., copies records to an SDF file. If set to .F., append records from an SDF file."
   },
   {
    "label": "<xcFile>",
    "documentation": "The name of the text file to copy to or append from. If a file extension is not specified, \".txt\" is used by default."
   },
   {
    "label": "<aFields>",
    "documentation": "An array of field names to limit the processing to. If not specified, or if empty, then all fields are processed."
   },
   {
    "label": "<bFor>",
    "documentation": "An optional code block containing a FOR expression that will reduce the number of records to be processed."
   },
   {
    "label": "<bWhile>",
    "documentation": "An optional code block containing a WHILE expression that will reduce the number of records to be processed."
   },
   {
    "label": "<nNext>",
    "documentation": "If present, but <nRecord> is not present, specifies to process this number of records, starting with the current record. A value of 0 means to process no records."
   },
   {
    "label": "<nRecord>",
    "documentation": "If present, specifies the only record to process. A value of 0 means to process no records. Overrides <nNext> and <lRest>."
   },
   {
    "label": "<lRest>",
    "documentation": "If <lExport> is .T., then if <lRest> is set to .T. and there are no <nRecord>, <nNext>, or <bWhile> arguments, processes all records from current to last."
   }
  ],
  "name": "__dbSDF"
 },
 {
  "label": "__dbStructFilter( <aStruct>, [<aFieldList>] ) --> aStructFiltered",
  "documentation": "Filter a database structure array",
  "arguments": [
   {
    "label": "<aStruct>",
    "documentation": "is a multidimensional array with database fields structure, which is usually the output from dbStruct(), where each array element has the following structure:"
   },
   {
    "label": "<table>",
    "documentation": " Position   Description    dbstruct.ch 1          cFieldName     DBS_NAME 2          cFieldType     DBS_TYPE 3          nFieldLength   DBS_LEN 4          nDecimals      DBS_DEC"
   },
   {
    "label": "</table>",
    "documentation": ""
   },
   {
    "label": "<aFieldList>",
    "documentation": "is an array where each element is a field name. Names could be specified as uppercase or lowercase."
   }
  ],
  "name": "__dbStructFilter",
  "return": {
   "name": "",
   "help": "__dbStructFilter() return a new multidimensional array where each element is in the same structure as the original <aStruct>, but the array is built according to the list of fields in <aFieldList>. If <aFieldList> is empty, __dbStructFilter() return reference to the original <aStruct> array."
  }
 },
 {
  "label": "__Dir( [<cFileMask>] ) --> NIL",
  "documentation": "Display listings of files",
  "arguments": [
   {
    "label": "<cFileMask>",
    "documentation": "File mask to include in the function return. It could contain path and standard wildcard characters as supported by your OS (like * and ?). If <cFileMask> contains no path, then SET DEFAULT path is used to display files in the mask."
   }
  ],
  "name": "__Dir",
  "return": {
   "name": "",
   "help": "__Dir() always returns NIL."
  }
 },
 {
  "label": "__FLedit( <aStruct>, [<aFieldList>] ) --> aStructFiltered",
  "documentation": "Filter a database structure array",
  "arguments": [
   {
    "label": "<aStruct>",
    "documentation": "is a multidimensional array with database fields structure, which is usually the output from dbStruct(), where each array element has the following structure:"
   },
   {
    "label": "<table>",
    "documentation": " Position   Description    dbstruct.ch 1          cFieldName     DBS_NAME 2          cFieldType     DBS_TYPE 3          nFieldLength   DBS_LEN 4          nDecimals      DBS_DEC"
   },
   {
    "label": "</table>",
    "documentation": ""
   },
   {
    "label": "<aFieldList>",
    "documentation": "is an array where each element is a field name. Names could be specified as uppercase or lowercase."
   }
  ],
  "name": "__FLedit",
  "return": {
   "name": "",
   "help": "__FLedit() return a new multidimensional array where each element is in the same structure as the original <aStruct>, but the array is built according to the list of fields in <aFieldList>. If <aFieldList> is empty, __FLedit() return reference to the original <aStruct> array."
  }
 },
 {
  "label": "__Input( <cMessage> ) --> cString",
  "documentation": "Stops application",
  "arguments": [
   {
    "label": "<cMessage>",
    "documentation": "is any valid expression."
   }
  ],
  "name": "__Input",
  "return": {
   "name": "<cString>",
   "help": "input value macroed"
  }
 },
 {
  "label": "__MenuTo( <bBlock>, <cVariable> ) --> nChoice",
  "documentation": "Invoked a menu defined by set of `@...PROMPT`",
  "arguments": [
   {
    "label": "<bBlock>",
    "documentation": "is a set/get code block for variable named <cVariable>."
   },
   {
    "label": "<cVariable>",
    "documentation": "is a character string that contain the name of the variable to hold the menu choices, if this variable does not exist a PRIVATE variable with the name <cVariable> would be created to hold the result."
   }
  ],
  "name": "__MenuTo",
  "return": {
   "name": "",
   "help": "__MenuTo() return the number of select menu item, or 0 if there was no item to select from or if the user pressed the <Esc> key."
  }
 },
 {
  "label": "__mvClear()",
  "documentation": "This function releases all PRIVATE and PUBLIC variables",
  "arguments": [],
  "name": "__mvClear",
  "return": {
   "name": "",
   "help": "Nothing"
  }
 },
 {
  "label": "__mvDbgInfo( <nScope> [, <nPosition> [, @<cVarName>] ] )",
  "documentation": "This function returns the information about the variables for debugger",
  "arguments": [
   {
    "label": "<nScope>",
    "documentation": "= the scope of variables for which an information is asked Supported values (defined in hbmemvar.ch)"
   },
   {
    "label": "<table-noheader>",
    "documentation": " HB_MV_PUBLIC HB_MV_PRIVATE (or any other value)"
   },
   {
    "label": "</table>",
    "documentation": ""
   },
   {
    "label": "<nPosition>",
    "documentation": "= the position of asked variable on the list of variables with specified scope - it should start from position 1"
   },
   {
    "label": "<cVarName>",
    "documentation": "= the value is filled with a variable name if passed by reference and <nPosition> is specified"
   }
  ],
  "name": "__mvDbgInfo",
  "return": {
   "name": "",
   "help": "The return value depends on the number of arguments passed"
  }
 },
 {
  "label": "__mvExist( <cVarName> ) --> lVariableExist",
  "documentation": "Determine if a given name is a PUBLIC or PRIVATE memory variable",
  "arguments": [
   {
    "label": "<cVarName>",
    "documentation": "- string that specifies the name of variable to check"
   }
  ],
  "name": "__mvExist",
  "return": {
   "name": "",
   "help": "__mvExist() return TRUE (.T.) if a MEMVAR named <cVarName> exist."
  }
 },
 {
  "label": "__mvGet( <cVarName> ) --> xVar",
  "documentation": "This function returns value of memory variable",
  "arguments": [
   {
    "label": "<cVarName>",
    "documentation": "- string that specifies the name of variable"
   }
  ],
  "name": "__mvGet",
  "return": {
   "name": "<xVar>",
   "help": "The value of variable"
  }
 },
 {
  "label": "__mvPrivate( <variable_name> )",
  "documentation": "This function creates a PRIVATE variable",
  "arguments": [
   {
    "label": "<variable_name>",
    "documentation": "= either a string that contains the variable's name or an one-dimensional array of strings with variable names No skeleton are allowed here."
   }
  ],
  "name": "__mvPrivate",
  "return": {
   "name": "",
   "help": "Nothing"
  }
 },
 {
  "label": "__mvPublic( <variable_name> )",
  "documentation": "This function creates a PUBLIC variable",
  "arguments": [
   {
    "label": "<variable_name>",
    "documentation": "= either a string that contains the variable's name or an one-dimensional array of strings with variable names No skeleton are allowed here."
   }
  ],
  "name": "__mvPublic",
  "return": {
   "name": "",
   "help": "Nothing"
  }
 },
 {
  "label": "__mvPut( <cVarName> [, <xValue>] ) --> xValue",
  "documentation": "This function set the value of memory variable",
  "arguments": [
   {
    "label": "<cVarName>",
    "documentation": "- string that specifies the name of variable"
   },
   {
    "label": "<xValue>",
    "documentation": "- a value of any type that will be set - if it is not specified then NIL is assumed"
   }
  ],
  "name": "__mvPut",
  "return": {
   "name": "<xValue>",
   "help": "A value assigned to the given variable."
  }
 },
 {
  "label": "__mvRelease( <skeleton>, <include_exclude_flag> )",
  "documentation": "This function releases PRIVATE variables",
  "arguments": [
   {
    "label": "<skeleton>",
    "documentation": "= string that contains the wildcard mask for variables' names that will be released. Supported wildcards: '*' and '?'"
   },
   {
    "label": "<include_exclude_flag>",
    "documentation": "= logical value that specifies if variables that match passed skeleton should be either included in deletion (if .T.) or excluded from deletion (if .F.)"
   }
  ],
  "name": "__mvRelease",
  "return": {
   "name": "",
   "help": "Nothing"
  }
 },
 {
  "label": "__mvScope( <cVarName> )",
  "documentation": "If variable exists then returns its scope.",
  "arguments": [
   {
    "label": "<cVarName>",
    "documentation": "= a string with a variable name to check"
   }
  ],
  "name": "__mvScope",
  "return": {
   "name": "",
   "help": "The symbolic values are defined in hbmemvar.ch <table-noheader> HB_MV_NOT_FOUND      variable is not declared (not found in symbol table) HB_MV_UNKNOWN        if variable doesn't exist (but found in symbol table) HB_MV_ERROR          if information cannot be obtained (memory error or argument error) HB_MV_PUBLIC         for public variables HB_MV_PRIVATE_GLOBAL for private variables declared outside of current function/procedure HB_MV_PRIVATE_LOCAL  for private variables declared in current function/procedure </table>"
  }
 },
 {
  "label": "__mvXRelease( <variable_name> )",
  "documentation": "This function releases value stored in PRIVATE or PUBLIC variable",
  "arguments": [
   {
    "label": "<variable_name>",
    "documentation": "= either a string that contains the variable's name or an one-dimensional array of strings with variable names No skeleton are allowed here."
   }
  ],
  "name": "__mvXRelease",
  "return": {
   "name": "",
   "help": "Nothing"
  }
 },
 {
  "label": "__NoNoAlert()",
  "documentation": "Override `//NOALERT` command-line switch",
  "arguments": [],
  "name": "__NoNoAlert"
 },
 {
  "label": "__objAddData( <oObject>, <cDataName> ) --> oObject",
  "documentation": "Add a VAR to an already existing class",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is the object to work on."
   },
   {
    "label": "<cDataName>",
    "documentation": "is the symbol name of the new VAR to add."
   }
  ],
  "name": "__objAddData",
  "return": {
   "name": "",
   "help": "__objAddData() return a reference to <oObject>."
  }
 },
 {
  "label": "__objAddInline( <oObject>, <cInlineName>, <bInline> ) --> oObject",
  "documentation": "Add an INLINE to an already existing class",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is the object to work on."
   },
   {
    "label": "<cInlineName>",
    "documentation": "is the symbol name of the new INLINE to add."
   },
   {
    "label": "<bInline>",
    "documentation": "is a code block to associate with the INLINE method."
   }
  ],
  "name": "__objAddInline",
  "return": {
   "name": "",
   "help": "__objAddInline() return a reference to <oObject>."
  }
 },
 {
  "label": "__objAddMethod( <oObject>, <cMethodName>, <nFuncPtr> ) --> oObject",
  "documentation": "Add a METHOD to an already existing class",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is the object to work on."
   },
   {
    "label": "<cMethodName>",
    "documentation": "is the symbol name of the new METHOD to add."
   },
   {
    "label": "<nFuncPtr>",
    "documentation": "is a pointer to a function to associate with the method."
   }
  ],
  "name": "__objAddMethod",
  "return": {
   "name": "",
   "help": "__objAddMethod() return a reference to <oObject>."
  }
 },
 {
  "label": "__objDelInline( <oObject>, <cSymbol> ) --> oObject",
  "documentation": "Delete a METHOD INLINE from class",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is the object to work on."
   },
   {
    "label": "<cSymbol>",
    "documentation": "is the symbol name of METHOD or INLINE method to be deleted (removed) from the object."
   }
  ],
  "name": "__objDelInline",
  "return": {
   "name": "",
   "help": "__objDelInline() return a reference to <oObject>."
  }
 },
 {
  "label": "__objDelMethod( <oObject>, <cSymbol> ) --> oObject",
  "documentation": "Delete a METHOD  from class",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is the object to work on."
   },
   {
    "label": "<cSymbol>",
    "documentation": "is the symbol name of METHOD or INLINE method to be deleted (removed) from the object."
   }
  ],
  "name": "__objDelMethod",
  "return": {
   "name": "",
   "help": "__objDelMethod() return a reference to <oObject>."
  }
 },
 {
  "label": "__objDelMethod( <oObject>, <cDataName> ) --> oObject",
  "documentation": "Delete a VAR (instance variable) from class",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is the object to work on."
   },
   {
    "label": "<cDataName>",
    "documentation": "is the symbol name of VAR to be deleted (removed) from the object."
   }
  ],
  "name": "__objDelMethod",
  "return": {
   "name": "",
   "help": "__objDelData() return a reference to <oObject>."
  }
 },
 {
  "label": "__objDerivedFrom( <oObject>, <xSuper> ) --> lIsParent",
  "documentation": "Determine whether a class is derived from another class",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is the object to check."
   },
   {
    "label": "<xSuper>",
    "documentation": "is the object that may be a parent. <xSuper> can be either an Object or a Character string with the class name."
   }
  ],
  "name": "__objDerivedFrom",
  "return": {
   "name": "",
   "help": "__objDerivedFrom() return a logical TRUE (.T.) if <oObject> is derived from <xSuper>."
  }
 },
 {
  "label": "__objGetMethodList( <oObject> ) --> aMethodNames",
  "documentation": "Return names of all METHOD for a given object",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is an object to scan."
   }
  ],
  "name": "__objGetMethodList",
  "return": {
   "name": "",
   "help": "__objGetMethodList() return an array of character stings with all METHOD names for a given object. __objGetMethodList() would return an empty array {} if the given object does not contain any METHOD."
  }
 },
 {
  "label": "__objGetMsgList( <oObject>, [<lData>], [nClassType] ) --> aNames",
  "documentation": "Return names of all VAR or METHOD for a given object",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is an object to scan."
   },
   {
    "label": "<lData>",
    "documentation": "is an optional logical value that specifies the information to return. A value of .T. instruct the function to return list of all VAR names, .F. return list of all METHOD names. Default value is .T."
   },
   {
    "label": "<nClassType>",
    "documentation": "is on optional numeric code for selecting which class type to return. Default value is HB_MSGLISTALL, returning the whole list."
   }
  ],
  "name": "__objGetMsgList",
  "return": {
   "name": "",
   "help": "__objGetMsgList() return an array of character stings with all VAR names or all METHOD names for a given object. __objGetMsgList() would return an empty array {} if the given object does not contain the requested information."
  }
 },
 {
  "label": "__objGetValueList( <oObject>, [<aExcept>] ) --> aData",
  "documentation": "Return an array of VAR names and values for a given object",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is an object to scan."
   },
   {
    "label": "<aExcept>",
    "documentation": "is an optional array with VAR names you want to exclude from the scan."
   }
  ],
  "name": "__objGetValueList",
  "return": {
   "name": "",
   "help": "__objGetValueList() return a 2D array that contain pairs of a VAR symbol name and the value of VAR. __objGetValueList() would return an empty array {} if the given object does not contain the requested information."
  }
 },
 {
  "label": "__objHasData( <oObject>, <cSymbol> ) --> lExist",
  "documentation": "Determine whether a symbol exist in object as VAR",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is an object to scan."
   },
   {
    "label": "<cSymbol>",
    "documentation": "is the name of the symbol to look for."
   }
  ],
  "name": "__objHasData",
  "return": {
   "name": "",
   "help": "__objHasData() return .T. if the given <cSymbol> exist as VAR (instance variable) in object <oObject), .F. if it does not exist."
  }
 },
 {
  "label": "__objHasMethod( <oObject>, <cSymbol> ) --> lExist",
  "documentation": "Determine whether a symbol exist in object as METHOD",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is an object to scan."
   },
   {
    "label": "<cSymbol>",
    "documentation": "is the name of the symbol to look for."
   }
  ],
  "name": "__objHasMethod",
  "return": {
   "name": "",
   "help": "__objHasMethod() return .T. if the given <cSymbol> exist as METHOD (class function) in object <oObject), .F. if it does not exist."
  }
 },
 {
  "label": "__objModInline( <oObject>, <cInlineName>, <bInline> ) --> oObject",
  "documentation": "Modify (replace) an INLINE method in an already existing class",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is the object to work on."
   },
   {
    "label": "<cInlineName>",
    "documentation": "is the symbol name of the INLINE method to modify."
   },
   {
    "label": "<bInline>",
    "documentation": "is a new code block to associate with the INLINE method."
   }
  ],
  "name": "__objModInline",
  "return": {
   "name": "",
   "help": "__objModInline() return a reference to <oObject>."
  }
 },
 {
  "label": "__objModMethod( <oObject>, <cMethodName>, <nFuncPtr> ) --> oObject",
  "documentation": "Modify (replace) a METHOD in an already existing class",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is the object to work on."
   },
   {
    "label": "<cMethodName>",
    "documentation": "is the symbol name of the METHOD to modify."
   },
   {
    "label": "<nFuncPtr>",
    "documentation": "is a pointer to a new function to associate with the method."
   }
  ],
  "name": "__objModMethod",
  "return": {
   "name": "",
   "help": "__objModMethod() return a reference to <oObject>."
  }
 },
 {
  "label": "__objSetValueList( <oObject>, <aData> ) --> oObject",
  "documentation": "Set object with an array of VAR names and values",
  "arguments": [
   {
    "label": "<oObject>",
    "documentation": "is an object to set."
   },
   {
    "label": "<aData>",
    "documentation": "is a 2D array with a pair of instance variables and values for setting those variable."
   }
  ],
  "name": "__objSetValueList",
  "return": {
   "name": "",
   "help": "__objSetValueList() return a reference to <oObject>."
  }
 },
 {
  "label": "__Quit()",
  "documentation": "Terminates an application.",
  "arguments": [],
  "name": "__Quit"
 },
 {
  "label": "__Run( <cCommand> )",
  "documentation": "Run an external program.",
  "arguments": [
   {
    "label": "<cCommand>",
    "documentation": "Command to execute."
   }
  ],
  "name": "__Run"
 },
 {
  "label": "__SetCentury([<lFlag> | <cOnOff> ] ) --> lPreviousValue",
  "documentation": "Set the Current Century",
  "arguments": [],
  "name": "__SetCentury",
  "return": {
   "name": "",
   "help": "Either the current or previous century setting as a logical value"
  }
 },
 {
  "label": "__SetFunction( <nFunctionKey>, [<cString>] ) --> NIL",
  "documentation": "Assign a character string to a function key",
  "arguments": [
   {
    "label": "<nFunctionKey>",
    "documentation": "is a number in the range 1..40 that represent the function key to be assigned."
   },
   {
    "label": "<cString>",
    "documentation": "is a character string to set. If <cString> is not specified, the function key is going to be set to NIL releasing by that any previous __SetFunction() or SetKey() for that function."
   }
  ],
  "name": "__SetFunction",
  "return": {
   "name": "",
   "help": "__SetFunction() always return NIL."
  }
 },
 {
  "label": "__SetHelpK()",
  "documentation": "Set <F1> as the default help key",
  "arguments": [],
  "name": "__SetHelpK"
 },
 {
  "label": "__TextRestore()",
  "documentation": "Restore console output settings as saved by __TextSave()",
  "arguments": [],
  "name": "__TextRestore"
 },
 {
  "label": "__TextSave( <cFile> )",
  "documentation": "Redirect console output to printer or file and save old settings",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "is either \"PRINTER\" (note the uppercase) in which console output is SET to PRINTER, or a name of a text file with a default `.txt` extension, that is used to redirect console output."
   }
  ],
  "name": "__TextSave"
 },
 {
  "label": "__TypeFile( <cFile>, [<lPrint>] ) --> NIL",
  "documentation": "Show the content of a file on the console and/or printer",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "is a name of the file to display. If the file have an extension, it must be specified (there is no default value)."
   },
   {
    "label": "<lPrint>",
    "documentation": "is an optional logical value that specifies whether the output should go only to the screen (.F.) or to both the screen and printer (.T.), the default is (.F.)."
   }
  ],
  "name": "__TypeFile",
  "return": {
   "name": "",
   "help": "__TypeFile() always return NIL."
  }
 },
 {
  "label": "__Wait( <cMessage> ) --> cKey",
  "documentation": "Stops the application until a key is pressed.",
  "arguments": [
   {
    "label": "<cMessage>",
    "documentation": "is a string."
   }
  ],
  "name": "__Wait",
  "return": {
   "name": "",
   "help": "Pressed key."
  }
 },
 {
  "label": "__XHelp() --> xValue",
  "documentation": "Determines whether a HELP() user defined function exists.",
  "arguments": [],
  "name": "__XHelp",
  "return": {
   "name": "",
   "help": "This function returns aleatory values."
  }
 },
 {
  "label": "__XRestScreen()",
  "documentation": "Restore screen image and coordinate from an internal buffer",
  "arguments": [],
  "name": "__XRestScreen"
 },
 {
  "label": "__XSaveScreen()",
  "documentation": "Save whole screen image and coordinate to an internal buffer",
  "arguments": [],
  "name": "__XSaveScreen"
 },
 {
  "label": ":AddColumn( <oCol> ) --> Self",
  "documentation": "Add an New Column to an TBrowse Object",
  "arguments": [
   {
    "label": "<oCol>",
    "documentation": "Is an TbColumn object"
   }
  ],
  "name": ":AddColumn",
  "return": {
   "name": "<Self>",
   "help": "The Current object"
  }
 },
 {
  "label": ":ApplyKey( <nKey> ) --> nResult",
  "documentation": "Evaluates an code block associated with an specific key",
  "arguments": [
   {
    "label": "<nKey>",
    "documentation": "An valid Inkey code"
   }
  ],
  "name": ":ApplyKey",
  "return": {
   "name": "<nResult>",
   "help": "Value returned from the evaluated Code Block See Table Below <table> Value    Meaning -1       User request for the browse lost input focus 0        Code block associated with <nkey> was evaluated 1        Unable to locate <nKey> in the dictionary, Key was not processed </table>"
  }
 },
 {
  "label": ":SetKey( <nKey>[, <bBlock>] ) --> bOldBlock",
  "documentation": "Get an optionally Set an new Code block associated to a inkey value",
  "arguments": [
   {
    "label": "<nKey>",
    "documentation": "An valid inkey Code"
   },
   {
    "label": "<bBlock>",
    "documentation": "An optional action to associate to the inkey value."
   }
  ],
  "name": ":SetKey",
  "return": {
   "name": "<bOldBlock>",
   "help": "If a key-press has it code block changes, it will return the previous one; otherwise, it will return the current one"
  }
 },
 {
  "label": "AAdd( <aArray>, [<xValue>] ) --> xValue",
  "documentation": "Dynamically add an element to an array",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "The name of an array"
   },
   {
    "label": "<xValue>",
    "documentation": "Element to add to array <aArray>"
   }
  ],
  "name": "AAdd",
  "return": {
   "name": "<xValue>",
   "help": "if specified <xValue>, <xValue> will be returned, otherwise this function returns a NIL value."
  }
 },
 {
  "label": "Abs( <nNumber> ) --> nAbsNumber",
  "documentation": "Return the absolute value of a number.",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "Any number."
   }
  ],
  "name": "Abs",
  "return": {
   "name": "<nAbsNumber>",
   "help": "The absolute numeric value."
  }
 },
 {
  "label": "AChoice( <nTop>, <nLeft>, <nBottom>, <nRight>, <acMenuItems>, [<alSelableItems> | <lSelableItems>], [<cUserFunction> | <bUserBlock>], [<nInitialItem>], [<nWindowRow>] ) --> nPosition",
  "documentation": "Allows selection of an element from an array",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": "- topmost row used to display array (default 0)"
   },
   {
    "label": "<nLeft>",
    "documentation": "- leftmost row used to display array (default 0)"
   },
   {
    "label": "<nBottom>",
    "documentation": "- bottommost row used to display array (default MaxRow())"
   },
   {
    "label": "<nRight>",
    "documentation": "- rightmost row used to display array (default MaxCol())"
   },
   {
    "label": "<acMenuItems>",
    "documentation": "- the character array of items from which to select"
   },
   {
    "label": "<alSelableItems>",
    "documentation": "- an array of items, either logical or character, which is used to determine if a particular item may be selected.  If the type of a given item is character, it is macro evaluated, and the result is expected to be a logical.  A value of .T. means that the item may be selected, .F. that it may not. (See next argument: `lSelectableItems`)"
   },
   {
    "label": "<lSelableItems>",
    "documentation": "- a logical value which is used to apply to all items in `acMenuItems`.  If .T., all items may be selected; if .F., none may be selected. (See previous argument: `alSelectableItems`) Default .T."
   },
   {
    "label": "<cUserFunction>",
    "documentation": "- the name of a function to be called which may affect special processing of keystrokes.  It is specified without parentheses or parameters. When it is called, it will be supplied with the parameters: `nMode`, `nCurElement`, and `nRowPos`. Default NIL."
   },
   {
    "label": "<bUserBlock>",
    "documentation": "- a codeblock to be called which may affect special processing of keystrokes. It should be specified in the form `{| nMode, nCurElemenet, nRowPos | MyFunc( nMode, nCurElemenet, nRowPos ) }`. Default NIL."
   },
   {
    "label": "<nInitialItem>",
    "documentation": "- the number of the element to be highlighted as the current item when the array is initially displayed.  1 origin.  Default 1."
   },
   {
    "label": "<nWindowRow>",
    "documentation": "- the number of the window row on which the initial item is to be displayed. 0 origin.  Default 0."
   }
  ],
  "name": "AChoice",
  "return": {
   "name": "<nPosition>",
   "help": "- the number of the item to be selected, or 0 if the selection was aborted."
  }
 },
 {
  "label": "AClone( <aSource> ) --> aDuplicate",
  "documentation": "Duplicate a  multidimensional array",
  "arguments": [
   {
    "label": "<aSource>",
    "documentation": "Name of the array to be cloned."
   }
  ],
  "name": "AClone",
  "return": {
   "name": "<aDuplicate>",
   "help": "A new array pointer reference complete with nested array values."
  }
 },
 {
  "label": "ACopy( <aSource>, <aTarget>, [<nStart>], [<nCount>], [<nTargetPos>] ) --> aTarget",
  "documentation": "Copy elements from one array to another",
  "arguments": [
   {
    "label": "<aSource>",
    "documentation": "is the array to copy elements from."
   },
   {
    "label": "<aTarget>",
    "documentation": "is the array to copy elements to."
   },
   {
    "label": "<nStart>",
    "documentation": "is the beginning subscript position to copy from <aSource>"
   },
   {
    "label": "<nCount>",
    "documentation": "the number of subscript elements to copy from <aSource>."
   },
   {
    "label": "<nTargetPos>",
    "documentation": "the starting subscript position in <aTarget> to copy elements to."
   }
  ],
  "name": "ACopy",
  "return": {
   "name": "<aTarget>",
   "help": "an array pointer reference"
  }
 },
 {
  "label": "Acos( nCosine ) -> nRadiant",
  "documentation": "Arcus cosine of the argument",
  "arguments": [
   {
    "label": "<nCosine>",
    "documentation": "the cosine of an angle"
   }
  ],
  "name": "Acos",
  "return": {
   "name": "<nRadiant>",
   "help": "the angle whose cosine is <nCosine>"
  }
 },
 {
  "label": "ADays() --> aDays",
  "documentation": "Returns an array with the days names.",
  "arguments": [],
  "name": "ADays",
  "return": {
   "name": "<aDays>",
   "help": "The array which holds the days names."
  }
 },
 {
  "label": "AddAscii( <[@]cString>, <nValue>, [<nPosition>], [<lCarryOver>] ) --> cString",
  "documentation": "Add an integer value to an ascii value of a string",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "is the string that should be edited"
   },
   {
    "label": "<nValue>",
    "documentation": "is a integer value that should be added to the ASCII value of the character at the <nPosition>th position [<nPosition>]  is the position of the character that should be edited. If not supplied, the last character of <[@]cString> is edited. [<lCarryOver>] NEW: is set to .T. if the substring from position 1 to position <nPosition> should be treated as an integer written to the base 256. Thus, the addition of <nValue> can affect to whole substring (see EXAMPLES). Default is .F., the original behaviour of this function."
   }
  ],
  "name": "AddAscii",
  "return": {
   "name": "",
   "help": "The edited string is returned. The return value can be suppressed by using the CSetRef() function. The string must then be passed by reference [@]."
  }
 },
 {
  "label": "AddMonth( [<dDate>,] <nMonths> ) -> dShiftedDate",
  "documentation": "add months to a date",
  "arguments": [],
  "name": "AddMonth"
 },
 {
  "label": "ADel( <aArray>, <nPos> ) --> aArray",
  "documentation": "Delete an element from an array.",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "Name of array from which an element is to be removed."
   },
   {
    "label": "<nPos>",
    "documentation": "Subscript of the element to be removed."
   }
  ],
  "name": "ADel",
  "return": {
   "name": "<aArray>",
   "help": "an array pointer reference."
  }
 },
 {
  "label": "ADir( [<cFileMask>], [<aName>], [<aSize>], [<aDate>], [<aTime>], [<aAttr>] ) --> nDirEntries",
  "documentation": "Fill pre-defined arrays with file/directory information",
  "arguments": [
   {
    "label": "<cFileMask>",
    "documentation": "File mask to include in the function return. It could contain path and standard wildcard characters as supported by your OS (like * and ?). If you omit <cFileMask> or if <cFileMask> contains no path, then the path from SET DEFAULT is used."
   },
   {
    "label": "<aName>",
    "documentation": "Array to fill with file name of files that meet <cFileMask>. Each element is a Character string and include the file name and extension without the path. The name is the long file name as reported by the OS and not necessarily the 8.3 uppercase name."
   },
   {
    "label": "<aSize>",
    "documentation": "Array to fill with file size of files that meet <cFileMask>. Each element is a Numeric integer for the file size in Bytes. Directories are always zero in size."
   },
   {
    "label": "<aDate>",
    "documentation": "Array to fill with file last modification date of files that meet <cFileMask>. Each element is of type Date."
   },
   {
    "label": "<aTime>",
    "documentation": "Array to fill with file last modification time of files that meet <cFileMask>. Each element is a Character string in the format HH:mm:ss."
   },
   {
    "label": "<aAttr>",
    "documentation": "Array to fill with attribute of files that meet <cFileMask>. Each element is a Character string, see Directory() for information about attribute values. If you pass array to <aAttr>, the function is going to return files with normal, hidden, system and directory attributes. If <aAttr> is not specified or with type other than Array, only files with normal attribute would return."
   }
  ],
  "name": "ADir",
  "return": {
   "name": "",
   "help": "ADir() return the number of file entries that meet <cFileMask>"
  }
 },
 {
  "label": "AdsBlob2File( <cFileName>, <cFieldName> ) --> lSuccess",
  "documentation": "Write a Binary (memo) field's contents to a file",
  "arguments": [
   {
    "label": "<cFileName>",
    "documentation": "File to create. If it already exists, it will be overwritten on success and destroyed on error."
   },
   {
    "label": "<cFieldName>",
    "documentation": "Field in the current workarea that contains binary data."
   }
  ],
  "name": "AdsBlob2File",
  "return": {
   "name": "<lSuccess>",
   "help": "True if the file is successfully written."
  }
 },
 {
  "label": "AdsCacheOpenCursors( <nOpen> ) -> nRetVal",
  "documentation": "Provides caching of open cursors",
  "arguments": [
   {
    "label": "<nOpen>",
    "documentation": "Number of cursors to cache."
   }
  ],
  "name": "AdsCacheOpenCursors",
  "return": {
   "name": "<nRetVal>",
   "help": "???"
  }
 },
 {
  "label": "AdsCacheOpenTables( <nOpen> ) -> nRetVal",
  "documentation": "Provides caching of open tables",
  "arguments": [
   {
    "label": "<nOpen>",
    "documentation": "Number of tables to cache."
   }
  ],
  "name": "AdsCacheOpenTables",
  "return": {
   "name": "<nRetVal>",
   "help": "???"
  }
 },
 {
  "label": "AdsClearAOF()",
  "documentation": "Clears an Advantage Optimized Filter in the current workarea.",
  "arguments": [],
  "name": "AdsClearAOF",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "AdsCloseCachedTables( [<hConnection>] ) -> nRetVal",
  "documentation": "Close all cached tables on the given connection",
  "arguments": [
   {
    "label": "<hConnection>",
    "documentation": "A connection handle retrieved via AdsConnect() or AdsConnect60(). If omitted, the RDD's current connection handle is used, but this only exists if AdsConnect() or AdsConnect60() were previously called."
   }
  ],
  "name": "AdsCloseCachedTables",
  "return": {
   "name": "<nRetVal>",
   "help": "???"
  }
 },
 {
  "label": "AdsClrCallback() --> NIL",
  "documentation": "Clears the callback set by AdsRegCallback().",
  "arguments": [],
  "name": "AdsClrCallback",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "AdsConnect60( <cFilePath>, <nServertype>, [<cUserName>], [<cUserPass>], [<nOptions>] ) -> lSuccess",
  "documentation": "Connect to a local/remote/internet server",
  "arguments": [
   {
    "label": "<cFilePath>",
    "documentation": "Name of data dictionary to connect to."
   },
   {
    "label": "<nServertype>",
    "documentation": "The server type to connect (LOCAL, REMOTE, AIS or all together)"
   },
   {
    "label": "<cUserName>",
    "documentation": "Optional Name of the user connecting to the server"
   },
   {
    "label": "<cUserPass>",
    "documentation": "Optional password for the user Name"
   },
   {
    "label": "<nOptions>",
    "documentation": "The optional connection options"
   }
  ],
  "name": "AdsConnect60",
  "return": {
   "name": "<lSuccess>",
   "help": "True if connected, otherwise False."
  }
 },
 {
  "label": "AdsCustomizeAOF( [<nRecno | aRecNos>] [, <nType>] ) --> nSuccess",
  "documentation": "Add or remove records from an existing AOF",
  "arguments": [
   {
    "label": "<nRecno | aRecNos>",
    "documentation": "Can be either a single record number or an array of record numbers to add or delete from the AOF. If omitted, defaults to the current record."
   },
   {
    "label": "<nType>",
    "documentation": "The type of operation:"
   },
   {
    "label": "<table-noheader>",
    "documentation": " ADS_AOF_ADD_RECORD      Add the record to the AOF (set the bit). This is the default operation. ADS_AOF_REMOVE_RECORD   Remove the record from the AOF (clear the bit). ADS_AOF_TOGGLE_RECORD   Switch the record into or out of the AOF."
   },
   {
    "label": "</table>",
    "documentation": ""
   }
  ],
  "name": "AdsCustomizeAOF",
  "return": {
   "name": "<nError>",
   "help": "ADS error code, or 0 for success."
  }
 },
 {
  "label": "AdsDDAddTable( <cTableName>, <cFileName>, <cIndexFileName> ) --> lSuccess",
  "documentation": "Add a new table to a Data dictionary",
  "arguments": [
   {
    "label": "<cTableName>",
    "documentation": "Name of the table inside the data dictionary"
   },
   {
    "label": "<cFileName>",
    "documentation": "Name of the adt or dbf file name"
   },
   {
    "label": "<cIndexFileName>",
    "documentation": "Optional name of the index file"
   }
  ],
  "name": "AdsDDAddTable",
  "return": {
   "name": "<lSuccess>",
   "help": "-> .T. if file was added, otherwise .F."
  }
 },
 {
  "label": "AdsEvalAOF( <cFilter> ) --> nOptimizationLevel",
  "documentation": "Evaluate a filter expression to determine its optimization level",
  "arguments": [
   {
    "label": "<cFilter>",
    "documentation": "Expression to test."
   }
  ],
  "name": "AdsEvalAOF",
  "return": {
   "name": "<nOptimizationLevel>",
   "help": "</par> Values are defined in ads.ch: ADS_OPTIMIZED_FULL, ADS_OPTIMIZED_PART, ADS_OPTIMIZED_NONE. IMPORTANT NOTE: These values are NOT the same as those returned by dbOrderInfo()."
  }
 },
 {
  "label": "AdsFile2Blob( <cFileName>, <cFieldName>, <nBinaryType> ) --> lSuccess",
  "documentation": "Save a Binary file to a field",
  "arguments": [
   {
    "label": "<cFileName>",
    "documentation": "File to read. Can be in UNC format. A common example is an image file."
   },
   {
    "label": "<cFieldName>",
    "documentation": "Field in the current workarea to contain the binary data."
   },
   {
    "label": "<nBinaryType>",
    "documentation": "Either ADS_BINARY (the default) or ADS_IMAGE. This parameter is for fields in DBF files. ADT tables cannot store binary and image data in standard character memo fields (they have specific field types for that)."
   }
  ],
  "name": "AdsFile2Blob",
  "return": {
   "name": "<lSuccess>",
   "help": "True if the file is successfully written."
  }
 },
 {
  "label": "AdsGetAOF() --> cFilter",
  "documentation": "Retrieve the filter expression used in the call to AdsSetAOF()",
  "arguments": [],
  "name": "AdsGetAOF",
  "return": {
   "name": "<cFilter>",
   "help": "The filter expression used in the call to AdsSetAOF()."
  }
 },
 {
  "label": "AdsGetAOFNoOpt() --> cFilterFragment",
  "documentation": "Return the non-optimized portion of the current filter expression",
  "arguments": [],
  "name": "AdsGetAOFNoOpt",
  "return": {
   "name": "<cFilterFragment>",
   "help": "If an AOF filter expression is not fully optimizable, the non-optimizable part of the expression can be retrieved with this function."
  }
 },
 {
  "label": "AdsGetAOFOptLevel() --> nOptimizationLevel",
  "documentation": "Returns optimization level of the current AOF filter",
  "arguments": [],
  "name": "AdsGetAOFOptLevel",
  "return": {
   "name": "<nOptimizationLevel>",
   "help": "</par> Values are defined in ads.ch: ADS_OPTIMIZED_FULL, ADS_OPTIMIZED_PART, ADS_OPTIMIZED_NONE."
  }
 },
 {
  "label": "AdsGetConnectionType( [<hConnection>] ) --> nConnectionType",
  "documentation": "Returns the type of Server used by the given connection handle.",
  "arguments": [
   {
    "label": "<hConnection>",
    "documentation": "A connection handle retrieved via AdsConnect() or AdsConnect60(). If omitted, the RDD's current connection handle is used, but this only exists if AdsConnect() or AdsConnect60() were previously called."
   }
  ],
  "name": "AdsGetConnectionType",
  "return": {
   "name": "",
   "help": "The type of Advantage Server that the connection uses, either ADS_REMOTE_SERVER, ADS_AIS_SERVER, or ADS_LOCAL_SERVER."
  }
 },
 {
  "label": "AdsGetLastError() --> nErrorCode",
  "documentation": "Returns any error code generated by the most recent ADS API call",
  "arguments": [],
  "name": "AdsGetLastError",
  "return": {
   "name": "",
   "help": "The error code generated by the most recent ADS API call. Zero for success."
  }
 },
 {
  "label": "AdsGetRelKeyPos() --> nKeyPos",
  "documentation": "Estimated key position of current record within the current index",
  "arguments": [],
  "name": "AdsGetRelKeyPos",
  "return": {
   "name": "",
   "help": "A value between 0.0 and 1.0, inclusive."
  }
 },
 {
  "label": "AdsGetTableConType() --> nConnectionType",
  "documentation": "Returns the type of Server used by current workarea.",
  "arguments": [],
  "name": "AdsGetTableConType",
  "return": {
   "name": "",
   "help": "The type of Advantage Server that the current workarea uses, either ADS_REMOTE_SERVER, ADS_AIS_SERVER, or ADS_LOCAL_SERVER. Returns zero if the current workarea does not have an Advantage table opened."
  }
 },
 {
  "label": "AdsIsExprValid( <cExp> ) --> lSuccess",
  "documentation": "Determine if the ADS server can parse an expression",
  "arguments": [
   {
    "label": "<cExp>",
    "documentation": "Any hopefully valid expression; often a filter string"
   }
  ],
  "name": "AdsIsExprValid",
  "return": {
   "name": "",
   "help": ".T. if the expression is understood by ADS."
  }
 },
 {
  "label": "AdsIsIndexed() --> lActiveIndex",
  "documentation": "Fast determination for if current workarea has a selected index",
  "arguments": [],
  "name": "AdsIsIndexed",
  "return": {
   "name": "<lActiveIndex>",
   "help": ""
  }
 },
 {
  "label": "AdsIsRecordInAOF( [<nRecNo>] ) --> lSatisfiesFilter",
  "documentation": "Determine if a record is in the current AOF",
  "arguments": [
   {
    "label": "<nRecNo>",
    "documentation": "Record number to test. Default is current record."
   }
  ],
  "name": "AdsIsRecordInAOF",
  "return": {
   "name": "",
   "help": "True if the record satisfies the filter criteria."
  }
 },
 {
  "label": "AdsKeyCount( [<xTag>], <cIgnoredIndexFile>, [<nFilterOption>] ) --> nKeyCount",
  "documentation": "Retrieve the number of keys in a specified index",
  "arguments": [
   {
    "label": "<xTag>",
    "documentation": "Numeric order number OR index tag name. Default is current index."
   },
   {
    "label": "<cIgnoredIndexFile>",
    "documentation": "This parameter is not processed. In other Harbour RDDs, the second parameter to \"ordKeyCount\" takes a second argument to identify a particular Index File in cases where two files are open that contain orders with the same name. The ADS driver does not support this and will select the first order with the requested name. To stay consistent with other RDDs, therefore, the second parameter is reserved and the"
   },
   {
    "label": "<nFilterOption>",
    "documentation": "is passed as a third parameter."
   },
   {
    "label": "<nFilterOption>",
    "documentation": "Indicates if filters and/or scopes are to be respected if set. Options are defined in ads.ch:"
   },
   {
    "label": "<table-noheader>",
    "documentation": " ADS_RESPECTFILTERS   Respect filters and scopes ADS_IGNOREFILTERS    Ignore filters and scopes ADS_RESPECTSCOPES    Respect scopes only"
   },
   {
    "label": "</table>",
    "documentation": ""
   }
  ],
  "name": "AdsKeyCount",
  "return": {
   "name": "<nKeyCount>",
   "help": "The number of keys within the current index."
  }
 },
 {
  "label": "AdsKeyNo( [<xTag>], <cIgnoredIndexFile>, [<nFilterOption>] ) --> nKeyNo",
  "documentation": "Get the logical key number of the current record in the given index",
  "arguments": [
   {
    "label": "<xTag>",
    "documentation": "Numeric order number OR index tag name. Default is current index."
   },
   {
    "label": "<cIgnoredIndexFile>",
    "documentation": "This parameter is not processed. In other Harbour RDDs, the second parameter to \"ordKeyNo\" takes a second argument to identify a particular Index File in cases where two files are open that contain orders with the same name. The ADS driver does not support this and will select the first order with the requested name. To stay consistent with other RDDs, therefore, the second parameter is reserved and the"
   },
   {
    "label": "<nFilterOption>",
    "documentation": "is passed as a third parameter."
   },
   {
    "label": "<nFilterOption>",
    "documentation": "Indicates if filters and/or scopes are to be respected if set. Options are defined in ads.ch:"
   },
   {
    "label": "<table-noheader>",
    "documentation": " ADS_RESPECTFILTERS   Respect filters and scopes ADS_IGNOREFILTERS    Ignore filters and scopes ADS_RESPECTSCOPES    Respect scopes only"
   },
   {
    "label": "</table>",
    "documentation": ""
   }
  ],
  "name": "AdsKeyNo",
  "return": {
   "name": "<nKeyNo>",
   "help": "The logical key number of the current record in the given index."
  }
 },
 {
  "label": "AdsLocking( <lMode> ) --> lPriorSetting",
  "documentation": "Turns on/off the Advantage proprietary locking mode",
  "arguments": [
   {
    "label": "<lMode>",
    "documentation": ".T. to use the Advantage proprietary locking mode (this is the default setting if a remote server is used) or pass .F. to use \"compatibility\" locking."
   }
  ],
  "name": "AdsLocking",
  "return": {
   "name": "<lPriorSetting>",
   "help": ".T. if prior setting was for the proprietary mode."
  }
 },
 {
  "label": "AdsRefreshAOF()",
  "documentation": "Update the filter snapshot",
  "arguments": [],
  "name": "AdsRefreshAOF",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "AdsRegCallback( <bEval> )  --> NIL",
  "documentation": "For Progress displays: Sets a codeblock to be called during indexing",
  "arguments": [
   {
    "label": "<bEval>",
    "documentation": "The codeblock that is eval'ed every 2 seconds during indexing. A numeric value of the \"percent completed\" is passed to the codeblock by the ADS server. The codeblock should return a logical value: .T. to abort or .F. to not stop indexing."
   }
  ],
  "name": "AdsRegCallback",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "AdsRightsCheck( <lMode> ) --> lPriorSetting",
  "documentation": "Sets the \"rights checking\" setting for opening files",
  "arguments": [
   {
    "label": "<lMode>",
    "documentation": ".T. to check rights upon opening data files (the default), or .F. to ignore rights"
   }
  ],
  "name": "AdsRightsCheck",
  "return": {
   "name": "<lPriorSetting>",
   "help": ""
  }
 },
 {
  "label": "AdsSetAOF( <cFilter> [, <nResolveOption>] ) --> lSuccess",
  "documentation": "Create an Advantage Optimized Filter",
  "arguments": [
   {
    "label": "<cFilter>",
    "documentation": "Filter expression to set."
   },
   {
    "label": "<nResolveOption>",
    "documentation": "Option to indicate how the filter should be resolved in the event that the expression cannot be fully optimized. Options are defined in ads.ch: ADS_RESOLVE_IMMEDIATE, ADS_RESOLVE_DYNAMIC."
   }
  ],
  "name": "AdsSetAOF",
  "return": {
   "name": "<lSuccess>",
   "help": "True if AOF is created."
  }
 },
 {
  "label": "AdsSetCharType( <nCharType>, [lOEM] ) --> nPriorSetting",
  "documentation": "Sets the type of character data expected when opening tables.",
  "arguments": [
   {
    "label": "<nCharType>",
    "documentation": "Type of character data in the table. From ADS docs: Options are ADS_ANSI and ADS_OEM. This indicates the type of character data to be stored in the table. For compatibility with DOS-based CA-Cl*pper applications, ADS_OEM should be specified. When usTableType is ADS_ADT, this parameter is ignored and ANSI is always used."
   },
   {
    "label": "<lOEM>",
    "documentation": "This parameter used for console mode applications, when character data stored in OEM charset. If lOEM is passed as .T., rddads doesn't convert character data into ANSI charset."
   }
  ],
  "name": "AdsSetCharType",
  "return": {
   "name": "<nPriorSetting>",
   "help": ""
  }
 },
 {
  "label": "AdsSetDefault( [<cPath>] ) --> cPriorSetting",
  "documentation": "Get/Set function for ADS's DEFAULT setting.",
  "arguments": [
   {
    "label": "<cPath>",
    "documentation": "Sets new value if passed."
   }
  ],
  "name": "AdsSetDefault",
  "return": {
   "name": "<cPriorSetting>",
   "help": ""
  }
 },
 {
  "label": "AdsSetDeleted( [<lOnOff>] ) --> lPriorSetting",
  "documentation": "Get/Set function for ADS's ShowDeleted() setting.",
  "arguments": [
   {
    "label": "<lOnOff>",
    "documentation": "Sets new value if passed. The value is parallel to Harbour usage, so pass .F. to see deleted records or .T. to hide them. (This is inverted from ADS's AdsShowDeleted() syntax.)"
   }
  ],
  "name": "AdsSetDeleted",
  "return": {
   "name": "<lPriorSetting>",
   "help": ""
  }
 },
 {
  "label": "AdsSetExact( [<lOnOff>] ) --> lPriorSetting",
  "documentation": "Get/Set function for ADS's AdsSetExact() setting.",
  "arguments": [
   {
    "label": "<lOnOff>",
    "documentation": "Sets new value if passed."
   }
  ],
  "name": "AdsSetExact",
  "return": {
   "name": "<lPriorSetting>",
   "help": ""
  }
 },
 {
  "label": "AdsSetSearchPath( [<cPath>] ) --> cPriorSetting",
  "documentation": "Get/Set function for ADS's AdsSetSearchPath() setting.",
  "arguments": [
   {
    "label": "<cPath>",
    "documentation": "Sets new value if passed."
   }
  ],
  "name": "AdsSetSearchPath",
  "return": {
   "name": "<cPriorSetting>",
   "help": ""
  }
 },
 {
  "label": "ADSSetSelKeyPos( <nPercent> ) --> nError",
  "documentation": "GoTo the given estimated key position within the current index",
  "arguments": [
   {
    "label": "<nPercent>",
    "documentation": "Relative key position between 0.0 and 1.0, inclusive."
   }
  ],
  "name": "ADSSetSelKeyPos",
  "return": {
   "name": "",
   "help": "The return/error value of the ADS API call."
  }
 },
 {
  "label": "AdsTestRecLocks( <lOnOff> ) --> lPriorSetting",
  "documentation": "Turn On or Off a \"debug mode\" for trapping missed record locks.",
  "arguments": [
   {
    "label": "<lOnOff>",
    "documentation": "New setting. Default is FALSE."
   }
  ],
  "name": "AdsTestRecLocks",
  "return": {
   "name": "",
   "help": "Prior Setting."
  }
 },
 {
  "label": "AEval( <aArray>, <bBlock>, [<nStart>], [<nCount>] ) --> aArray",
  "documentation": "Evaluates the subscript element of an array",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "Is the array to be evaluated."
   },
   {
    "label": "<bBlock>",
    "documentation": "Is a code block to evaluate for each element processed."
   },
   {
    "label": "<nStart>",
    "documentation": "The beginning array element index to evaluate."
   },
   {
    "label": "<nCount>",
    "documentation": "The number of elements to process."
   }
  ],
  "name": "AEval",
  "return": {
   "name": "<aArray>",
   "help": "an array pointer reference."
  }
 },
 {
  "label": "AFields( <aNames>, [<aTypes>], [<aLen>], [<aDecs>] ) --> nFields",
  "documentation": "Fills referenced arrays with database field information",
  "arguments": [
   {
    "label": "<aNames>",
    "documentation": "Array of field names"
   },
   {
    "label": "<aTypes>",
    "documentation": "Array of field names"
   },
   {
    "label": "<aLens>",
    "documentation": "Array of field names"
   },
   {
    "label": "<aDecs>",
    "documentation": "Array of field names"
   }
  ],
  "name": "AFields",
  "return": {
   "name": "<nFields>",
   "help": "Number of fields in a database or work area"
  }
 },
 {
  "label": "AFill( <aArray>, <xValue>, [<nStart>], [<nCount>] ) --> aArray",
  "documentation": "Fill an array with a specified value",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "Name of array to be filled."
   },
   {
    "label": "<xValue>",
    "documentation": "Expression to be globally filled in <aArray>"
   },
   {
    "label": "<nStart>",
    "documentation": "Subscript starting position"
   },
   {
    "label": "<nCount>",
    "documentation": "Number of subscript to be filled"
   }
  ],
  "name": "AFill",
  "return": {
   "name": "<aArray>",
   "help": "pointer to the array."
  }
 },
 {
  "label": "AfterAtNum( <cStringToMatch>, <cString>, [<nCounter>], [<nIgnore>] ) --> cRestString",
  "documentation": "Returns string portion after nth occurence of substring",
  "arguments": [
   {
    "label": "<cStringToMatch>",
    "documentation": "is the substring scanned for"
   },
   {
    "label": "<cString>",
    "documentation": "is the scanned string [<nCounter>]        determines how many occurences are of"
   },
   {
    "label": "<cStringToMatch>",
    "documentation": "in <cString> are searched Default: search last occurence [<nIgnore>]         determines how many character from the start should be ignored in the search Default: 0"
   }
  ],
  "name": "AfterAtNum",
  "return": {
   "name": "<cRestString>",
   "help": "the portion of <cString> after the <nCounter>th occurence of <cStringToMatch> in <cString> If such a rest does not exist, an empty string is returned."
  }
 },
 {
  "label": "AIns( <aArray>, <nPos> ) --> aArray",
  "documentation": "Insert a NIL value at an array subscript position.",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "Array name."
   },
   {
    "label": "<nPos>",
    "documentation": "Subscript position in <aArray>"
   }
  ],
  "name": "AIns",
  "return": {
   "name": "",
   "help": "a reference to <aArray>."
  }
 },
 {
  "label": "Alert( <xMessage>, [<aOptions>], [<cColorNorm>], [<nDelay>] ) --> nChoice or NIL",
  "documentation": "Display a dialog box with a message",
  "arguments": [
   {
    "label": "<xMessage>",
    "documentation": "Message to display in the dialog box. <xMessage> can be of any Harbour type. If <xMessage> is an array of Character strings, each element would be displayed in a new line. If <xMessage> is a Character string, you could split the message to several lines by placing a semicolon `;` in the desired places."
   },
   {
    "label": "<aOptions>",
    "documentation": "Array with available response. Each element should be Character string. If omitted, default is `{ \"Ok\" }`."
   },
   {
    "label": "<cColorNorm>",
    "documentation": "Color string to paint the dialog box with. If omitted, default color is `\"W+/R\"`."
   },
   {
    "label": "<nDelay>",
    "documentation": "Number of seconds to wait to user response before abort. Default value is 0, that wait forever."
   }
  ],
  "name": "Alert",
  "return": {
   "name": "",
   "help": "Alert() return Numeric value representing option number chosen. If <Esc> was pressed, return value is zero. The return value is NIL if Alert() is called with no parameters, or if <xMessage> type is not Character and HB_CLP_STRICT option was used. If <nDelay> seconds had passed without user response, the return value is 1."
  }
 },
 {
  "label": "Alias( [<nWorkArea>] ) --> cWorkArea",
  "documentation": "Returns the alias name of a work area",
  "arguments": [
   {
    "label": "<nWorkArea>",
    "documentation": "Number of a work area"
   }
  ],
  "name": "Alias",
  "return": {
   "name": "<cWorkArea>",
   "help": "Name of alias"
  }
 },
 {
  "label": "AllTrim( <cString> ) --> cExpression",
  "documentation": "Removes leading and trailing blank spaces from a string",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Any character string"
   }
  ],
  "name": "AllTrim",
  "return": {
   "name": "<cExpression>",
   "help": "An string will all blank spaces removed from <cString>"
  }
 },
 {
  "label": "AMonths() --> aMonths",
  "documentation": "Returns an array with the months names.",
  "arguments": [],
  "name": "AMonths",
  "return": {
   "name": "<aMonths>",
   "help": "The array which holds the months names."
  }
 },
 {
  "label": "Array( <nElements>[, <nElements>...] ) --> aArray",
  "documentation": "Create an uninitialized array of specified length",
  "arguments": [
   {
    "label": "<nElements>",
    "documentation": "is the number of elements in the specified dimension."
   }
  ],
  "name": "Array",
  "return": {
   "name": "<aArray>",
   "help": "an array of specified dimensions."
  }
 },
 {
  "label": "Asc( <cCharacter> ) --> nAscNumber",
  "documentation": "Returns the ASCII value of a character",
  "arguments": [
   {
    "label": "<cCharacter>",
    "documentation": "Any character expression"
   }
  ],
  "name": "Asc",
  "return": {
   "name": "<nAscNumber>",
   "help": "ASCII value"
  }
 },
 {
  "label": "AScan( <aArray>, <xSearch>, [<nStart>], [<nCount>] ) --> nStoppedAt",
  "documentation": "Scan array elements for a specified condition",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "Array to be scanned."
   },
   {
    "label": "<xSearch>",
    "documentation": "Expression to search for in <aTarget>"
   },
   {
    "label": "<nStart>",
    "documentation": "Beginning subscript position at which to start the search."
   },
   {
    "label": "<nCount>",
    "documentation": "Number of elements to scan with <aTarget>."
   }
  ],
  "name": "AScan",
  "return": {
   "name": "<nStoppedAt>",
   "help": "A numeric value of subscript position where <xSearch> was found, or 0 if <xSearch> is not found."
  }
 },
 {
  "label": "AsciiSum( <cString> ) --> nAsciiSum",
  "documentation": "calculate the sum of the ASCII values of the characters in a string",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "the string to be processed"
   }
  ],
  "name": "AsciiSum",
  "return": {
   "name": "<nAsciiSum>",
   "help": "sum of the ASCII values in <cString>"
  }
 },
 {
  "label": "AscPos( <cString>, [<nPosition>] ) --> nAsciiValue",
  "documentation": "ASCII value of a character at a certain position",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "is the processed string [<nPosition>]  is an optional position within <cString> Default: last position in <cString>"
   }
  ],
  "name": "AscPos",
  "return": {
   "name": "<nAsciiValue>",
   "help": "the ASCII value of the character at the specified position"
  }
 },
 {
  "label": "Asin( nSine ) -> nRadiant",
  "documentation": "Arcus sine of the argument",
  "arguments": [
   {
    "label": "<nSine>",
    "documentation": "the sine of an angle"
   }
  ],
  "name": "Asin",
  "return": {
   "name": "<nRadiant>",
   "help": "the angle whose sine is <nSine>"
  }
 },
 {
  "label": "ASize( <aArray>, <nLen> ) --> aArray",
  "documentation": "Adjust the size of an array",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "Name of array to be dynamically altered"
   },
   {
    "label": "<nLen>",
    "documentation": "Numeric value representing the new size (i.e. number of elements) of <aArray>"
   }
  ],
  "name": "ASize",
  "return": {
   "name": "",
   "help": "The function returns a reference to <aArray>."
  }
 },
 {
  "label": "ASort( <aArray>, [<nStart>], [<nCount>], [<bSort>] ) --> aArray",
  "documentation": "Sort an array",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "Array to be sorted."
   },
   {
    "label": "<nStart>",
    "documentation": "The first element to start the sort from, default is 1."
   },
   {
    "label": "<nCount>",
    "documentation": "Number of elements starting from <nStart> to sort, default is all elements."
   },
   {
    "label": "<bSort>",
    "documentation": "Code block for sorting order, default is ascending order `{| x, y | x < y }`. The code block should accept two parameters and must return .T. if the sort is in order, .F. if not."
   }
  ],
  "name": "ASort",
  "return": {
   "name": "<aArray>",
   "help": "reference to the now sorted <aArray> or NIL if the passed <aArray> is not an array."
  }
 },
 {
  "label": "At( <cSearch>, <cString> ) --> nPos",
  "documentation": "Locates the position of a substring in a main string.",
  "arguments": [
   {
    "label": "<cSearch>",
    "documentation": "Substring to search for"
   },
   {
    "label": "<cString>",
    "documentation": "Main string"
   }
  ],
  "name": "At",
  "return": {
   "name": "",
   "help": "At() return the starting position of the first occurrence of the substring in the main string"
  }
 },
 {
  "label": "AtAdjust( <cStringToMatch>, <cString>, <nAdjustPosition>, [<nCounter>], [<nIgnore>], [<nFillChar|cFillChar>] ) -> cString",
  "documentation": "Adjusts a sequence within a string to a specified position",
  "arguments": [
   {
    "label": "<cStringToMatch>",
    "documentation": "is the sequence to be adjusted within <cString>"
   },
   {
    "label": "<cString>",
    "documentation": "is the string that contains <cStringToMatch>"
   },
   {
    "label": "<nAdjustPosition>",
    "documentation": "specifies the position to that <cStringToMatch> will be adjusted [<nCounter>]            specifies which occurence of <cStringToMatch> in <cString> is to be adjusted Default: last occurence [<nIgnore>]             specifies how many characters should be omitted in the scan [<nFillChar|cFillChar>] specifies the character that is used for the adjustment"
   }
  ],
  "name": "AtAdjust",
  "return": {
   "name": "",
   "help": "cString                 the changed string"
  }
 },
 {
  "label": "ATail( <aArray> ) --> xValue",
  "documentation": "Returns the last element of an array",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "is the array."
   }
  ],
  "name": "ATail",
  "return": {
   "name": "<xValue>",
   "help": "the value of the last element in the array."
  }
 },
 {
  "label": "Atan( nTangent ) -> nRadiant",
  "documentation": "Arcus tangent of the argument",
  "arguments": [
   {
    "label": "<nTangent>",
    "documentation": "the tangent of an angle"
   }
  ],
  "name": "Atan",
  "return": {
   "name": "<nRadiant>",
   "help": "the angle whose tangent is <nTangent>"
  }
 },
 {
  "label": "Atn2( nSine, nCosine ) -> nRadiant",
  "documentation": "Arcus tangent a sine and a cosine argument",
  "arguments": [
   {
    "label": "<nSine>",
    "documentation": "the sine of an angle"
   },
   {
    "label": "<nCosine>",
    "documentation": "the cosine of an angle"
   }
  ],
  "name": "Atn2",
  "return": {
   "name": "<nRadiant>",
   "help": "the angle whose tangent is <nSine>/<nCosine>"
  }
 },
 {
  "label": "AtNum( <cStringToMatch>, <cString>, [<nCounter>], [<nIgnore>] ) --> nPosition",
  "documentation": "Returns the start position of the nth occurence of a substring in a string",
  "arguments": [
   {
    "label": "<cStringToMatch>",
    "documentation": "is the substring scanned for"
   },
   {
    "label": "<cString>",
    "documentation": "is the scanned string [<nCounter>]        determines how many occurences are of"
   },
   {
    "label": "<cStringToMatch>",
    "documentation": "in <cString> are searched Default: search last occurence [<nIgnore>]         determines how many character from the start should be ignored in the search Default: 0"
   }
  ],
  "name": "AtNum",
  "return": {
   "name": "<nPosition>",
   "help": "the position of the <nCounter>th occurence of <cStringToMatch> in <cString>. If such an occurence does not exist, 0 is returned."
  }
 },
 {
  "label": "AtRepl( <cStringToMatch>, <cString>, <cReplacement>, [<nCounter>], [<lMode>], [<nIgnore>] ) --> cString",
  "documentation": "Search and replace sequences in a string",
  "arguments": [
   {
    "label": "<cStringToMatch>",
    "documentation": "is the substring searched for in <cString>"
   },
   {
    "label": "<cString>",
    "documentation": "is the processed string"
   },
   {
    "label": "<cReplacement>",
    "documentation": "is the replacement for sequences found [<nCounter>]       specifies the number of replacements Default: last occurence [<lMode>]          if set to .T., only the <nCounter>th sequence of <cStringToMatch> will be replaced, else all sequences will be replaced. Default: .F. [<nIgnore>])       specifies how many characters in <cString> from the beginning should be ignored by the function Default: 0"
   }
  ],
  "name": "AtRepl",
  "return": {
   "name": "<cString>",
   "help": ""
  }
 },
 {
  "label": "AtToken( <cString>, [<cTokenizer>], [<nTokenCount>], [<nSkipWidth>] ) -> nPosition",
  "documentation": "Position of a token in a string",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "is the processed string [<cTokenizer>]     is a list of characters separating the tokens in <cString> Default: Chr( 0 ) + Chr( 9 ) + Chr( 10 ) + Chr( 13 ) + Chr( 26 ) + hb_BChar( 138 ) + hb_BChar( 141 ) + Chr( 32 ) + \",.;:!\\?/\\\\<>()#&%+-*\" [<nTokenCount>]    specifies the count of the token whose position should be calculated Default: last token [<nSkipWidth>]     specifies the maximum number of successive tokenizing characters that are combined as ONE token stop, e.g. specifying 1 can yield to empty tokens Default: 0, any number of successive tokenizing characters are combined as ONE token stop"
   }
  ],
  "name": "AtToken",
  "return": {
   "name": "<nPosition>",
   "help": "The start position of the specified token or 0 if such a token does not exist in <cString>."
  }
 },
 {
  "label": "BeforAtNum( <cStringToMatch>, <cString>, [<nCounter>], [<nIgnore>] ) --> cRestString",
  "documentation": "Returns string portion before nth occurence of substring",
  "arguments": [
   {
    "label": "<cStringToMatch>",
    "documentation": "is the substring scanned for"
   },
   {
    "label": "<cString>",
    "documentation": "is the scanned string [<nCounter>]        determines how many occurences are of"
   },
   {
    "label": "<cStringToMatch>",
    "documentation": "in <cString> are searched Default: search last occurence [<nIgnore>]         determines how many character from the start should be ignored in the search Default: 0"
   }
  ],
  "name": "BeforAtNum",
  "return": {
   "name": "<cRestString>",
   "help": "the portion of <cString> before the <nCounter>th occurence of <cStringToMatch> in <cString> If such a string does not exist, an empty string is returned."
  }
 },
 {
  "label": "Bin2I( <cBuffer> ) --> nNumber",
  "documentation": "Convert signed short encoded bytes into Harbour numeric",
  "arguments": [
   {
    "label": "<cBuffer>",
    "documentation": "is a character string that contains 16-bit encoded signed short integer (least significant byte first). The first two bytes are taken into account, the rest if any are ignored."
   }
  ],
  "name": "Bin2I",
  "return": {
   "name": "",
   "help": "Bin2I() return numeric integer (or 0 if <cBuffer> is not a string)."
  }
 },
 {
  "label": "Bin2L( <cBuffer> ) --> nNumber",
  "documentation": "Convert signed long encoded bytes into Harbour numeric",
  "arguments": [
   {
    "label": "<cBuffer>",
    "documentation": "is a character string that contains 32-bit encoded signed long integer (least significant byte first). The first four bytes are taken into account, the rest if any are ignored."
   }
  ],
  "name": "Bin2L",
  "return": {
   "name": "",
   "help": "Bin2L() return numeric integer (or 0 if <cBuffer> is not a string)."
  }
 },
 {
  "label": "Bin2U( <cBuffer> ) --> nNumber",
  "documentation": "Convert unsigned long encoded bytes into Harbour numeric",
  "arguments": [
   {
    "label": "<cBuffer>",
    "documentation": "is a character string that contains 32-bit encoded unsigned long integer (least significant byte first). The first four bytes are taken into account, the rest if any are ignored."
   }
  ],
  "name": "Bin2U",
  "return": {
   "name": "",
   "help": "Bin2U() return numeric integer (or 0 if <cBuffer> is not a string)."
  }
 },
 {
  "label": "Bin2W( <cBuffer> ) --> nNumber",
  "documentation": "Convert unsigned short encoded bytes into Harbour numeric",
  "arguments": [
   {
    "label": "<cBuffer>",
    "documentation": "is a character string that contains 16-bit encoded unsigned short integer (least significant byte first). The first two bytes are taken into account, the rest if any are ignored."
   }
  ],
  "name": "Bin2W",
  "return": {
   "name": "",
   "help": "Bin2W() return numeric integer (or 0 if <cBuffer> is not a string)."
  }
 },
 {
  "label": "BinToDec( <cN> ) --> <cNr>",
  "documentation": "Converts a Binary Value to Decimal",
  "arguments": [
   {
    "label": "<cN>",
    "documentation": "NUMBER TO BE CONVERTED"
   }
  ],
  "name": "BinToDec",
  "return": {
   "name": "<cNr>",
   "help": "NUMBER CONVERTED"
  }
 },
 {
  "label": "BitToC( <nInteger>, <cBitPattern>[, <lMode>] ) -> <cBitString>",
  "documentation": "",
  "arguments": [],
  "name": "BitToC"
 },
 {
  "label": "Bof() --> lBegin",
  "documentation": "Test for the beginning-of-file condition",
  "arguments": [],
  "name": "Bof",
  "return": {
   "name": "",
   "help": "Bof() Logical true (.T.) or false (.F.)"
  }
 },
 {
  "label": "BoM( [<dDate>] ) -> dDateBeginOfMonth",
  "documentation": "_B_egin _O_f _M_onth",
  "arguments": [],
  "name": "BoM"
 },
 {
  "label": "BoM( <dDate> ) --> dBOM",
  "documentation": "Gets the first day in a month.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "A valid date."
   }
  ],
  "name": "BoM",
  "return": {
   "name": "<dBOM>",
   "help": "The first day in the month."
  }
 },
 {
  "label": "BoQ( [<dDate>] ) -> dDateBeginOfQuarter",
  "documentation": "_B_egin _O_f _Q_uarter",
  "arguments": [],
  "name": "BoQ"
 },
 {
  "label": "BoY( [<dDate>] ) -> dDateBeginOfYear",
  "documentation": "_B_egin _O_f _Y_ear",
  "arguments": [],
  "name": "BoY"
 },
 {
  "label": "BoY( <dDate> ) --> dBOY",
  "documentation": "Gets the first date of the year.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "A valid date."
   }
  ],
  "name": "BoY",
  "return": {
   "name": "<dBOY>",
   "help": "The first day in the year."
  }
 },
 {
  "label": "Break( <xExp> )",
  "documentation": "Exits from a `BEGIN SEQUENCE` block",
  "arguments": [
   {
    "label": "<xExp>",
    "documentation": "is any valid expression. It is always required. If do not want to pass any argument, just use NIL."
   }
  ],
  "name": "Break"
 },
 {
  "label": "Browse( [<nTop>, <nLeft>, <nBottom>, <nRight>] ) --> lOk",
  "documentation": "Browse a database file",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": "coordinate for top row display."
   },
   {
    "label": "<nLeft>",
    "documentation": "coordinate for left column display."
   },
   {
    "label": "<nBottom>",
    "documentation": "coordinate for bottom row display."
   },
   {
    "label": "<nRight>",
    "documentation": "coordinate for right column display."
   }
  ],
  "name": "Browse",
  "return": {
   "name": "",
   "help": "Browse() return .F. if there is no database open in this work area, else it return .T."
  }
 },
 {
  "label": "CD( <cDir> ) --> lSuccess",
  "documentation": "Change the Current Directory",
  "arguments": [
   {
    "label": "<cDir>",
    "documentation": "DIR TO BE CHANGED"
   }
  ],
  "name": "CD",
  "return": {
   "name": "<lSucess>",
   "help": ".T. IF SUCCESSFUL; otherwise .F."
  }
 },
 {
  "label": "CDoW( <dDate> ) --> cDay",
  "documentation": "Converts a date to the day of week",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "Any date expression."
   }
  ],
  "name": "CDoW",
  "return": {
   "name": "<cDay>",
   "help": "The current day of week."
  }
 },
 {
  "label": "Ceiling( <nNumber> ) -> nUpRoundedNumber",
  "documentation": "Rounds up a number to the next integer",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "number to round up"
   }
  ],
  "name": "Ceiling",
  "return": {
   "name": "<nUpRoundedNumber>",
   "help": "the rounded number"
  }
 },
 {
  "label": "Celsius( nDegreeFahrenheit ) --> nDegreeCelsius",
  "documentation": "Temperature conversion Fahrenheit to Celsius",
  "arguments": [
   {
    "label": "<nDegreeFahrenheit>",
    "documentation": "temperature in degree Fahrenheit"
   }
  ],
  "name": "Celsius",
  "return": {
   "name": "<nDegreeCelsius>",
   "help": "temperate in degree Celsius"
  }
 },
 {
  "label": "CharAdd( <[@]cString1>, <cString2> ) --> cAddString",
  "documentation": "Adds corresponding ASCII value of two strings",
  "arguments": [
   {
    "label": "<[@]cString1>",
    "documentation": "first string"
   },
   {
    "label": "<cString2>",
    "documentation": "second string"
   }
  ],
  "name": "CharAdd",
  "return": {
   "name": "<cAddString>",
   "help": "string with added ASCII values"
  }
 },
 {
  "label": "CharAnd( <[@]cString1>, <cString2> ) --> cAndString",
  "documentation": "Combine corresponding ASCII value of two strings with bitwise AND",
  "arguments": [
   {
    "label": "<[@]cString1>",
    "documentation": "first string"
   },
   {
    "label": "<cString2>",
    "documentation": "second string"
   }
  ],
  "name": "CharAnd",
  "return": {
   "name": "<cAndString>",
   "help": "string with bitwise AND combined ASCII values"
  }
 },
 {
  "label": "CharEven( <cString> ) --> cEvenString",
  "documentation": "Returns the characters on the even positions in a string",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "processed string"
   }
  ],
  "name": "CharEven",
  "return": {
   "name": "<cEvenString>",
   "help": "a string containing all character from even positions in <cString>"
  }
 },
 {
  "label": "CharHist( [<cString>] ) -> aCharacterCount",
  "documentation": "Generates a character histogram of a string",
  "arguments": [],
  "name": "CharHist",
  "return": {
   "name": "<aCharacterCount>",
   "help": "an array with 256 elements where the nth element contains the count of character #(n-1) in cString"
  }
 },
 {
  "label": "CharList( [<cString>] ) -> cCharacterList",
  "documentation": "Generates a list of all characters in a string",
  "arguments": [],
  "name": "CharList",
  "return": {
   "name": "<cCharacterList>",
   "help": "a list of the characters in <cString>"
  }
 },
 {
  "label": "CharMirr( <[@]cString>, [<lDontMirrorSpaces>] ) -> cMirroredString",
  "documentation": "Mirror a string",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "is the string that should be mirrored [<lDontMirrorSpaces>]   if set to .T., spaces at the end of"
   },
   {
    "label": "<cString>",
    "documentation": "will not be mirrored but kept at the end Default: .F., mirror the whole string"
   }
  ],
  "name": "CharMirr",
  "return": {
   "name": "<cMirroredString>",
   "help": "the mirrored string"
  }
 },
 {
  "label": "CharMix( <cString1>[, <cString2>] ) --> cMixedString",
  "documentation": "Mix two strings",
  "arguments": [
   {
    "label": "<cString1>",
    "documentation": "String that will be mixed with the characters from <cString2> [<cString2>]   String whose characters will be mixed with the one from"
   },
   {
    "label": "<cString1>",
    "documentation": ". Default: \" \" (string with one space char)"
   }
  ],
  "name": "CharMix",
  "return": {
   "name": "<cMixedString>",
   "help": "Mixed string"
  }
 },
 {
  "label": "CharNoList( [<cString>] ) -> cCharacterList",
  "documentation": "Generates a list of all characters not contained in a string",
  "arguments": [],
  "name": "CharNoList",
  "return": {
   "name": "<cCharacterList>",
   "help": "a list of the characters that are not contained in <cString>"
  }
 },
 {
  "label": "CharNot( <[@]cString> ) --> cNotString",
  "documentation": "Process each character in a string with bitwise NOT operation",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "string to be processed"
   }
  ],
  "name": "CharNot",
  "return": {
   "name": "<cNotString>",
   "help": "string with bitwise negated characters"
  }
 },
 {
  "label": "CharOdd( <cString> ) --> cOddString",
  "documentation": "Returns the characters on the odd positions in a string",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "processed string"
   }
  ],
  "name": "CharOdd",
  "return": {
   "name": "<cOddString>",
   "help": "a string containing all character from odd positions in <cString>"
  }
 },
 {
  "label": "CharOne( [<cCharactersToReduce>,] <cString> ) -> cReducedString",
  "documentation": "Reduce multiple occurences of a character to one",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "specifies the processed string"
   }
  ],
  "name": "CharOne",
  "return": {
   "name": "<cReducedString>",
   "help": "the string with the reduced occurences"
  }
 },
 {
  "label": "CharOnly( <cThisCharactersOnly>, <cString> ) -> cReducedString",
  "documentation": "Intersectional set of two strings based on characters",
  "arguments": [
   {
    "label": "<cThisCharactersOnly>",
    "documentation": "specifies the characters that must not be deleted in <cString>."
   },
   {
    "label": "<cString>",
    "documentation": "is the string that should be processed"
   }
  ],
  "name": "CharOnly",
  "return": {
   "name": "<cReducedString>",
   "help": "A string with all characters deleted but those specified in <cThisCharactersOnly>."
  }
 },
 {
  "label": "CharOr( <[@]cString1>, <cString2> ) --> cOrString",
  "documentation": "Combine corresponding ASCII value of two strings with bitwise OR",
  "arguments": [
   {
    "label": "<[@]cString1>",
    "documentation": "first string"
   },
   {
    "label": "<cString2>",
    "documentation": "second string"
   }
  ],
  "name": "CharOr",
  "return": {
   "name": "<cOrString>",
   "help": "string with bitwise OR combined ASCII values"
  }
 },
 {
  "label": "CharPix() --> nHeight",
  "documentation": "Gets the number of scan lines per character.",
  "arguments": [],
  "name": "CharPix",
  "return": {
   "name": "",
   "help": "Returns the number of scan lines per character."
  }
 },
 {
  "label": "CharRelA( <cStringToMatch1>, <cString1>, <cStringToMatch2>, <cString2> ) -> nPosition",
  "documentation": "Character relation of two strings",
  "arguments": [],
  "name": "CharRelA"
 },
 {
  "label": "CharRelRep( <cStringToMatch1>, <cString1>, <cStringToMatch2>, <[@]cString2>, <cReplacement> ) -> cString",
  "documentation": "Relation dependant character replacement",
  "arguments": [],
  "name": "CharRelRep"
 },
 {
  "label": "CharRem( <cDeleteThisCharacters>, <cString> ) -> cReducedString",
  "documentation": "Removes characters from a string",
  "arguments": [
   {
    "label": "<cDeleteThisCharacters>",
    "documentation": "specifies the characters that should be deleted in <cString>"
   },
   {
    "label": "<cString>",
    "documentation": ")                is the string that should be processed"
   }
  ],
  "name": "CharRem",
  "return": {
   "name": "<cReducedString>",
   "help": "is a string where the characters specified in <cDeleteThisCharacters> are deleted"
  }
 },
 {
  "label": "CharRepl( <cSearchString>, <[@]cString>, <cReplaceString>, [<lMode>] ) -> cString",
  "documentation": "Replacement of characters",
  "arguments": [
   {
    "label": "<cSearchString>",
    "documentation": "is a string of characters that should be replaced"
   },
   {
    "label": "<[@]cString>",
    "documentation": "is the processed string"
   },
   {
    "label": "<cReplaceString>",
    "documentation": "is a string of characters that replace the one of <cSearchString> [<lMode>]          sets the replacement method (see description) Default: .F."
   }
  ],
  "name": "CharRepl",
  "return": {
   "name": "<cString>",
   "help": "the processed string"
  }
 },
 {
  "label": "CharRll( <[@]cString>, <nBitsToRLL> ) --> cRLLString",
  "documentation": "Process each character in a string with bitwise ROLL LEFT operation",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "string to be processed"
   },
   {
    "label": "<nBitsToRLL>",
    "documentation": "number of bit positions to be rolled to the left"
   }
  ],
  "name": "CharRll",
  "return": {
   "name": "<cRLLString>",
   "help": "string with bitwise rolled left characters"
  }
 },
 {
  "label": "CharRlr( <[@]cString>, <nBitsToRLR> ) --> cRLRString",
  "documentation": "Process each character in a string with bitwise ROLL RIGHT operation",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "string to be processed"
   },
   {
    "label": "<nBitsToRLR>",
    "documentation": "number of bit positions to be rolled to the right"
   }
  ],
  "name": "CharRlr",
  "return": {
   "name": "<cRLRString>",
   "help": "string with bitwise rolled right characters"
  }
 },
 {
  "label": "CharShl( <[@]cString>, <nBitsToSHL> ) --> cSHLString",
  "documentation": "Process each character in a string with bitwise SHIFT LEFT operation",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "string to be processed"
   },
   {
    "label": "<nBitsToSHL>",
    "documentation": "number of bit positions to be shifted to the left"
   }
  ],
  "name": "CharShl",
  "return": {
   "name": "<cSHLString>",
   "help": "string with bitwise shifted left characters"
  }
 },
 {
  "label": "CharShr( <[@]cString>, <nBitsToSHR> ) --> cSHRString",
  "documentation": "Process each character in a string with bitwise SHIFT RIGHT operation",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "string to be processed"
   },
   {
    "label": "<nBitsToSHR>",
    "documentation": "number of bit positions to be shifted to the right"
   }
  ],
  "name": "CharShr",
  "return": {
   "name": "<cSHRString>",
   "help": "string with bitwise shifted right characters"
  }
 },
 {
  "label": "CharSList( [<cString>] ) -> cSortedCharacterList",
  "documentation": "Generates a sorted list of all characters in a string",
  "arguments": [],
  "name": "CharSList",
  "return": {
   "name": "<cSortedCharacterList>",
   "help": "a sorted list of the characters in <cString>"
  }
 },
 {
  "label": "CharSort( <[@]cString>, [<nElementLength>], [<nCompareLength>], [<nIgnoreCharacters>], [<nElemenOffset>], [<nSortLength>], [<lDescending>] ) -> cSortedString",
  "documentation": "Sort sequences within a string.",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "is the string that should be processed [<nElementLength>]       specifies the length of the elements that should be sorted Default: 1 [<nCompareLength>]       specifies how many characters within one element should be used for comparison Default: <nElementLength> [<nIgnoreCharacters>]    specifies the number of characters at the beginning of <cString> that should be ignored in the sort process Default: 0 [<nElementOffset>]       specifies the offset of the comparison string within a element Default: 0 [<nSortLength>]          specifies how many characters in <cString>, starting from the <nIgnoreCharacters> position, should be sorted Default: Len(cString)-nIgnoreCharacters [<lDescending>])         specifies whether the process should sort descending or not"
   }
  ],
  "name": "CharSort",
  "return": {
   "name": "<cSortedString>",
   "help": "the string resulting from the sort process"
  }
 },
 {
  "label": "CharSub( <[@]cString1>, <cString2>) --> cSubString",
  "documentation": "Subtracts corresponding ASCII value of two strings",
  "arguments": [
   {
    "label": "<[@]cString1>",
    "documentation": "first string"
   },
   {
    "label": "<cString2>",
    "documentation": "second string"
   }
  ],
  "name": "CharSub",
  "return": {
   "name": "<cSubString>",
   "help": "string with subtracted ASCII values"
  }
 },
 {
  "label": "CharSwap( <[@]cString> ) -> cSwappedString",
  "documentation": "Swap neighbouring characters in a string",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "is the string that should be processed"
   }
  ],
  "name": "CharSwap",
  "return": {
   "name": "<cSwappedString>",
   "help": "a string where neighbour characters are swapped"
  }
 },
 {
  "label": "CharWin( <nTop>, <nLeft>, <nBottom>, <nRight>, [<cNewChar|nNewChar>], [<cOldChar|nOldChar>] ) --> <cEmptyString>",
  "documentation": "",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": "- top row number, default 0"
   },
   {
    "label": "<nLeft>",
    "documentation": "- left column number, default 0"
   },
   {
    "label": "<nBottom>",
    "documentation": "- top row number, default MaxRow()"
   },
   {
    "label": "<nRight>",
    "documentation": "- right column number, default MaxCol()"
   },
   {
    "label": "<cNewChar|nNewChar>",
    "documentation": "- new character for the screen area, as a numeric value in the range of 0 to 255 or as a character string, default value is the CLEARB."
   },
   {
    "label": "<cOldChar|nOldChar>",
    "documentation": "- character to exchange. Specify the parameter as a numeric in the range of 0 to 255 or as a character string.  The default is to exchange all characters."
   }
  ],
  "name": "CharWin",
  "return": {
   "name": "",
   "help": "Returns an empty string."
  }
 },
 {
  "label": "CharXor( <[@]cString1>, <cString2> ) --> cXOrString",
  "documentation": "Combine corresponding ASCII value of two strings with bitwise XOR",
  "arguments": [
   {
    "label": "<[@]cString1>",
    "documentation": "first string"
   },
   {
    "label": "<cString2>",
    "documentation": "second string"
   }
  ],
  "name": "CharXor",
  "return": {
   "name": "<cXOrString>",
   "help": "string with bitwise XOR combined ASCII values"
  }
 },
 {
  "label": "Chr( <nAsciiNum> ) --> cReturn",
  "documentation": "Converts an ASCII value to it character value",
  "arguments": [
   {
    "label": "<nAsciiNum>",
    "documentation": "Any ASCII character code."
   }
  ],
  "name": "Chr",
  "return": {
   "name": "<cReturn>",
   "help": "Character expression of that ASCII value"
  }
 },
 {
  "label": "CLIPINIT() --> NIL",
  "documentation": "Initialize various Harbour sub-systems",
  "arguments": [],
  "name": "CLIPINIT",
  "return": {
   "name": "",
   "help": "CLIPINIT() always return NIL."
  }
 },
 {
  "label": "CMonth( <dDate> ) --> cMonth",
  "documentation": "Return the name of the month.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "Any date expression."
   }
  ],
  "name": "CMonth",
  "return": {
   "name": "<cMonth>",
   "help": "The current month name"
  }
 },
 {
  "label": "Col() --> nPosition",
  "documentation": "Returns the current screen column position",
  "arguments": [],
  "name": "Col",
  "return": {
   "name": "<nPosition>",
   "help": "Current column position"
  }
 },
 {
  "label": "ColorRepl( [<cNewAttr|nNewAttr>], [<cOldAttr|nOldAttr>] ) --> cNull",
  "documentation": "",
  "arguments": [
   {
    "label": "<cNewAttr|nNewAttr>",
    "documentation": "Designates the new attribute.  The default is CLEARA."
   },
   {
    "label": "<cOldAttr|InOldAttr>",
    "documentation": "Designates the old attribute to exchange.  The default is all existing attributes."
   }
  ],
  "name": "ColorRepl",
  "return": {
   "name": "",
   "help": "Returns an empty string."
  }
 },
 {
  "label": "ColorToN( <cAttr> ) -> <nAttr>",
  "documentation": "",
  "arguments": [
   {
    "label": "<cAttr>",
    "documentation": "Designates the alphanumeric color attribute that is converted in NN/NN or CC/CC form."
   }
  ],
  "name": "ColorToN",
  "return": {
   "name": "",
   "help": "ColorToN() returns a number that corresponds to the combined numeric color attribute."
  }
 },
 {
  "label": "ColorWin( [<nTopLine>], [<nLeftCol>], [<nBottomLine>], [<nRightCol>], [<cNewAttr|nNewAttr>], [<cOldAttr|nOldAttr>] ) --> cNull",
  "documentation": "",
  "arguments": [
   {
    "label": "<nTopLine>",
    "documentation": "Designates the topmost line to begin processing.  The default is the cursor line."
   },
   {
    "label": "<nLeftCol>",
    "documentation": "Designates the leftmost column to begin processing.  The default is the cursor column."
   },
   {
    "label": "<nBottomLine>",
    "documentation": "Designates the bottommost line that is processed. The default is the last screen line or window line."
   },
   {
    "label": "<nRightCol>",
    "documentation": "Designates the rightmost column to clear.  The default is the right screen border or window border."
   },
   {
    "label": "<cNewAttr|nNewAttr>",
    "documentation": "Designates the new attribute to replace the old one.  The default is the standard attribute CLEARA."
   },
   {
    "label": "<cOldAttr|nOldAttr>",
    "documentation": "Designates the old character to exchange.  The default is \"exchange all attributes\"."
   }
  ],
  "name": "ColorWin",
  "return": {
   "name": "",
   "help": "Returns an empty string."
  }
 },
 {
  "label": "Cos( nRadiant ) -> nCosine",
  "documentation": "Cosine of the argument",
  "arguments": [
   {
    "label": "<nRadiant>",
    "documentation": "an angle size given in radiants"
   }
  ],
  "name": "Cos",
  "return": {
   "name": "<nCosine>",
   "help": "the cosine of <nRadiant>"
  }
 },
 {
  "label": "Cosh( nArea ) -> nHyperbolicCosine",
  "documentation": "Hyperbolic Cosine of the argument",
  "arguments": [
   {
    "label": "<nArea>",
    "documentation": "the size of the area (see below)"
   }
  ],
  "name": "Cosh",
  "return": {
   "name": "<nHyperbolicCosine>",
   "help": "the hyperbolic cosine of <nArea>"
  }
 },
 {
  "label": "Cot( nRadiant ) -> nCotangent",
  "documentation": "Cotangent of the argument",
  "arguments": [
   {
    "label": "<nRadiant>",
    "documentation": "an angle size given in radiants"
   }
  ],
  "name": "Cot",
  "return": {
   "name": "<nCotangent>",
   "help": "the cotangent of <nRadiant>"
  }
 },
 {
  "label": "CountLeft( <cString>, [<cSearch|nSearch>] ) -> nCount",
  "documentation": "Count a certain character at the beginning of a string",
  "arguments": [],
  "name": "CountLeft"
 },
 {
  "label": "CountRight( <cString>, [<cSearch|nSearch>] ) -> nCount",
  "documentation": "Count a certain character at the end of a string",
  "arguments": [],
  "name": "CountRight"
 },
 {
  "label": "CSetArgErr( [<nNewMode>] ) -> <nOldMode>",
  "documentation": "Sets argument error behaviour",
  "arguments": [],
  "name": "CSetArgErr",
  "return": {
   "name": "<nOldMode>",
   "help": "The current or old argument error throwing mode."
  }
 },
 {
  "label": "CSetAtMupa( [<lNewSwitch>] ) -> lOldSwitch",
  "documentation": "Determine \"multi-pass\" behaviour in some string functions",
  "arguments": [],
  "name": "CSetAtMupa",
  "return": {
   "name": "",
   "help": "lOldSwitch      old (if lNewSwitch is a logical value) or current state of the switch"
  }
 },
 {
  "label": "CSetRef( [<lNewSwitch>] ) -> lOldSwitch",
  "documentation": "Determine return value of reference sensitive CT3 string functions",
  "arguments": [],
  "name": "CSetRef",
  "return": {
   "name": "",
   "help": "lOldSwitch      old (if lNewSwitch is a logical value) or current state of the switch"
  }
 },
 {
  "label": "CToBit( <cBitString>, <cBitPattern> ) -> <nWord>",
  "documentation": "",
  "arguments": [],
  "name": "CToBit"
 },
 {
  "label": "CToD( <cDateString> ) --> dDate",
  "documentation": "Converts a character string to a date expression",
  "arguments": [
   {
    "label": "<cDateString>",
    "documentation": "A character date in format \"mm/dd/yy\""
   }
  ],
  "name": "CToD",
  "return": {
   "name": "<dDate>",
   "help": "A date expression"
  }
 },
 {
  "label": "CToDoW( <cName> ) -> nOrdinal",
  "documentation": "convert name of day of the week to its ordinal number",
  "arguments": [],
  "name": "CToDoW"
 },
 {
  "label": "CToF( <cFloatingPointNumber> ) --> nFloatingPointNumber ",
  "documentation": "",
  "arguments": [
   {
    "label": "<cFloatingPointNumber>",
    "documentation": "Designate a string that contains a Harbour number in flotaing point format. ATTENTION: different implementations or platforms of Harbour, they could produce different format in the string returned by FToC()."
   }
  ],
  "name": "CToF",
  "return": {
   "name": "",
   "help": "CToF() return the floating point number that corresponds to the string passed."
  }
 },
 {
  "label": "CToMonth( <cName> ) -> nOrdinal",
  "documentation": "convert name of month to its ordinal number",
  "arguments": [],
  "name": "CToMonth"
 },
 {
  "label": "CToN( <xNumber>[, <nBase>][, <lMode>] ) -> <nNumber>",
  "documentation": "",
  "arguments": [],
  "name": "CToN"
 },
 {
  "label": "CurDir( [<cDrive>] ) --> cPath",
  "documentation": "Returns the current OS directory name.",
  "arguments": [
   {
    "label": "<cDrive>",
    "documentation": "OS drive letter"
   }
  ],
  "name": "CurDir",
  "return": {
   "name": "<cPath>",
   "help": "Name of directory"
  }
 },
 {
  "label": "Date() --> dCurDate",
  "documentation": "Return the Current OS Date",
  "arguments": [],
  "name": "Date",
  "return": {
   "name": "<dCurDate>",
   "help": "Current system date."
  }
 },
 {
  "label": "Day( <cDate> ) --> nMonth",
  "documentation": "Return the numeric day of the month.",
  "arguments": [
   {
    "label": "<cDate>",
    "documentation": "Any valid date expression."
   }
  ],
  "name": "Day",
  "return": {
   "name": "<nMonth>",
   "help": "Numeric value of the day of month."
  }
 },
 {
  "label": "Days( <nSecs> ) --> nDay",
  "documentation": "Convert elapsed seconds into days",
  "arguments": [
   {
    "label": "<nSecs>",
    "documentation": "The number of seconds"
   }
  ],
  "name": "Days",
  "return": {
   "name": "<nDay>",
   "help": "The number of days"
  }
 },
 {
  "label": "dbEdit( [<nTop>], [<nLeft>], [<nBottom>], [<nRight>], [<acColumns>], [<xUserFunc>], [<xColumnSayPictures>], [<xColumnHeaders>], [<xHeadingSeparators>], [<xColumnSeparators>], [<xFootingSeparators>], [<xColumnFootings>] ) --> lOk",
  "documentation": "Browse records in a table",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": "coordinate for top row display. <nTop> could range from 0 to MaxRow(), default is 0."
   },
   {
    "label": "<nLeft>",
    "documentation": "coordinate for left column display. <nLeft> could range from 0 to MaxCol(), default is 0."
   },
   {
    "label": "<nBottom>",
    "documentation": "coordinate for bottom row display. <nBottom> could range from 0 to MaxRow(), default is MaxRow()."
   },
   {
    "label": "<nRight>",
    "documentation": "coordinate for right column display. <nRight> could range from 0 to MaxCol(), default is MaxCol()."
   },
   {
    "label": "<acColumns>",
    "documentation": "is an array of character expressions that contain database fields names or expressions to display in each column. If not specified, the default is to display all fields from the database in the current work area."
   },
   {
    "label": "<xUserFunc>",
    "documentation": "is a name of a user defined function or a code block that would be called every time unrecognized key is been pressed or when there are no keys waiting to be processed and dbEdit() goes into idle mode. If <xUserFunc> is a character string, it must contain root name of a valid user define function without parentheses. Both the user define function or the code block should accept two parameters: <nMode>, <nCurrentColumn>. Both should return a numeric value that correspond to one of the expected return codes (see table below for a list of <nMode> and return codes)."
   },
   {
    "label": "<xColumnSayPictures>",
    "documentation": "is an optional picture. If <xColumnSayPictures> is a character string, all columns would used this value as a picture string. If <xColumnSayPictures> is an array, each element should be a character string that correspond to a picture string for the column with the same index. Look at the help for `@...SAY` to get more information about picture values."
   },
   {
    "label": "<xColumnHeaders>",
    "documentation": "contain the header titles for each column, if this is a character string, all columns would have that same header, if this is an array, each element is a character string that contain the header title for one column. Header may be split to more than one line by placing semicolon `;` in places where you want to break line. If omitted, the default value for each column header is taken from <acColumns> or field name if <acColumns> was not specified."
   },
   {
    "label": "<xHeadingSeparators>",
    "documentation": "is an array that contain characters that draw the lines separating the headers and the fields data. Instead of an array you can use a character string that would be used to display the same line for all fields. Default value is a double line."
   },
   {
    "label": "<xColumnSeparators>",
    "documentation": "is an array that contain characters that draw the lines separating displayed columns. Instead of an array you can use a character string that would be used to display the same line for all fields. Default value is a single line."
   },
   {
    "label": "<xFootingSeparators>",
    "documentation": "is an array that contain characters that draw the lines separating the fields data area and the footing area. Instead of an array you can use a character string that would be used to display the same line for all footers. Default is to have to no footing separators."
   },
   {
    "label": "<xColumnFootings>",
    "documentation": "contain the footing to be displayed at the bottom of each column, if this is a character string, all columns would have that same footer, if this is an array, each element is a character string that contain the footer for one column. Footer may be split to more than one line by placing semicolon `;` in places where you want to break line. If omitted, no footer are displayed."
   }
  ],
  "name": "dbEdit",
  "return": {
   "name": "",
   "help": "dbEdit() return .F. if there is no database in use or if the number of columns to display is zero, else dbEdit() return .T."
  }
 },
 {
  "label": "dbSkipper( <nRecs> ) --> nSkipped",
  "documentation": "Helper function to skip a database",
  "arguments": [
   {
    "label": "<nRecs>",
    "documentation": "is the number of records to skip relative to current record. Positive number would try to move the record pointer forward, while a negative number would try to move the record pointer back <nRecs> records."
   }
  ],
  "name": "dbSkipper",
  "return": {
   "name": "",
   "help": "dbSkipper() return the number of actual record skipped."
  }
 },
 {
  "label": "DecToBin( <cN> ) --> <cNr>",
  "documentation": "Converts a Decimal Value to Binary",
  "arguments": [
   {
    "label": "<cN>",
    "documentation": "NUMBER TO BE CONVERTED"
   }
  ],
  "name": "DecToBin",
  "return": {
   "name": "<cNr>",
   "help": "NUMBER CONVERTED"
  }
 },
 {
  "label": "DecToHexa( <cN> ) --> <cNr>",
  "documentation": "Converts a Decimal Value to Hexa",
  "arguments": [
   {
    "label": "<cN>",
    "documentation": "NUMBER TO BE CONVERTED"
   }
  ],
  "name": "DecToHexa",
  "return": {
   "name": "<cNr>",
   "help": "NUMBER CONVERTED"
  }
 },
 {
  "label": "DecToOctal( <cN> ) --> <cNr>",
  "documentation": "Converts a Decimal Value to Octal",
  "arguments": [
   {
    "label": "<cN>",
    "documentation": "NUMBER TO BE CONVERTED"
   }
  ],
  "name": "DecToOctal",
  "return": {
   "name": "<cNr>",
   "help": "NUMBER CONVERTED"
  }
 },
 {
  "label": "Deleted() --> lDeleted",
  "documentation": "Tests the record's deletion flag.",
  "arguments": [],
  "name": "Deleted",
  "return": {
   "name": "",
   "help": "Deleted() return a logical true (.T.) or false (.F.)."
  }
 },
 {
  "label": "Descend( <xExp> ) --> xExpInverted",
  "documentation": "Inverts an expression of string, logical, date or numeric type.",
  "arguments": [
   {
    "label": "<xExp>",
    "documentation": "is any valid expression."
   }
  ],
  "name": "Descend",
  "return": {
   "name": "",
   "help": "Inverted value of the same type as passed."
  }
 },
 {
  "label": "DevOutPict( <xExp>, <cPicture>, [<cColorString>] )",
  "documentation": "Displays a value to a device using a picture template",
  "arguments": [
   {
    "label": "<xExp>",
    "documentation": "is any valid expression."
   },
   {
    "label": "<cPicture>",
    "documentation": "is any picture transformation that Transform() can use."
   },
   {
    "label": "<cColorString>",
    "documentation": "is an optional string that specifies a screen color to use in place of the default color when the output goes to the screen."
   }
  ],
  "name": "DevOutPict"
 },
 {
  "label": "DirChange( <cDirectory> ) --> nError",
  "documentation": "Changes the directory",
  "arguments": [
   {
    "label": "<cDirectory>",
    "documentation": "The name of the directory you want do change into."
   }
  ],
  "name": "DirChange",
  "return": {
   "name": "<nError>",
   "help": "0 if directory was successfully changed, otherwise the number of the last error."
  }
 },
 {
  "label": "DirRemove( <cDirectory> ) --> nError",
  "documentation": "Attempt to remove an directory",
  "arguments": [
   {
    "label": "<cDirectory>",
    "documentation": "The name of the directory you want to remove."
   }
  ],
  "name": "DirRemove",
  "return": {
   "name": "<nError>",
   "help": "0 if directory was successfully removed, otherwise the number of the last error."
  }
 },
 {
  "label": "DiskSpace( [<nDrive>] ) --> nDiskBytes",
  "documentation": "Get the amount of space available on a disk",
  "arguments": [
   {
    "label": "<nDrive>",
    "documentation": "The number of the drive you are requesting info on where 1 = A, 2 = B, etc. For 0 or no parameter, DiskSpace will operate on the current drive.  The default is 0"
   }
  ],
  "name": "DiskSpace",
  "return": {
   "name": "<nDiskBytes>",
   "help": "The number of bytes on the requested disk that match the requested type."
  }
 },
 {
  "label": "DMY( [<dDate>][, <lMode>] ) -> cDateString",
  "documentation": "Returns the date as a string in DD Month YY format",
  "arguments": [],
  "name": "DMY"
 },
 {
  "label": "DMY( [<dDate>] ) -> nDayOfYear",
  "documentation": "Determines the day of the year for a specific date",
  "arguments": [],
  "name": "DMY"
 },
 {
  "label": "Do( <xFuncProc> [, <xArguments...>] ) --> xRetVal",
  "documentation": "Calls a procedure or a function",
  "arguments": [
   {
    "label": "<xFuncProc>",
    "documentation": "= Either a string with a function/procedure name to be called or a codeblock to evaluate."
   },
   {
    "label": "<xArguments>",
    "documentation": "= arguments passed to a called function/procedure or to a codeblock."
   }
  ],
  "name": "Do",
  "return": {
   "name": "<xRetVal>",
   "help": "A value that was returned from called function."
  }
 },
 {
  "label": "DoW( <dDate> ) --> nDay",
  "documentation": "Value for the day of week.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "Any valid date expression"
   }
  ],
  "name": "DoW",
  "return": {
   "name": "<nDay>",
   "help": "The current day number"
  }
 },
 {
  "label": "DoY( <dDate> ) --> nDay",
  "documentation": "Gets the day number of the year.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "A valid date."
   }
  ],
  "name": "DoY",
  "return": {
   "name": "<nDay>",
   "help": "The day number"
  }
 },
 {
  "label": "DToC( <dDateString> ) --> cDate",
  "documentation": "Date to character conversion",
  "arguments": [
   {
    "label": "<dDateString>",
    "documentation": "Any date"
   }
  ],
  "name": "DToC",
  "return": {
   "name": "<dDate>",
   "help": "Character representation of date"
  }
 },
 {
  "label": "DToR( nDegree ) -> nRadiant",
  "documentation": "Convert degree to radiant",
  "arguments": [
   {
    "label": "<nDegree>",
    "documentation": "the size of that angle in degree"
   }
  ],
  "name": "DToR",
  "return": {
   "name": "<nRadiant>",
   "help": "the size of an angle in radiant"
  }
 },
 {
  "label": "DToS( <dDateString> ) --> cDate",
  "documentation": "Date to string conversion",
  "arguments": [
   {
    "label": "<dDateString>",
    "documentation": "Any date"
   }
  ],
  "name": "DToS",
  "return": {
   "name": "<dDate>",
   "help": "String notation of the date"
  }
 },
 {
  "label": "ElapTime( <cStartTime>, <cEndTime> ) --> cDifference",
  "documentation": "Calculates elapsed time.",
  "arguments": [
   {
    "label": "<cStartTime>",
    "documentation": "Start in time as a string format"
   },
   {
    "label": "<cEndTime>",
    "documentation": "End time as a string format"
   }
  ],
  "name": "ElapTime",
  "return": {
   "name": "<cDifference>",
   "help": "Difference between the times"
  }
 },
 {
  "label": "Empty( <xExp> ) --> lIsEmpty",
  "documentation": "Checks if the passed argument is empty.",
  "arguments": [
   {
    "label": "<xExp>",
    "documentation": "is any valid expression."
   }
  ],
  "name": "Empty",
  "return": {
   "name": "",
   "help": "A logical value. It is true (.T.) if the passed argument is empty otherwise it is false (.F.)."
  }
 },
 {
  "label": "Enhanced() -> <cEmptyString>",
  "documentation": "Select the \"ENHANCED\" color value for output",
  "arguments": [],
  "name": "Enhanced"
 },
 {
  "label": "Eof() --> lEnd",
  "documentation": "Test for end-of-file condition.",
  "arguments": [],
  "name": "Eof",
  "return": {
   "name": "<lEnd>",
   "help": "A logical true (.T.) or false (.F.)"
  }
 },
 {
  "label": "EoM( [<dDate>] ) -> dDateEndOfMonth",
  "documentation": "_E_nd _O_f _M_onth",
  "arguments": [],
  "name": "EoM"
 },
 {
  "label": "EoM( <dDate> ) --> dEOM",
  "documentation": "Gets the last day in a month.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "A valid date."
   }
  ],
  "name": "EoM",
  "return": {
   "name": "<dEOM>",
   "help": "The last day in the month."
  }
 },
 {
  "label": "EoQ( [<dDate>] ) -> dDateEndOfQuarter",
  "documentation": "_E_nd _O_f _Q_uarter",
  "arguments": [],
  "name": "EoQ"
 },
 {
  "label": "EoY( [<dDate>] ) -> dDateEndOfYear",
  "documentation": "_E_nd _O_f _Y_ear",
  "arguments": [],
  "name": "EoY"
 },
 {
  "label": "EoY( <dDate> ) --> dEOY",
  "documentation": "Gets the last date of the year.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "A valid date."
   }
  ],
  "name": "EoY",
  "return": {
   "name": "<dEOY>",
   "help": "The last date of the year."
  }
 },
 {
  "label": "ErrorSys() --> NIL",
  "documentation": "Install default error handler",
  "arguments": [],
  "name": "ErrorSys",
  "return": {
   "name": "",
   "help": "ErrorSys() always return NIL."
  }
 },
 {
  "label": "Eval( <bBlock> [, <xVal> [,...] ] ) --> xExpression",
  "documentation": "Evaluate a code block",
  "arguments": [
   {
    "label": "<bBlock>",
    "documentation": "Code block expression to be evaluated"
   },
   {
    "label": "<xVal>",
    "documentation": "Argument to be passed to the code block expression"
   },
   {
    "label": "<xVal...>",
    "documentation": "Argument list to be passed to the code block expression"
   }
  ],
  "name": "Eval",
  "return": {
   "name": "<xExpression>",
   "help": "The result of the evaluated code block"
  }
 },
 {
  "label": "Exp( <nNumber> ) --> nValue",
  "documentation": "Calculates the value of e raised to the passed power.",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "Any  real number."
   }
  ],
  "name": "Exp",
  "return": {
   "name": "<nValue>",
   "help": "The anti-logarithm of <nNumber>"
  }
 },
 {
  "label": "Exponent( <nFloatingPointNumber> ) --> nExponent",
  "documentation": "Evaluate the exponent of a floating point number",
  "arguments": [
   {
    "label": "<nFloatingPointNumber>",
    "documentation": "Designate any Harbour number."
   }
  ],
  "name": "Exponent",
  "return": {
   "name": "",
   "help": "Exponent() returns the exponent of the <nFloatingPointNumber> number in base 2."
  }
 },
 {
  "label": "Fact( <nNumber> ) -> nFaculty",
  "documentation": "Calculates faculty",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "number between 0 and 21"
   }
  ],
  "name": "Fact",
  "return": {
   "name": "<nFaculty>",
   "help": "the faculty of <nNumber>"
  }
 },
 {
  "label": "Fahrenheit( nDegreeCelsius ) --> nDegreeFahrenheit",
  "documentation": "Temperature conversion Celsius to Fahrenheit",
  "arguments": [
   {
    "label": "<nDegreeCelsius>",
    "documentation": "temperate in degree Celsius"
   }
  ],
  "name": "Fahrenheit",
  "return": {
   "name": "<nDegreeFahrenheit>",
   "help": "temperature in degree Fahrenheit"
  }
 },
 {
  "label": "FClose( <nHandle> ) --> lSuccess",
  "documentation": "Closes an open file",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "File handle"
   }
  ],
  "name": "FClose",
  "return": {
   "name": "<lSuccess>",
   "help": "Logical TRUE (.T.) or FALSE (.F.)"
  }
 },
 {
  "label": "FCount() --> nFields",
  "documentation": "Counts the number of fields in an active database.",
  "arguments": [],
  "name": "FCount",
  "return": {
   "name": "<nFields>",
   "help": "Return the number of fields"
  }
 },
 {
  "label": "FCreate( <cFile>, [<nAttribute>] ) --> nHandle",
  "documentation": "Creates a file.",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "is the name of the file to create."
   },
   {
    "label": "<nAttribute>",
    "documentation": "Numeric code for the file attributes."
   }
  ],
  "name": "FCreate",
  "return": {
   "name": "<nHandle>",
   "help": "Numeric file handle to be used in other operations."
  }
 },
 {
  "label": "FErase( <cFile> ) --> nSuccess",
  "documentation": "Erase a file from disk",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "Name of file to erase."
   }
  ],
  "name": "FErase",
  "return": {
   "name": "<nSuccess>",
   "help": "0 if successful, -1 if not"
  }
 },
 {
  "label": "FError() --> nErrorCode",
  "documentation": "Reports the error status of low-level file functions",
  "arguments": [],
  "name": "FError",
  "return": {
   "name": "<nErrorCode>",
   "help": "Value of the OS error last encountered by a low-level file function. FError() Return Values <table> Error          Meaning 0              Successful 2              File not found 3              Path not found 4              Too many files open 5              Access denied 6              Invalid handle 8              Insufficient memory 15             Invalid drive specified 19             Attempted to write to a write-protected disk 21             Drive not ready 23             Data CRC error 29             Write fault 30             Read fault 32             Sharing violation 33             Lock Violation </table>"
  }
 },
 {
  "label": "FieldBlock( <cFieldName> ) --> bFieldBlock",
  "documentation": "Return a code block that sets/gets a value for a given field",
  "arguments": [
   {
    "label": "<cFieldName>",
    "documentation": "is a string that contain the field name."
   }
  ],
  "name": "FieldBlock",
  "return": {
   "name": "",
   "help": "FieldBlock() return a code block that when evaluate could retrieve a field value or assigning a new value to the field. If <cFieldName> is not specified or from type other than character, FieldBlock() return NIL."
  }
 },
 {
  "label": "FieldGet( <nField> ) --> ValueField",
  "documentation": "Obtains the value  of a specified field",
  "arguments": [
   {
    "label": "<nField>",
    "documentation": "Is the numeric field position"
   }
  ],
  "name": "FieldGet",
  "return": {
   "name": "<ValueField>",
   "help": "Any expression"
  }
 },
 {
  "label": "FieldName()/Field( <nPosition> ) --> cFieldName",
  "documentation": "Return the name of a field at a numeric field location.",
  "arguments": [
   {
    "label": "<nPosition>",
    "documentation": "Field order in the database."
   }
  ],
  "name": "FieldName",
  "return": {
   "name": "<cFieldName>",
   "help": "returns the field name."
  }
 },
 {
  "label": "FieldPos( <cFieldName> ) --> nFieldPos",
  "documentation": "Return the ordinal position of a field.",
  "arguments": [
   {
    "label": "<cFieldName>",
    "documentation": "Name of a field."
   }
  ],
  "name": "FieldPos",
  "return": {
   "name": "<nFieldPos>",
   "help": "is ordinal position of the field."
  }
 },
 {
  "label": "FieldPut( <nField>, <expAssign> ) --> ValueAssigned",
  "documentation": "Set the value of a field variable",
  "arguments": [
   {
    "label": "<nField>",
    "documentation": "The field numeric position"
   },
   {
    "label": "<expAssign>",
    "documentation": "Expression to be assigned to the specified field"
   }
  ],
  "name": "FieldPut",
  "return": {
   "name": "<ValueAssigned>",
   "help": "Any expression"
  }
 },
 {
  "label": "FieldWBlock( <cFieldName>, <nWorkArea> ) --> bFieldBlock",
  "documentation": "Return a sets/gets code block for field in a given work area",
  "arguments": [
   {
    "label": "<cFieldName>",
    "documentation": "is a string that contain the field name."
   },
   {
    "label": "<nWorkArea>",
    "documentation": "is the work area number in which <cFieldName> exist."
   }
  ],
  "name": "FieldWBlock",
  "return": {
   "name": "",
   "help": "FieldWBlock() return a code block that when evaluate could retrieve field value or assigning a new value for a field in a given work area. If <cFieldName> is not specified or from type other than character, or if <nWorkArea> is not specified or is not numeric FieldWBlock() return NIL."
  }
 },
 {
  "label": "File( <cFileSpec> ) --> lExists",
  "documentation": "Tests for the existence of file(s)",
  "arguments": [
   {
    "label": "<cFileSpec>",
    "documentation": "File name skeleton or file name to find."
   }
  ],
  "name": "File",
  "return": {
   "name": "<lExists>",
   "help": "a logical true (.T.) if the file exists or logical false (.F.)."
  }
 },
 {
  "label": "FLock() --> lSuccess",
  "documentation": "Locks a file",
  "arguments": [],
  "name": "FLock",
  "return": {
   "name": "<lSuccess>",
   "help": "A true (.T.) value, if the lock was successful; otherwise false (.F.)"
  }
 },
 {
  "label": "Floor( <nNumber> ) -> nDownRoundedNumber",
  "documentation": "Rounds down a number to the next integer",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "number to round down"
   }
  ],
  "name": "Floor",
  "return": {
   "name": "<nDownRoundedNumber>",
   "help": "the rounded number"
  }
 },
 {
  "label": "FOpen( <cFile>, [<nMode>] ) --> nHandle",
  "documentation": "Open a file.",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "Name of file to open."
   },
   {
    "label": "<nMode>",
    "documentation": "File open mode."
   }
  ],
  "name": "FOpen",
  "return": {
   "name": "<nHandle>",
   "help": "A file handle."
  }
 },
 {
  "label": "Found() --> lSuccess",
  "documentation": "Determine the success of a previous search operation.",
  "arguments": [],
  "name": "Found",
  "return": {
   "name": "<lSuccess>",
   "help": "A logical true (.T.) is successful; otherwise, false (.F.)"
  }
 },
 {
  "label": "FRead( <nHandle>, @<cBuffer>, <nBytes> ) --> nBytes",
  "documentation": "Reads a specified number of bytes from a file.",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "File handle"
   },
   {
    "label": "<cBuffer>",
    "documentation": "Character expression passed by reference."
   },
   {
    "label": "<nBytes>",
    "documentation": "Number of bytes to read."
   }
  ],
  "name": "FRead",
  "return": {
   "name": "<nBytes>",
   "help": "the number of bytes successfully read from the file. <nHandle>"
  }
 },
 {
  "label": "FReadStr( <nHandle>, <nBytes> ) --> cString",
  "documentation": "Reads a string from a file.",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "File handle number."
   },
   {
    "label": "<nBytes>",
    "documentation": "Number of bytes to read."
   }
  ],
  "name": "FReadStr",
  "return": {
   "name": "<cString>",
   "help": "an character expression"
  }
 },
 {
  "label": "FRename( <cOldFile>, <cNewFile> ) --> nSuccess",
  "documentation": "Renames a file",
  "arguments": [
   {
    "label": "<cOldFile>",
    "documentation": "Old file name to be changed"
   },
   {
    "label": "<cNewFile>",
    "documentation": "New file name"
   }
  ],
  "name": "FRename",
  "return": {
   "name": "<nSuccess>",
   "help": "If successful, a 0 will be returned otherwise, a -1 will be returned."
  }
 },
 {
  "label": "FSeek( <nHandle>, <nOffset>, [<nOrigin>] ) --> nPosition",
  "documentation": "Positions the file pointer in a file.",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "File handle."
   },
   {
    "label": "<nOffset>",
    "documentation": "The number of bytes to move."
   },
   {
    "label": "<nOrigin>",
    "documentation": "The relative position in the file."
   }
  ],
  "name": "FSeek",
  "return": {
   "name": "<nPosition>",
   "help": "the current position relative to begin-of-file"
  }
 },
 {
  "label": "ft_AAddition( <aList1>, <aList2> [, <lTrimmer> [, <lCaseSens> ] ] ) ; -> aNewArray",
  "documentation": "Add elements unique of source array to target array",
  "arguments": [
   {
    "label": "<aList1>",
    "documentation": "is the primary array."
   },
   {
    "label": "<aList2>",
    "documentation": "is the secondary array."
   },
   {
    "label": "<lTrimmer>",
    "documentation": "is a logical value denoting whether leading or trailing spaces should be included in the comparison. If .T., then ignores spaces in comparison, defaults to .T., .F. includes spaces."
   },
   {
    "label": "<lCaseSens>",
    "documentation": "is a logical value denoting case sensitivity. If .T., then comparison is sensitive to case, defaults to .T., .F. ignores case."
   }
  ],
  "name": "ft_AAddition",
  "return": {
   "name": "",
   "help": "An array of the union of aList1 and aList2."
  }
 },
 {
  "label": "ft_AAvg( <aArray> [, <nStartIndex> [, <nEndIndex> ] ] ) -> nAverage",
  "documentation": "Average numeric values in an array",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "is the array containing the elements to be averaged."
   },
   {
    "label": "<nStartIndex>",
    "documentation": "is the first array item to include, defaults to first element."
   },
   {
    "label": "<nEndIndex>",
    "documentation": "is the last array element to include, defaults to all elements."
   }
  ],
  "name": "ft_AAvg",
  "return": {
   "name": "",
   "help": "The average of the specified array elements."
  }
 },
 {
  "label": "ft_AcctAdj( [ <dGivenDate> ], [ <lIsEnd> ] ) -> dDate",
  "documentation": "Adjust beginning or ending fiscal pd. dates to acctg. dates",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any valid format. Defaults to Date() if not supplied."
   },
   {
    "label": "<lIsEnd>",
    "documentation": "is a logical variable. .F. = adjust for beginning of period mode, .T. = adjust for end of period mode.  Defaults to beginning of period mode."
   }
  ],
  "name": "ft_AcctAdj",
  "return": {
   "name": "",
   "help": "An adjusted date dependent upon mode and work week start day."
  }
 },
 {
  "label": "ft_AcctMonth( [ <dGivenDate> ], [ <nMonthNum> ] ) -> aDateInfo",
  "documentation": "Return accounting month data",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any date format.  Defaults to current system date if not supplied."
   },
   {
    "label": "<nMonthNum>",
    "documentation": "is a number from 1 to 12 signifying a month. Defaults to current month if not supplied."
   }
  ],
  "name": "ft_AcctMonth",
  "return": {
   "name": "",
   "help": "A three element array containing the following data: aDateInfo[ 1 ] - The year and month as a character string \"YYYYMM\" aDateInfo[ 2 ] - The beginning date of the accounting month aDateInfo[ 3 ] - The ending date of the accounting month"
  }
 },
 {
  "label": "ft_AcctQtr( [ <dGivenDate> ], [ <nQtrNum> ] ) -> aDateinfo",
  "documentation": "Return accounting quarter data",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any date format.  Defaults to current system date if not supplied."
   },
   {
    "label": "<nQtrNum>",
    "documentation": "is a number from 1 to 4 signifying a quarter. Defaults to current quarter if not supplied."
   }
  ],
  "name": "ft_AcctQtr",
  "return": {
   "name": "",
   "help": "A three element array containing the following data: aDateInfo[ 1 ] - The year and qtr. as a character string \"YYYYQQ\" aDateInfo[ 2 ] - The beginning date of the accounting quarter aDateInfo[ 3 ] - The ending date of the accounting quarter"
  }
 },
 {
  "label": "ft_AcctWeek( [ <dGivenDate> ], [ <nWeekNum> ] ) -> aDateInfo",
  "documentation": "Return accounting week data",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any date format.  Defaults to current system date if not supplied."
   },
   {
    "label": "<nWeekNum>",
    "documentation": "is a number from 1 to 52 signifying a week. Defaults to current week if not supplied."
   }
  ],
  "name": "ft_AcctWeek",
  "return": {
   "name": "",
   "help": "A three element array containing the following data: aDateInfo[ 1 ] - The year and week as a character string \"YYYYWW\" aDateInfo[ 2 ] - The beginning date of the accounting week aDateInfo[ 3 ] - The ending date of the accounting week"
  }
 },
 {
  "label": "ft_AcctYear( [ <dGivenDate> ] ) -> aDateInfo",
  "documentation": "Return accounting year data",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any date format.  Defaults to current system date if not supplied."
   }
  ],
  "name": "ft_AcctYear",
  "return": {
   "name": "",
   "help": "A three element array containing the following data: aDateInfo[ 1 ] - The year as a character string \"YYYY\" aDateInfo[ 2 ] - The beginning date of the accounting year aDateInfo[ 3 ] - The ending date of the accounting year"
  }
 },
 {
  "label": "ft_Adapter() -> nResult",
  "documentation": "Report the type of video adapter installed",
  "arguments": [],
  "name": "ft_Adapter",
  "return": {
   "name": "",
   "help": "Integer representing type of video adapter 0 - monochrome 1 - CGA 2 - EGA 3 - VGA"
  }
 },
 {
  "label": "ft_Adder()",
  "documentation": "Pop up a simple calculator",
  "arguments": [],
  "name": "ft_Adder",
  "return": {
   "name": "",
   "help": "NIL .... but optionally places Total of calculation in active Get variable using oGet:varPut()"
  }
 },
 {
  "label": "ft_AddWkDy( <dStart>, <nWorkDays> ) -> nTrueDays",
  "documentation": "Return true number of days to add given number of workdays",
  "arguments": [
   {
    "label": "<dStart>",
    "documentation": "= date to start adding from"
   },
   {
    "label": "<nWorkDays>",
    "documentation": "= number of workdays to add"
   }
  ],
  "name": "ft_AddWkDy",
  "return": {
   "name": "<nTrueDays>",
   "help": "= Number of actual days to add to <dStart> in order to add the required <nWorkDays>"
  }
 },
 {
  "label": "ft_ADesSort( <aArray> [, <nStartIndex> [, <nEndIndex> ] ] ) -> aSorted",
  "documentation": "Sort an array in descending order",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "is the array to be sorted"
   },
   {
    "label": "<nStartIndex>",
    "documentation": "is the first array item to include in the sort, defaults to first element"
   },
   {
    "label": "<nEndIndex>",
    "documentation": "is the last array element to include in the sort, defaults to all elements"
   }
  ],
  "name": "ft_ADesSort",
  "return": {
   "name": "",
   "help": "The array, sorted in descending order."
  }
 },
 {
  "label": "ft_AEMaxLen( <aArray> [, <nDimension> [, <nStart> [, <nCount> ] ] ] ) ; -> nMaxlen",
  "documentation": "Find longest element within an array",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "is the array containing the elements to be measured."
   },
   {
    "label": "<nDimension>",
    "documentation": "is the array dimension to be measured, defaults to first dimension."
   },
   {
    "label": "<nStart>",
    "documentation": "is the starting array element to include, defaults to first array element."
   },
   {
    "label": "<nCount>",
    "documentation": "is the number of array elements to process from from <nStart>, defaults to remaining elements in array."
   }
  ],
  "name": "ft_AEMaxLen",
  "return": {
   "name": "",
   "help": "The length of the longest size element of an array."
  }
 },
 {
  "label": "ft_AEMinLen( <aArray> [, <nDimension> [, <nStart> [, <nCount> ] ] ] ) -> nMinlen",
  "documentation": "Find shortest element within an array",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "is the array containing the elements to be measured."
   },
   {
    "label": "<nDimension>",
    "documentation": "is the array dimension to be measured, defaults to first dimension."
   },
   {
    "label": "<nStart>",
    "documentation": "is the starting array element to include, defaults to first array element."
   },
   {
    "label": "<nCount>",
    "documentation": "is the number of array elements to process from from <nStart>, defaults to remaining elements in array."
   }
  ],
  "name": "ft_AEMinLen",
  "return": {
   "name": "",
   "help": "The length of the shortest size element of an array."
  }
 },
 {
  "label": "ft_Alt() -> lValue",
  "documentation": "Determine status of the Alt key",
  "arguments": [],
  "name": "ft_Alt",
  "return": {
   "name": "",
   "help": ".T. if Alt key is pressed, .F. if otherwise."
  }
 },
 {
  "label": "ft_AMedian( <aArray> [, <nStart> [, <nEnd> ] ] ) -> nMedian",
  "documentation": "Find middle value in array, or average of two middle values",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "is the array containing the elements to be averaged."
   },
   {
    "label": "<nStart>",
    "documentation": "is the first array element to include, defaults to first element."
   },
   {
    "label": "<nEnd>",
    "documentation": "is the last array element to include, defaults to last element."
   }
  ],
  "name": "ft_AMedian",
  "return": {
   "name": "",
   "help": "The median average of the array elements"
  }
 },
 {
  "label": "ft_ANoMatches( <aArray>, <bCompareBlock> ; [, <nStartIndex> [, <nEndIndex> ] ] ) -> nNoOfMatches",
  "documentation": "Find the number of array elements meeting a condition",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "is the array to be searched"
   },
   {
    "label": "<bCompareBlock>",
    "documentation": "is a code block containing the expression for the array elements to be tested with.  Each element is passed as a parameter to the block.  If the block returns .T., the number of matches will be incremented by one."
   },
   {
    "label": "<nStartIndex>",
    "documentation": "is the first array item to include in the search, defaults to first element."
   },
   {
    "label": "<nEndIndex>",
    "documentation": "is the last array element to include in the search, defaults to all elements."
   }
  ],
  "name": "ft_ANoMatches",
  "return": {
   "name": "",
   "help": "The number of elements that cause the code block to return .T."
  }
 },
 {
  "label": "ft_ArEdit( <nTop>, <nLeft>, <nBottom>, <nRight>, <Array Name>, ; <nElem>, <aHeadings>, <aBlocks> [, <bGetFunc> ] ) -> xElement",
  "documentation": "2 dimensional array editing function using TBrowse",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": ", <nLeft>, <nBottom>, <nRight> are coordinates for TBrowse"
   },
   {
    "label": "<Array Name>",
    "documentation": "is name of 2 dimensional to array edit"
   },
   {
    "label": "<nElem>",
    "documentation": "is pointer for element in array"
   },
   {
    "label": "<aHeadings>",
    "documentation": "is array of column headings"
   },
   {
    "label": "<aBlocks>",
    "documentation": "is array of blocks describing each array element [ <bGetFunc> ] is get editing function for handling individual elements"
   }
  ],
  "name": "ft_ArEdit",
  "return": {
   "name": "",
   "help": "Value of element positioned on when exit ft_ArEdit() The type of this value depends on what is displayed."
  }
 },
 {
  "label": "ft_ASum( <aArray> [, <nStartIndex> [, <nEndIndex> ] ] ) -> nSum",
  "documentation": "Sum the elements of an array",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "is the array containing the elements to be summed."
   },
   {
    "label": "<nStartIndex>",
    "documentation": "is the first array item to include, defaults to first element."
   },
   {
    "label": "<nEndIndex>",
    "documentation": "is the last array element to include, defaults to all elements."
   }
  ],
  "name": "ft_ASum",
  "return": {
   "name": "",
   "help": "The sum of the elements of the array or the lengths of the elements."
  }
 },
 {
  "label": "ft_At2( <cSearch>, <cTarget> [, <nOccurs> [, <lCaseSens> ] ] ) -> nPos",
  "documentation": "Find position of the nth occurrence of a substring",
  "arguments": [
   {
    "label": "<cSearch>",
    "documentation": "is the character substring to search for."
   },
   {
    "label": "<cTarget>",
    "documentation": "is the character string to search."
   },
   {
    "label": "<nOccurs>",
    "documentation": "is the occurrence of cSearch to look for, defaults to 1."
   },
   {
    "label": "<lCaseSens>",
    "documentation": "is a logical value denoting case sensitivity. If .F., then search is NOT sensitive to case, defaults to .T."
   }
  ],
  "name": "ft_At2",
  "return": {
   "name": "",
   "help": "The position of the nth occurrence of a substring"
  }
 },
 {
  "label": "ft_BitClr( <cByte>, <nBitPos> ) -> cByte",
  "documentation": "Clear (reset) selected bit in a byte",
  "arguments": [
   {
    "label": "<cByte>",
    "documentation": "is a character from hb_BChar( 0 ) to hb_BChar( 255 )."
   },
   {
    "label": "<nBitPos>",
    "documentation": "is a number from 0 to 7 conforming to standard right-to-left bit numbering convention and representing the position of the bit within the byte."
   }
  ],
  "name": "ft_BitClr",
  "return": {
   "name": "",
   "help": "Returns new byte, with designated bit cleared (reset). If parameters are faulty, returns NIL."
  }
 },
 {
  "label": "ft_BitSet( <cByte>, <nBitPos> ) -> cByte",
  "documentation": "Set selected bit in a byte",
  "arguments": [
   {
    "label": "<cByte>",
    "documentation": "is a character from hb_BChar( 0 ) to hb_BChar( 255 )."
   },
   {
    "label": "<nBitPos>",
    "documentation": "is a number from 0 to 7 conforming to standard right-to-left bit numbering convention and representing the position of the bit within the byte."
   }
  ],
  "name": "ft_BitSet",
  "return": {
   "name": "",
   "help": "Returns new byte, with designated bit set.  If parameters are faulty, returns NIL."
  }
 },
 {
  "label": "ft_Blink( <cMsg>, [ <nRow> ], [ <nCol> ] ) -> NIL",
  "documentation": "Display a blinking message on the screen",
  "arguments": [
   {
    "label": "<cMsg>",
    "documentation": "is the string to blink."
   },
   {
    "label": "<nRow>",
    "documentation": "is an optional screen row for @...SAY, default current."
   },
   {
    "label": "<nCol>",
    "documentation": "is an optional screen col for @...say, default current."
   }
  ],
  "name": "ft_Blink",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_BrwsWhl( <aFields>, <bWhileCond>, <cKey>,                  ; [ <nFreeze> ], [ <lSaveScrn> ], [ <cColorList> ], ; [ <cColorShadow> ], [ <nTop> ], [ <nLeft> ],      ; [ <nBottom> ], [ <nRight> ] -> nRecno",
  "documentation": "Browse an indexed database limited to a while condition",
  "arguments": [
   {
    "label": "<aFields>",
    "documentation": "is array of field blocks of fields you want to display. Example to set up last name and first name in array: aFields := {} AAdd( aFields, { \"Last Name\" , {|| Names->Last }  } ) AAdd( aFields, { \"First Name\", {|| Names->First } } )"
   },
   {
    "label": "<bWhileCond>",
    "documentation": "is the limiting WHILE condition as a block. Example 1: {|| Names->Last == \"JONES\" } Example 2: {|| Names->Last == \"JONES\" .AND. Names->First == \"A\"  }"
   },
   {
    "label": "<cKey>",
    "documentation": "is the key to find top condition of WHILE. cLast  := \"JONES     \" cFirst := \"A\" Example 1: cKey := cLast Example 2: cKey := cLast + cFirst"
   },
   {
    "label": "<nFreeze>",
    "documentation": "is number of fields to freeze in TBrowse.  Defaults to 0 if not passed."
   },
   {
    "label": "<lSaveScrn>",
    "documentation": "is a logical indicating whether or not you want to save the screen from the calling program.  Defaults to .T. if not passed."
   },
   {
    "label": "<cColorList>",
    "documentation": "is a list of colors for the TBrowse columns. The 1st color is used as SAY/TBrowse Background and the 3rd and 4th colors are used as part of column:defColor := { 3, 4 } Thus if you pass a cColorList, you MUST pass at least 4 colors. Defaults to \"N/W, N/BG, B/W, B/BG, B/W, B/BG, R/W, B/R\" if not passed."
   },
   {
    "label": "<cColorShad>",
    "documentation": "is the color of the TBrowse box shadow.  Defaults to \"N/N\" if not passed."
   },
   {
    "label": "<nTop>",
    "documentation": ", <nLeft>, <nBottom>, <nRight> are the coordinates of the area to display the TBrowse in.  Defaults to 2, 2, MaxRow() - 2, MaxCol() - 2 with shadowed box, i.e. full screen."
   }
  ],
  "name": "ft_BrwsWhl",
  "return": {
   "name": "",
   "help": "nRecno is the number of the record selected by the <Enter> key. 0 is returned if there are either no records matching the WHILE condition or an <Esc> is pressed instead of an <Enter>"
  }
 },
 {
  "label": "ft_Byt2Bit( <cByte> ) -> cBitPattern",
  "documentation": "Convert byte to string of 1's and 0's",
  "arguments": [
   {
    "label": "<cByte>",
    "documentation": "is the byte to convert."
   }
  ],
  "name": "ft_Byt2Bit",
  "return": {
   "name": "",
   "help": "9-character string, consisting of 1's and 0's, representing bits 0 through 7 of parameter byte, with space between bits 3 and 4.  Returns NIL if parameters are faulty."
  }
 },
 {
  "label": "ft_Byt2Hex( cByte ) -> cHexValue",
  "documentation": "Convert byte to hexadecimal version of its binary value",
  "arguments": [
   {
    "label": "<cByte>",
    "documentation": "is the byte to convert."
   }
  ],
  "name": "ft_Byt2Hex",
  "return": {
   "name": "",
   "help": "Three-character string, consisting of two digits of hexadecimal notation and letter 'h' to signify hex.  Returns NIL if parameters are faulty."
  }
 },
 {
  "label": "ft_ByteAnd( <cByte1>, <cByte2> ) -> cByte",
  "documentation": "Perform bit-wise AND on two ASCII characters (bytes)",
  "arguments": [
   {
    "label": "<cByte1>",
    "documentation": "and <cByte2> are characters from hb_BChar( 0 ) to hb_BChar( 255 ). May be passed in hb_BChar() form, as character literals, or as expressions evaluating to character values."
   }
  ],
  "name": "ft_ByteAnd",
  "return": {
   "name": "",
   "help": "Returns resulting byte, as a string.  If parameters are faulty, returns NIL."
  }
 },
 {
  "label": "ft_ByteNeg( <cByte> ) -> cNewByte",
  "documentation": "Perform bit-wise negation on an ASCII character",
  "arguments": [
   {
    "label": "<cByte>",
    "documentation": "is a character from hb_BChar( 0 ) to hb_BChar( 255 ). May be passed in hb_BChar() form, as character literals, or as expressions evaluating to character values."
   }
  ],
  "name": "ft_ByteNeg",
  "return": {
   "name": "",
   "help": "Returns resulting byte, as a string.  If parameters are faulty, returns NIL."
  }
 },
 {
  "label": "ft_ByteNot( <cByte> ) -> cNewByte",
  "documentation": "Perform bit-wise NOT on an ASCII character (byte)",
  "arguments": [
   {
    "label": "<cByte>",
    "documentation": "is a character from hb_BChar( 0 ) to hb_BChar( 255 ). May be passed in hb_BChar() form, as character literals, or as expressions evaluating to character values."
   }
  ],
  "name": "ft_ByteNot",
  "return": {
   "name": "",
   "help": "Returns resulting byte, as a string.  If parameters are faulty, returns NIL."
  }
 },
 {
  "label": "ft_ByteOr( <cByte1>, <cByte2> ) -> cNewByte",
  "documentation": "Perform bit-wise OR on two ASCII characters (bytes)",
  "arguments": [
   {
    "label": "<cByte1>",
    "documentation": "and <cByte2> are characters from hb_BChar( 0 ) to hb_BChar( 255 ). May be passed in hb_BChar() form, as character literals, or as expressions evaluating to character values."
   }
  ],
  "name": "ft_ByteOr",
  "return": {
   "name": "",
   "help": "Returns resulting byte, as a string.  If parameters are faulty, returns NIL."
  }
 },
 {
  "label": "ft_ByteXor( <cByte1>, <cByte2> ) -> cNewByte",
  "documentation": "Perform bit-wise XOR on two ASCII characters (bytes)",
  "arguments": [
   {
    "label": "<cByte1>",
    "documentation": "and <cByte2> are characters from hb_BChar( 0 ) to hb_BChar( 255 ). May be passed in hb_BChar() form, as character literals, or as expressions evaluating to character values."
   }
  ],
  "name": "ft_ByteXor",
  "return": {
   "name": "",
   "help": "Returns resulting byte, as a string.  If parameters are faulty, returns NIL."
  }
 },
 {
  "label": "ft_Calendar( [ <nRow> ], [ <nCol> ], [ <cColor> ], [ <lShadow> ] , [ <lShowHelp> ] ) -> aRetVal",
  "documentation": "Display date/time calendar, find a date, return calendar data.",
  "arguments": [
   {
    "label": "<nRow>",
    "documentation": "is an optional screen row for calendar display, default row 1."
   },
   {
    "label": "<nCol>",
    "documentation": "is an optional screen col for calendar display, default col 63."
   },
   {
    "label": "<cColor>",
    "documentation": "is an optional color string for displayed messages, default is bright white text over green background."
   },
   {
    "label": "<lShadow>",
    "documentation": "is an optional logical variable. If true (.T.), it uses ft_Shadow() to add a transparent shadow to the display, default (.F.)."
   },
   {
    "label": "<lShowHelp>",
    "documentation": "is an optional logical variable. If true, uses ft_XBox() to display  a four line help message if the F1 key is pressed, default (.F.)."
   }
  ],
  "name": "ft_Calendar",
  "return": {
   "name": "",
   "help": "aRetVal  is an 8 element array containing date, month, day, year, month (in character format), day of the week, julian day and current time."
  }
 },
 {
  "label": "ft_CapLock([ <lNewSetting> ]) -> lCurrentSetting",
  "documentation": "Determine and optionally change the status of CapLock key",
  "arguments": [
   {
    "label": "<lNewSetting>",
    "documentation": "is optional and if supplied is the new setting for the CapLock key.  Specify .T. to turn CapLock on, or .F. to turn it off."
   }
  ],
  "name": "ft_CapLock",
  "return": {
   "name": "",
   "help": ".T. if CapLock is set, .F. if it isn't set.  The value returned represents the setting in effect prior to any changes that might by made by <lNewSetting>."
  }
 },
 {
  "label": "ft_ChDir( <cDirName> ) -> nResult",
  "documentation": "Change the current directory",
  "arguments": [
   {
    "label": "<cDirName>",
    "documentation": "is the name of the desired directory."
   }
  ],
  "name": "ft_ChDir",
  "return": {
   "name": "",
   "help": "0  if successful 3  if path not found 99 if invalid parameters passed"
  }
 },
 {
  "label": "ft_Civ2Mil( <cCIVTIME> ) -> cMILTIME",
  "documentation": "Convert usual civilian format time to military time.",
  "arguments": [
   {
    "label": "<cCIVTIME>",
    "documentation": "character string of form hh:mm (am,pm,n or m), where 0<hh<12."
   }
  ],
  "name": "ft_Civ2Mil",
  "return": {
   "name": "<cMILTIME>",
   "help": "character string of form hhmm, where 0<=hh<24."
  }
 },
 {
  "label": "ft_ClrSel( <aClrData>, [ <lClrMode> ], [ <cTestChr> ]  -> aClrData",
  "documentation": "User Selectable Color Routine",
  "arguments": [
   {
    "label": "<aClrData>",
    "documentation": "is an array of subarrays, with each subarray containing information about the color settings. The subarray has the following structure: [ 1 ] cName    is the name of this color setting i.e. \"Pick List\" Maximum length is 20 bytes [ 2 ] cClrStr  is the current color string Default is \"W/N,N/W,N/N,N/N,N/W\" If Setting type is \"M\" (Menu) the colors are... 1.  Prompt Color 2.  Message Color 3.  HotKey Color 4.  LightBar Color 5.  LightBar HotKey Color Note: While there are many ways to code the individual color combinations,  they should be in the same format that gets returned from SetColor(), so the defaults can be found in the color palette. foreground [+] / background [*] i.e. \"GR+/BG*, N/W*, N+/N, , W/N\" [ 3 ] cType  is the type of color setting Default is \"W\" (Window) T = Title     Only 1 color element D = Desktop   Background color and character M = Menu      For ft_MenuTo() style menus W = Window    Windows with radio buttons G = Get       For use with @ SAY... B = Browse    For TBrowse() and *dbEdit() A = aChoice   Pick-lists etc... W/G/B/A are functionally the same but will provide a more appropriate test display. [ 4 ] cFillChar  is the character (for desktop background only) Default is \"▒▒▒▒▒▒▒▒▒▒▒▒▒▒\""
   },
   {
    "label": "<lClrMode>",
    "documentation": ".T.  use color palette .F.  use monochrome palette Default is the IsColor() setting"
   },
   {
    "label": "<cTestChr>",
    "documentation": "2 Byte character string for color test display Default is \"■■\""
   }
  ],
  "name": "ft_ClrSel",
  "return": {
   "name": "",
   "help": "An array identical to the one passed, with new selected colors"
  }
 },
 {
  "label": "ft_CLS( <nTRow>, <nLCol>, <nBRow>, <nRCol>, <nColor> ) -> NIL",
  "documentation": "Clear screen",
  "arguments": [
   {
    "label": "<nTRow>",
    "documentation": ", <nLCol>, <nBRow> and  <nRCol> are the screen coordinates to clear."
   },
   {
    "label": "<nColor>",
    "documentation": "is an integer representing the color attribute. The formula is: nFore + ( nBack * 16 ) The default is black."
   }
  ],
  "name": "ft_CLS",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Color2N( <cColor> ) -> nValue",
  "documentation": "Returns the numeric complement of a Clipper color string",
  "arguments": [
   {
    "label": "<cColor>",
    "documentation": "is a Clipper color string"
   }
  ],
  "name": "ft_Color2N",
  "return": {
   "name": "",
   "help": "The numeric complement of a color string or 0 if passed color is invalid."
  }
 },
 {
  "label": "ft_Color2N( <nColor> ) -> cColor",
  "documentation": "Returns the string complement of a Clipper color number",
  "arguments": [
   {
    "label": "<nColor>",
    "documentation": "a number representing a Clipper color"
   }
  ],
  "name": "ft_Color2N",
  "return": {
   "name": "",
   "help": "The string complement of a number representing a Clipper or a null string if the parameter is invalid"
  }
 },
 {
  "label": "ft_Ctrl() -> lValue",
  "documentation": "Determine status of the Ctrl key",
  "arguments": [],
  "name": "ft_Ctrl",
  "return": {
   "name": "",
   "help": ".T. if Ctrl key is pressed, .F. if otherwise."
  }
 },
 {
  "label": "ft_D2E( <nDec>, <nPrecision> )  -> <cNumE>",
  "documentation": "Convert decimal to scientific notation",
  "arguments": [
   {
    "label": "<nDec>",
    "documentation": "Decimal number to convert"
   },
   {
    "label": "<nPrecision>",
    "documentation": "Number of decimal places in result. Defaults to 6 decimal places."
   }
  ],
  "name": "ft_D2E",
  "return": {
   "name": "<cNumE>",
   "help": "A string representing a number in scientific notation"
  }
 },
 {
  "label": "ft_DateCnfg( [ <cFYStart> ], [ <nDow> ] ) -> aDateInfo",
  "documentation": "Set beginning of year/week for ft_*() date functions",
  "arguments": [
   {
    "label": "<cFYStart>",
    "documentation": "is a character date string in the user's system date format, i.e., the same as the user would enter for CToD().  If this argument is NIL, the current value is unchanged. Note: The year portion of the date string must be present and be a valid year; however, it has no real meaning."
   },
   {
    "label": "<nDow>",
    "documentation": "is a number from 1 to 7 (1 = Sunday) indicating the desired start of a work week.  If this argument is NIL, the current value is unchanged."
   }
  ],
  "name": "ft_DateCnfg",
  "return": {
   "name": "",
   "help": "A 2-element array containing the following information: aDateInfo[ 1 ] - an ANSI date string indicating the beginning date of the year.  Only the month and day are meaningful. aDateInfo[ 2 ] - the number of the first day of the week (1 = Sunday)"
  }
 },
 {
  "label": "ft_DayOfYr( [ <dGivenDate> ], [ <nDayNum> ], [ <lIsAcct> ] ) -> aDateInfo",
  "documentation": "Return calendar, fiscal or accounting day data",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any valid format.  Defaults to current system date if not supplied."
   },
   {
    "label": "<nDayNum>",
    "documentation": "is a number from 1 to 371, signifying a day of a year. Defaults to current day if not supplied."
   },
   {
    "label": "<lIsAcct>",
    "documentation": "is a logical which specifies the type of year to base the return value on:  .F. = calendar or fiscal year, .T. = accounting year."
   }
  ],
  "name": "ft_DayOfYr",
  "return": {
   "name": "",
   "help": "A three element array containing the following data: If <nDayNum> is specified: aDateInfo[ 1 ] - The date of the specified day number aDateInfo[ 2 ] - The beginning date of the year aDateInfo[ 3 ] - The ending date of the year If <nDayNum> is not specified: aDateInfo[ 1 ] - The year and day as a character string \"YYYYDDD\" aDateInfo[ 2 ] - The beginning date of the year aDateInfo[ 3 ] - The ending date of the year"
  }
 },
 {
  "label": "ft_DayToBoW( [ <dGivenDate> ] ) -> nDays",
  "documentation": "Calculate no. of days between date and beginning of week",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any valid date format. Defaults to current date if not supplied."
   }
  ],
  "name": "ft_DayToBoW",
  "return": {
   "name": "",
   "help": "A positive number of days to beginning of week, range 0 to 6."
  }
 },
 {
  "label": "ft_Dec2Bin( <nNum> ) -> cBinaryNumber",
  "documentation": "Convert decimal to binary",
  "arguments": [
   {
    "label": "<nNum>",
    "documentation": "is the numeric expression to be converted."
   }
  ],
  "name": "ft_Dec2Bin",
  "return": {
   "name": "",
   "help": "A character string representing <nNum> in binary format."
  }
 },
 {
  "label": "ft_Default( [ <cDrive> ] ) -> cDrive",
  "documentation": "Retrieve and optionally change the current default drive",
  "arguments": [
   {
    "label": "<cDrive>",
    "documentation": "is optional, and if specified is the new default drive."
   }
  ],
  "name": "ft_Default",
  "return": {
   "name": "",
   "help": "The current default drive.  If a change of default drive is requested, the return value is the drive AFTER the change is made.  This allows you to make sure you specified a valid drive (i.e. if you attempt to change the default drive, and the function returns a different drive letter than the one you specified, then the drive does not exist)."
  }
 },
 {
  "label": "ft_Descend( <exp> ) -> <value>",
  "documentation": "Create a descending index key value",
  "arguments": [
   {
    "label": "<exp>",
    "documentation": "is any expression of character, numeric, date, or logical type."
   }
  ],
  "name": "ft_Descend",
  "return": {
   "name": "",
   "help": "The inverse of <exp>"
  }
 },
 {
  "label": "ft_DFClose() -> NIL",
  "documentation": "Close file displayed by ft_DispFile()",
  "arguments": [],
  "name": "ft_DFClose",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_DFSetup( <cInFile>, <nTop>, <nLeft>, <nBottom>, <nRight>, ; <nStart>, <nCNormal>, <nCHighlight>, <cExitKeys>,   ; <lBrowse>, <nColSkip>, <nRMargin>, <nBuffSize> ) -> nResult",
  "documentation": "Set up parameters for ft_DispFile()",
  "arguments": [
   {
    "label": "<cInFile>",
    "documentation": "- text file to display (full path and filename)"
   },
   {
    "label": "<nTop>",
    "documentation": "- upper row of window"
   },
   {
    "label": "<nLeft>",
    "documentation": "- left col of window"
   },
   {
    "label": "<nBottom>",
    "documentation": "- lower row of window"
   },
   {
    "label": "<nRight>",
    "documentation": "- right col of window"
   },
   {
    "label": "<nStart>",
    "documentation": "- line to place highlight at startup"
   },
   {
    "label": "<nCNormal>",
    "documentation": "- normal text color     (numeric attribute)"
   },
   {
    "label": "<nCHighlight>",
    "documentation": "- text highlight color  (numeric attribute)"
   },
   {
    "label": "<cExitKeys>",
    "documentation": "- terminating key list  (each byte of string is a key code)"
   },
   {
    "label": "<lBrowse>",
    "documentation": "- act-like-a-browse-routine flag"
   },
   {
    "label": "<nColSkip>",
    "documentation": "- col increment for left/right arrows"
   },
   {
    "label": "<nRMargin>",
    "documentation": "- right margin - anything to right is truncated"
   },
   {
    "label": "<nBuffSize>",
    "documentation": "- size of the paging buffer"
   }
  ],
  "name": "ft_DFSetup",
  "return": {
   "name": "",
   "help": "0 if successful, FError() code if not"
  }
 },
 {
  "label": "ft_DispFile() -> cExitkey",
  "documentation": "Browse a text file",
  "arguments": [],
  "name": "ft_DispFile",
  "return": {
   "name": "",
   "help": "The ASCII keystroke that terminated ft_DispFile()"
  }
 },
 {
  "label": "ft_DispMsg( <aMessageArray>, [ <cKey2Check> ], [ <nTopBoxRow> ], [ <nLeftBoxColumn> ], [ <cnBoxType> ], [ <lShadow> ] ) -> lKeyMatch",
  "documentation": "Display a message and optionally waits for a keypress",
  "arguments": [
   {
    "label": "<aMessageArray>",
    "documentation": "is a multidimensional array of messages to be displayed and the color attributes for each message. The first dimension of the array contains one or more elements, each representing one line in the message box, up to the maximum number of rows on the screen. Within each line of the message individual characters or groups of characters may be delimited with braces ([]).  The braces will be stripped out and the character(s) inside those braces will be highlighted. The second dimension of the array contains a color attribute for the corresponding element in dimension one, plus one additional element for the color of the box border.  Dimension two will always contain one more element than dimension one.  If an attribute is omitted, the last color selected will be used."
   },
   {
    "label": "<Key2Check>",
    "documentation": "is a character string of one or more keys to check for.  If omitted, the message is displayed and control is returned to the calling procedure.  If one character is specified, ft_DispMsg() waits for one keypress, restores the screen and returns.  If multiple characters are specified, ft_DispMsg() remains in a loop until one of the specified keys has been pressed, then restores the screen and returns."
   },
   {
    "label": "<nTopBoxRow>",
    "documentation": "is the upper row for the message box.  If omitted, the box is centered vertically."
   },
   {
    "label": "<nLeftBoxColumn>",
    "documentation": "is the leftmost column for the box.  If omitted, the box is centered horizontally."
   },
   {
    "label": "<cnBoxType>",
    "documentation": "is a string of characters or a variable for the box border.  See the DispBox() function.  If omitted, a double box is drawn."
   },
   {
    "label": "<lShadow>",
    "documentation": "is a logical variable.  If true (.T.) or omitted, it uses ft_Shadow() to add a transparent shadow to the box.  If false (.F.), the box is drawn without the shadow."
   }
  ],
  "name": "ft_DispMsg",
  "return": {
   "name": "",
   "help": "If <Key2Check> is not specified, ft_DispMsg() will return false (.F.). If <Key2Check> is a one-character string, ft_DispMsg() will return true (.T.) if the user presses that key, or false (.F.) if any other key is pressed. If <Key2Check> consists of multiple characters, it will lock the user in a loop until one of those keys are pressed and return the Inkey() value of the keypress."
  }
 },
 {
  "label": "ft_DosVer() -> <cVersion>",
  "documentation": "Return the current DOS major and minor version as a string",
  "arguments": [],
  "name": "ft_DosVer",
  "return": {
   "name": "",
   "help": "A character string with the major version number first, a period (\".\"), then the minor version number (e.g., \"3.30\")"
  }
 },
 {
  "label": "ft_DoY( <dDate> ) -> <nResult>",
  "documentation": "Find number of day within year",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "is a date in the form \"mm/dd/yy\" or \"mm/dd/yyyy\""
   }
  ],
  "name": "ft_DoY",
  "return": {
   "name": "",
   "help": "Return numeric position of day within the year. Return NIL if parameter does not conform."
  }
 },
 {
  "label": "ft_DskFree( [ <cDrive> ] ) -> nSpaceAvail",
  "documentation": "Return the amount of available disk space",
  "arguments": [
   {
    "label": "<cDrive>",
    "documentation": "is the fixed disk to query. If no parameter is passed the operation will be performed on the default drive.  Do not include the \":\"."
   }
  ],
  "name": "ft_DskFree",
  "return": {
   "name": "",
   "help": "Integer representing the available disk space in bytes."
  }
 },
 {
  "label": "ft_DskSize( [ <cDrive> ] ) -> nMaxCapacity",
  "documentation": "Return the maximum capacity of a fixed disk",
  "arguments": [
   {
    "label": "<cDrive>",
    "documentation": "is the fixed disk to query. If no drive is sent, the operation will be performed on the default drive. Send without the \":\"."
   }
  ],
  "name": "ft_DskSize",
  "return": {
   "name": "",
   "help": "An integer representing the maximum disk capacity in bytes."
  }
 },
 {
  "label": "ft_E2D( <cNumE> )  -> <nDec>",
  "documentation": "Convert scientific notation string to a decimal",
  "arguments": [
   {
    "label": "<cNumE>",
    "documentation": "Scientific notation string to convert"
   }
  ],
  "name": "ft_E2D",
  "return": {
   "name": "<nDec>",
   "help": "Decimal number"
  }
 },
 {
  "label": "ft_Easter( <xYear> ) -> dEdate",
  "documentation": "Return the date of Easter",
  "arguments": [],
  "name": "ft_Easter",
  "return": {
   "name": "",
   "help": "The actual date that Easter occurs."
  }
 },
 {
  "label": "ft_ElapMin( <cTIME1>, <cTIME2> ) -> nMINUTES",
  "documentation": "Return difference, in minutes, between two mil format times.",
  "arguments": [
   {
    "label": "<cTIME1, cTIME2>",
    "documentation": "character strings of military form \"hhmm\", where 0<=hh<24."
   }
  ],
  "name": "ft_ElapMin",
  "return": {
   "name": "<nMINUTES>",
   "help": ""
  }
 },
 {
  "label": "ft_Elapsed([ <dStart> ], [ <dEnd> ], ; <cTimeStart>, <cTimeEnd>) -> aTimedata",
  "documentation": "Return elapsed time between two days and/or times",
  "arguments": [
   {
    "label": "<dStart>",
    "documentation": "is any valid date in any date format. Defaults to Date()."
   },
   {
    "label": "<dEnd>",
    "documentation": "is any valid date in any date format. Defaults to Date()."
   },
   {
    "label": "<cTimeStart>",
    "documentation": "is a valid Time string of the format 'hh:mm:ss' where hh is hours in 24-hour format."
   },
   {
    "label": "<cTimeEnd>",
    "documentation": "is a valid Time string of the format 'hh:mm:ss' where hh is hours in 24-hour format."
   }
  ],
  "name": "ft_Elapsed",
  "return": {
   "name": "",
   "help": "A two-dimensional array containing elapsed time data."
  }
 },
 {
  "label": "ft_ElTime( <cTime1>, <cTime2> ) -> cDiff",
  "documentation": "Compute difference between times in hours, minutes, seconds.",
  "arguments": [
   {
    "label": "<cTime1, cTime2>",
    "documentation": "character strings representing times in hh:mm:ss format."
   }
  ],
  "name": "ft_ElTime",
  "return": {
   "name": "<cDiff>",
   "help": "character string representing time difference in hh:mm:ss format."
  }
 },
 {
  "label": "ft_EscCode( <cASCII> )  -> <cPrinterFormat>",
  "documentation": "Convert Lotus style escape codes",
  "arguments": [
   {
    "label": "<cASCII>",
    "documentation": "is the ASCII representation of the printer control codes in Lotus 123 format (e.g. \"\\027E\" for hb_BChar( 27 ) + \"E\") \"\\nnn\" will be converted to hb_BChar( nnn ) \"\\\\\" will be converted to \"\\\""
   }
  ],
  "name": "ft_EscCode",
  "return": {
   "name": "",
   "help": "The binary version of an ASCII coded printer setup string."
  }
 },
 {
  "label": "ft_FAppend( [ <nLines> ] ) -> NIL",
  "documentation": "Appends a line to the currently selected text file",
  "arguments": [
   {
    "label": "<nLines>",
    "documentation": "is the number of lines that should be appended to the end of the currently selected text file. If <nLines> is omitted, one record is appended."
   }
  ],
  "name": "ft_FAppend",
  "return": {
   "name": "",
   "help": "lSuccess.  If FALSE, check ^bft_FError()^n for the error code."
  }
 },
 {
  "label": "ft_FBof() -> lResult",
  "documentation": "Determine if attempt to skip past beginning of text file",
  "arguments": [],
  "name": "ft_FBof",
  "return": {
   "name": "",
   "help": ".T. if an attempt was made to skip past the first record of the currently selected text file, otherwise .F."
  }
 },
 {
  "label": "ft_FDay( [ <dDateToChk> ] ) -> dFirstDay",
  "documentation": "Return first day of the month",
  "arguments": [
   {
    "label": "<dDateToChk>",
    "documentation": "is a date within a month for which you want to find the first date of that month.  If not passed or is an incorrect type, defaults to current system date."
   }
  ],
  "name": "ft_FDay",
  "return": {
   "name": "",
   "help": "A Clipper date value representing the first date of the month."
  }
 },
 {
  "label": "ft_FDelete( [ <nLines> ] ) -> lSuccess",
  "documentation": "Deletes a line from the currently selected text file",
  "arguments": [],
  "name": "ft_FDelete",
  "return": {
   "name": "",
   "help": "TRUE if successful, otherwise check ^bft_FError()^n for error code."
  }
 },
 {
  "label": "ft_FEof() -> lResult",
  "documentation": "Determine if end of text file has been encountered",
  "arguments": [],
  "name": "ft_FEof",
  "return": {
   "name": "",
   "help": ".T. if an attempt was made to skip past the last record of the currently selected text file, otherwise .F."
  }
 },
 {
  "label": "ft_FError() -> nErrorNo",
  "documentation": "Return the error code for a text file operation",
  "arguments": [],
  "name": "ft_FError",
  "return": {
   "name": "",
   "help": "The DOS error code if one occurred.  See a reference on DOS error codes for an explanation of what the code means."
  }
 },
 {
  "label": "ft_FGoBot() -> NIL",
  "documentation": "Go to the last record in a text file",
  "arguments": [],
  "name": "ft_FGoBot",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_FGoto( nLine ) -> NIL",
  "documentation": "Move record pointer to specific record in a text file",
  "arguments": [
   {
    "label": "<nLine>",
    "documentation": "is the record number to go to."
   }
  ],
  "name": "ft_FGoto",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_FGoTop() -> NIL",
  "documentation": "Go to the first record in a text file",
  "arguments": [],
  "name": "ft_FGoTop",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Fill( <aSubArrayName>, <cMenuSelection>, <bFunction>, <lSelectable> ) -> NIL",
  "documentation": "Declare menu options for ft_Menu1()",
  "arguments": [
   {
    "label": "<aSubArrayName>",
    "documentation": "is a sub-array of <acOptions> in ft_Menu1() denoting the group in which to include the selection -- e.g., acOptions[ 1 ]"
   },
   {
    "label": "<cMenuSelection>",
    "documentation": "is the character string that will appear on the menu."
   },
   {
    "label": "<bFunction>",
    "documentation": "is the code block to be executed when that menu option is selected.  i.e. {|| MyFunction() } would execute the function called MyFunction().  {|| .F. } would exit the ft_Menu1() and return to the calling routine.  {|| .T. } would do nothing."
   },
   {
    "label": "<lSelectable>",
    "documentation": "is a logical variable that determines whether the corresponding menu option is selectable or not."
   }
  ],
  "name": "ft_Fill",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_FindITh( <cCheckFor>, <cCheckIn>, <nWhichOccurrence> ; [, <lIgnoreCase> ] ) -> <nStringPosition>",
  "documentation": "Find the \"ith\" occurrence of a substring within a string",
  "arguments": [
   {
    "label": "<cCheckFor>",
    "documentation": "is the string to search for."
   },
   {
    "label": "<cCheckIn>",
    "documentation": "is the string to search."
   },
   {
    "label": "<nWhichOccurrence>",
    "documentation": "is the number of the occurrence to find."
   },
   {
    "label": "<lIgnoreCase>",
    "documentation": "is a logical indicating if the search is to be case sensitive.  The default is no case sensitivity (.T.)."
   }
  ],
  "name": "ft_FindITh",
  "return": {
   "name": "",
   "help": "The position in the string cCheckIn of the ith occurrence of cCheckFor."
  }
 },
 {
  "label": "ft_FInsert( [ <nLines> ] ) -> lSuccess",
  "documentation": "Inserts a line in the currently selected text file",
  "arguments": [],
  "name": "ft_FInsert",
  "return": {
   "name": "",
   "help": "^blSuccess^n is TRUE if the insert succeeded, FALSE if not.  If false check the return value of ^bft_FError()^n for the reason."
  }
 },
 {
  "label": "ft_FLastRe() -> nLastRecordNum",
  "documentation": "Get the no. of records in the currently selected text file",
  "arguments": [],
  "name": "ft_FLastRe",
  "return": {
   "name": "",
   "help": "An integer containing the number of records in the text file in the currently selected text file workarea, or zero if no file is currently open in the workarea."
  }
 },
 {
  "label": "ft_FlopTst( <cDirectory|nDrive> ) -> nStatus",
  "documentation": "Test diskette drive status",
  "arguments": [
   {
    "label": "<nDrive>",
    "documentation": "is the diskette drive number, 0 = A:, 1 = B:"
   }
  ],
  "name": "ft_FlopTst",
  "return": {
   "name": "",
   "help": "-1 - Wrong Parameters 0 - Drive Loaded and ready to read or write 1 - Drive Door Open or Diskette inserted upside down 2 - Diskette is unformatted 3 - Write protected 4 - Undetermined"
  }
 },
 {
  "label": "ft_FReadLn() -> cLine",
  "documentation": "Read a line from the currently selected text file",
  "arguments": [],
  "name": "ft_FReadLn",
  "return": {
   "name": "",
   "help": "A string containing the current record in a text file."
  }
 },
 {
  "label": "ft_FRecNo() -> nRecNo",
  "documentation": "Return the current record number of a text file",
  "arguments": [],
  "name": "ft_FRecNo",
  "return": {
   "name": "",
   "help": "The current record number of a text file or 0 if no file is open."
  }
 },
 {
  "label": "ft_FSelect( [ <nNewArea> ] ) -> nPreviousArea",
  "documentation": "Select a text file workarea",
  "arguments": [],
  "name": "ft_FSelect",
  "return": {
   "name": "",
   "help": "The current selected text file area."
  }
 },
 {
  "label": "ft_FSkip( [ <nLines> ] ) -> nLinesSkipped",
  "documentation": "Move the record pointer to a new position in a text file",
  "arguments": [
   {
    "label": "<nLines>",
    "documentation": "is the number of lines to skip.  Defaults to 1 if not specified."
   }
  ],
  "name": "ft_FSkip",
  "return": {
   "name": "",
   "help": "The number of lines actually skipped.  If the file's EOF or BOF was encountered before ^b<nLines>^n could be skipped, the return value will be less than ^b<nLines>^n."
  }
 },
 {
  "label": "ft_FUse( [ <cFile> ] [, <nMode> ] ) -> nHandle | 0",
  "documentation": "Open or close a text file for use by the ft_F*() functions",
  "arguments": [],
  "name": "ft_FUse",
  "return": {
   "name": "",
   "help": "If ^b<cFile>^n is passed and the file is opened successfully, an integer containing the text file's workarea.  If the file cannot be opened, F_ERROR (-1) will be returned.  In this case, check the return value of ^bft_FError()^n for the cause of the error. If ft_FUse() is called without any arguments, it will close the text file in the current \"text area\" and return 0. If a read error occurs ^ft_FError()^n will contain the error code."
  }
 },
 {
  "label": "ft_FWriteLn( <cData>, [ <lInsert> ] ) -> lSuccess",
  "documentation": "Write a line to the currently selected text file",
  "arguments": [
   {
    "label": "<cData>",
    "documentation": "is a string of data to write to the file at the current record position."
   },
   {
    "label": "<lInsert>",
    "documentation": "is a logical indicating whether the contents of the current record are to be preserved, that is, if lInsert evaluates to .T., the a new record is inserted at the current position.  The current record then is pushed down to ft_FRecNo()+1. If lInsert is .F. or omitted, the current record is replaced by cData."
   }
  ],
  "name": "ft_FWriteLn",
  "return": {
   "name": "",
   "help": "TRUE if successful, otherwise check ^ft_FError()^n for error code."
  }
 },
 {
  "label": "ft_GCD( <nNumber1>, <nNumber2> ) -> nGCD",
  "documentation": "Calculate greatest common divisor of two numbers",
  "arguments": [
   {
    "label": "<nNumber1>",
    "documentation": "is the first number to find the GCD of."
   },
   {
    "label": "<nNumber2>",
    "documentation": "is the second number to find the GCD of."
   }
  ],
  "name": "ft_GCD",
  "return": {
   "name": "",
   "help": "The greatest common divisor of the 2 numbers, or 0 if either is 0."
  }
 },
 {
  "label": "ft_GetE( [ @<xReceiveVar> ] ) -> nNumStrings",
  "documentation": "Return the entire current environment",
  "arguments": [
   {
    "label": "<xReceiveVar>",
    "documentation": "is the variable to receive the environment data."
   },
   {
    "label": "<xReceiveVar>",
    "documentation": "can be a character type variable, in which case the function will place all environment strings in the variable separated by carriage return/line feeds (Chr( 13 ) + Chr( 10 ))."
   },
   {
    "label": "<xReceiveVar>",
    "documentation": "can be an array type, in which case the function will place each string in an array element.  The array MUST be declared with the proper number of elements prior to passing it to the function.  This can be done by calling ft_GetE() without parameters first to get the number of strings in the environment. Note that the argument MUST be passed by reference. Since arrays are by nature passed by reference, the \"@\" symbol is optional when passing an array. If no argument is passed, ft_GetE() merely returns the number of strings in the environment."
   }
  ],
  "name": "ft_GetE",
  "return": {
   "name": "",
   "help": "ft_GetE() returns the total number of strings found in the current program's environment."
  }
 },
 {
  "label": "ft_GetMode() -> nVMode",
  "documentation": "Get the video mode",
  "arguments": [],
  "name": "ft_GetMode",
  "return": {
   "name": "",
   "help": "The video mode, as a numeric."
  }
 },
 {
  "label": "ft_GetVCur( [<nPage>] ) -> <aCurInfo>",
  "documentation": "Return info about the cursor on a specified video page",
  "arguments": [
   {
    "label": "<nPage>",
    "documentation": "is the video page to get the cursor information for. Defaults to the current page, as returned by ft_GetVPg()."
   }
  ],
  "name": "ft_GetVCur",
  "return": {
   "name": "",
   "help": "A four-element array (<aCurInfo>), set up as follows: aCurInfo[ 1 ] = Top line of cursor aCurInfo[ 2 ] = Bottom line of cursor aCurInfo[ 3 ] = Character row aCurInfo[ 4 ] = Character column"
  }
 },
 {
  "label": "ft_GetVPg() -> <nPage>",
  "documentation": "Get the currently selected video page",
  "arguments": [],
  "name": "ft_GetVPg",
  "return": {
   "name": "",
   "help": "The video page, as a numeric."
  }
 },
 {
  "label": "ft_Hex2Dec( <cHexNum> ) -> nDecNum",
  "documentation": "Convert a hex number to decimal",
  "arguments": [
   {
    "label": "<cHexNum>",
    "documentation": "is a character string representing a hex number."
   }
  ],
  "name": "ft_Hex2Dec",
  "return": {
   "name": "",
   "help": "A decimal number."
  }
 },
 {
  "label": "ft_IAmIdle() -> lSuccess",
  "documentation": "Inform the operating system that the application is idle.",
  "arguments": [],
  "name": "ft_IAmIdle",
  "return": {
   "name": "",
   "help": ".T. if supported, .F. otherwise."
  }
 },
 {
  "label": "ft_Idle()",
  "documentation": "Generate an idle event to allow incremental garbage collection.",
  "arguments": [],
  "name": "ft_Idle",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_inp( <nPort> ) -> nValue",
  "documentation": "Retrieve a byte from a specified I/O port",
  "arguments": [
   {
    "label": "<nPort>",
    "documentation": "is the port from which to retrieve the byte.  If it is invalid in any way, the function will return zero."
   }
  ],
  "name": "ft_inp",
  "return": {
   "name": "",
   "help": "The byte retrieved."
  }
 },
 {
  "label": "ft_int86( <nInterruptNumber>, <aRegisterValues> ) -> lResult",
  "documentation": "Execute a software interrupt",
  "arguments": [
   {
    "label": "<nInterruptNumber>",
    "documentation": "is the interrupt to execute."
   },
   {
    "label": "<aRegisterValues>",
    "documentation": "is an array that contains values to be loaded into the various CPU registers.  The correspondence between registers and array elements is as follows: aElement[ 1 ]  ==  AX register aElement[ 2 ]  ==  BX register aElement[ 3 ]  ==  CX register aElement[ 4 ]  ==  DX register aElement[ 5 ]  ==  SI register aElement[ 6 ]  ==  DI register aElement[ 7 ]  ==  BP register aElement[ 8 ]  ==  DS register aElement[ 9 ]  ==  ES register aElement[ 10 ] ==  Flags register"
   }
  ],
  "name": "ft_int86",
  "return": {
   "name": "",
   "help": ".T. if all parameters valid and the function was able to execute the desired interrupt. .F. if invalid parameters passed.  If you call this function in protected mode, .F. may also be returned if an allocation of low DOS memory fails. n addition, the array elements will contain whatever values were in he CPU registers immediately after the interrupt was executed.  If ither of the string parameters were altered by the interrupt, these hanges will be reflected as well."
  }
 },
 {
  "label": "ft_InvClr( [ <cDsrdColor> ] ) -> cColor",
  "documentation": "Get the inverse of a color",
  "arguments": [
   {
    "label": "<cDsrdColor>",
    "documentation": "is the color to get the inverse of.  Defaults to current color."
   }
  ],
  "name": "ft_InvClr",
  "return": {
   "name": "",
   "help": "The inverse of the passed color."
  }
 },
 {
  "label": "ft_IsBit( <cByte>, <nBitPos> ) -> lResult",
  "documentation": "Test the status of an individual bit",
  "arguments": [
   {
    "label": "<cByte>",
    "documentation": "is a character from hb_BChar( 0 ) to hb_BChar( 255 )."
   },
   {
    "label": "<nBitPos>",
    "documentation": "is a number from 0 to 7 conforming to standard right-to-left bit-numbering convention and representing the position of the bit within the byte."
   }
  ],
  "name": "ft_IsBit",
  "return": {
   "name": "",
   "help": ".T. if designated bit is set (1), .F. if not set (0), NIL if invalid parameters."
  }
 },
 {
  "label": "ft_IsBitOn( <nNumber>, <nBit> ) -> lResult",
  "documentation": "Determine the state of individual bits in a number",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "is an integer for which a bit state needs to be checked."
   },
   {
    "label": "<nBit>",
    "documentation": "is a number from 0 to 15 that indicates which bit to test."
   }
  ],
  "name": "ft_IsBitOn",
  "return": {
   "name": "",
   "help": ".T. if the specified bit was on., .F. if off."
  }
 },
 {
  "label": "ft_IsPrint( [ <cDevice> ] ) -> lResult",
  "documentation": "Check printer status",
  "arguments": [
   {
    "label": "<cDevice>",
    "documentation": "is optional and is the device to test (LPT2, COM1, etc.). If omitted, the function will default to the PRN device."
   }
  ],
  "name": "ft_IsPrint",
  "return": {
   "name": "",
   "help": ".T.  if device is ready for output. .F.  if one of the following conditions occurs: 1)  The device is not ready. 2)  The device does not exist. 3)  DOS couldn't open the device for some reason (such as no file handles available)."
  }
 },
 {
  "label": "ft_IsShare() -> nRetCode",
  "documentation": "Determine if DOS \"Share\" is installed",
  "arguments": [],
  "name": "ft_IsShare",
  "return": {
   "name": "",
   "help": "nRetcode will be set as follows on exit: 0 if SHARE not loaded but ok to load 1 if SHARE not loaded and not ok to load 255 if SHARE loaded"
  }
 },
 {
  "label": "ft_LastKey( <nKey> ) -> NIL",
  "documentation": "Force LastKey() to return a programmer-defined value.",
  "arguments": [
   {
    "label": "<nKey>",
    "documentation": "is the Inkey() value of the desired key."
   }
  ],
  "name": "ft_LastKey",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_LastKey( <nKey> ) -> NIL",
  "documentation": "Force LastKey() to return a programmer-defined value.",
  "arguments": [
   {
    "label": "<nKey>",
    "documentation": "is the Inkey() value of the desired key."
   }
  ],
  "name": "ft_LastKey",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_LDay( [ <dDateToChk> ] ) -> dLastDay",
  "documentation": "Return last day of the month",
  "arguments": [
   {
    "label": "<dDateToChk>",
    "documentation": "is a date within a month for which you want to find the last date of that month.  If not passed or is an incorrect type, defaults to current system date."
   }
  ],
  "name": "ft_LDay",
  "return": {
   "name": "",
   "help": "A Clipper date value representing the last date of the month."
  }
 },
 {
  "label": "ft_Linked( <cString> ) -> lResult",
  "documentation": "Determine if a function was linked in",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "is a character string containing one or more function calls"
   }
  ],
  "name": "ft_Linked",
  "return": {
   "name": "",
   "help": ".T. if all functions within the string are currently linked into the application, .F. if one or more aren't.  See below for a definition of \"function.\""
  }
 },
 {
  "label": "ft_MAdd( [ <dGivenDate> ], [ <nAddMonths> ], [ <lMakeEOM> ] ) -> dDate",
  "documentation": "Add or subtract months to/from a date",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any date format. Defaults to current system date if not supplied."
   },
   {
    "label": "<nAddMonths>",
    "documentation": "is the number of months to be added or subtracted. Defaults to 0 if not supplied."
   },
   {
    "label": "<lMakeEOM>",
    "documentation": "is a logical variable indicating whether or not to force the returned date to the last date of the month.  It only affects the returned date if <dGivenDate> is an end-of-month date."
   }
  ],
  "name": "ft_MAdd",
  "return": {
   "name": "",
   "help": "A date."
  }
 },
 {
  "label": "ft_MButPrs( <nButton> [, @nButPrs [, @nX [, @nY] ] ] ) -> nButStatus",
  "documentation": "Retrieve button press status",
  "arguments": [
   {
    "label": "<nButton>",
    "documentation": "is the mouse button number: 0 - Left   Button 1 - Right  Button 2 - Middle Button [if applicable]"
   },
   {
    "label": "<nButPrs>",
    "documentation": "is the number of times the specified button was pressed since the last call to this routine. PASSED BY REFERENCE."
   },
   {
    "label": "<nX>",
    "documentation": "is the X position of the cursor when the last press occurred. PASSED BY REFERENCE."
   },
   {
    "label": "<nY>",
    "documentation": "is the Y position of the cursor when the last press occurred. PASSED BY REFERENCE."
   }
  ],
  "name": "ft_MButPrs",
  "return": {
   "name": "",
   "help": "An integer representing the button status: 0 - no buttons pressed 1 - left button pressed 2 - right button pressed 3 - left and right pressed 4 - middle pressed 5 - left and middle pressed 6 - middle and right buttons pressed 7 - all 3 buttons pressed"
  }
 },
 {
  "label": "ft_MButRel( nButton [, @nButRel [, @nX [, @nY] ] ]) -> nBStat",
  "documentation": "Get mouse button release information",
  "arguments": [
   {
    "label": "<nButton>",
    "documentation": "is the mouse button number 0 - Left   Button 1 - Right  Button 2 - Middle Button [if applicable]"
   },
   {
    "label": "<nButRel>",
    "documentation": "is the number of times the specified button was released since the last call to this routine. PASSED BY REFERENCE."
   },
   {
    "label": "<nX>",
    "documentation": "is the X position of the cursor when the last release occurred. PASSED BY REFERENCE."
   },
   {
    "label": "<nY>",
    "documentation": "is the Y position of the cursor when the last release occurred. PASSED BY REFERENCE."
   }
  ],
  "name": "ft_MButRel",
  "return": {
   "name": "<nBStat>",
   "help": "- an integer representing button release status 0 - None 1 - Left 2 - Right 3 - Middle"
  }
 },
 {
  "label": "ft_MCOnOff( <nTop>, <nLeft>, <nBottom>, <nRight> )",
  "documentation": "Turn mouse cursur off if in specified region",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": ", <nLeft> <nBottom> <nRight> are the four corners of the screen region in row and column coordinates."
   }
  ],
  "name": "ft_MCOnOff",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_MCursor( [ <lState> ] ) -> lCursorState",
  "documentation": "Set the mouse cursor",
  "arguments": [
   {
    "label": "<lState>",
    "documentation": "is a logical indicating whether to set the mouse cursor on. .T. - set mouse cursor on .F. - set mouse cursor off If omitted, no change is made to cursor state"
   }
  ],
  "name": "ft_MCursor",
  "return": {
   "name": "",
   "help": "A logical indicating the previous mouse cursor state."
  }
 },
 {
  "label": "ft_MDblClk( [ <nClick> [, <nButton> [, <nInterval> [, <nRow> [, <nCol>; [, <nTime> ] ] ] ] ] ] ) -> lIsDoubleClk",
  "documentation": "Return true if a double click was detected",
  "arguments": [
   {
    "label": "<nClick>",
    "documentation": "is a numeric value.  If it is zero ft_MDblClk() will not check for the first press but rather will simply wait the specified period for a single press. This is useful if this routine is called from one which in turn responded to a button press. If it is not present or not equal to 0, then ft_MDblClk() will wait for two presses of the specified button."
   },
   {
    "label": "<nButton>",
    "documentation": "is the mouse button number 0 - Left   Button 1 - Right  Button 2 - Middle Button [if applicable]"
   },
   {
    "label": "<nInterval>",
    "documentation": "is the interval to wait for the first click if requested and the time to wait for the second. If not present then defaults to 0.5 second."
   },
   {
    "label": "<nRow>",
    "documentation": "is the row number for the mouse cursor location for a double click to be valid. If not present then the current position is taken as the valid location."
   },
   {
    "label": "<nCol>",
    "documentation": "is the column number for the mouse cursor location for a double click to be valid. If not present, then the current position is taken as the valid location."
   },
   {
    "label": "<nTime>",
    "documentation": "is an optional start time for the waiting period for the first click (of either one or two requested). If not given then the time is set at entry into this routine. This is useful when this routine is called from another routine which was called in response to a mouse click but needs to know if a double click has occurred"
   }
  ],
  "name": "ft_MDblClk",
  "return": {
   "name": "",
   "help": ".T. if a double click was detected."
  }
 },
 {
  "label": "ft_MDefCrs( <nCrsType>, <nScrMask>, <nCrsMask> ) -> NIL",
  "documentation": "Define the mouse cursor",
  "arguments": [
   {
    "label": "<nCrsType>",
    "documentation": "is the cursor type. A value of 0 indicates the software cursor (the default) and a value of 1 indicates the hardware cursor."
   },
   {
    "label": "<nScrMask>",
    "documentation": "is the screen mask for the software cursor or the first scan line of the hardware cursor. See the description for more information."
   },
   {
    "label": "<nCrsMask>",
    "documentation": "is the cursor mask for the software cursor of the last scan line of the hardware cursor. See the description for more information."
   }
  ],
  "name": "ft_MDefCrs",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Menu1( <acBarNames>, <acOptions>, <acAction>, <acColors> [, <nTopRow> ], [ <lShadow> ] ) -> NIL",
  "documentation": "Pulldown menu system",
  "arguments": [
   {
    "label": "<acBarNames>",
    "documentation": "is a character array containing the names to appear on the menu bar."
   },
   {
    "label": "<acOptions>",
    "documentation": "is a multi-dimensional array with one element for each selection to appear on the pulldown menus."
   },
   {
    "label": "<acColors>",
    "documentation": "is an array containing the colors for the menu groups."
   },
   {
    "label": "<nTopRow>",
    "documentation": "is a numeric value that determines the row for the menu bar.  If omitted, it defaults to 0."
   },
   {
    "label": "<lShadow>",
    "documentation": "is a logical variable.  If true (.T.) or omitted, it uses ft_Shadow() to add a transparent shadow to the each pulldown menu.  If false (.F.), the menu is drawn without the shadow. All arguments except nTopRow and lShadow are required."
   }
  ],
  "name": "ft_Menu1",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Menu2( <aMenuarray> [, <cColors> ] ) -> NIL",
  "documentation": "Vertical lightbar menu",
  "arguments": [
   {
    "label": "<aMenuarray>",
    "documentation": "is an array of menu options, messages, and action blocks. Each element in this array is a nested array with the structure: element[ x, 1 ] = menu option element[ x, 2 ] = message to be displayed when option is highlighted element[ x, 3 ] = code block to be executed when option is selected"
   },
   {
    "label": "<cColors>",
    "documentation": "is a string containing colors for the prompts, in the same format as that returned by Set( _SET_COLOR ).  If not supplied, colors default to the current color setting."
   }
  ],
  "name": "ft_Menu2",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Metaph( <cName> [, <nSize> ] ) -> cMetaPhone",
  "documentation": "Convert a character string to MetaPhone format",
  "arguments": [
   {
    "label": "<cName>",
    "documentation": "is the character string to convert"
   },
   {
    "label": "<nSize>",
    "documentation": "is the length of the character string to be returned. If not specified the default length is 4 bytes."
   }
  ],
  "name": "ft_Metaph",
  "return": {
   "name": "",
   "help": "A phonetically spelled character string"
  }
 },
 {
  "label": "ft_MGetPage() -> <nPage>",
  "documentation": "Get the display page for the mouse pointer",
  "arguments": [],
  "name": "ft_MGetPage",
  "return": {
   "name": "<nPage>",
   "help": "is the display page on which the mouse is currently being displayed"
  }
 },
 {
  "label": "ft_MGetPos( @<nX>, @<nY> ) -> nButtonStatus",
  "documentation": "Get mouse cursor position and button status",
  "arguments": [
   {
    "label": "<nX>",
    "documentation": "is a variable that will receive the mouse X position in virtual screen coordinates.  It must be passed by reference."
   },
   {
    "label": "<nY>",
    "documentation": "is a variable that will receive the mouse Y position in virtual screen coordinates.  It must be passed by reference."
   }
  ],
  "name": "ft_MGetPos",
  "return": {
   "name": "",
   "help": "an integer representing button status - 0 for no button pressed - 1 for left pressed - 2 for right pressed - 3 for left and right pressed - 4 for middle pressed - 5 for left and middle pressed - 6 for right and middle pressed - 7 for all three buttons pressed"
  }
 },
 {
  "label": "ft_MGetPos( @<nX>, @<nY> ) -> nButtonStatus",
  "documentation": "Get mouse cursor position (text coord.) and button status",
  "arguments": [
   {
    "label": "<nX>",
    "documentation": "is a variable that will receive the mouse X position in text screen coordinates.  It must be passed by reference."
   },
   {
    "label": "<nY>",
    "documentation": "is a variable that will receive the mouse Y position in text screen coordinates.  It must be passed by reference."
   }
  ],
  "name": "ft_MGetPos",
  "return": {
   "name": "",
   "help": "an integer representing button status - 0 for no button pressed - 1 for left pressed - 2 for right pressed - 3 for left and right pressed - 4 for middle pressed - 5 for left and middle pressed - 6 for right and middle pressed - 7 for all three buttons pressed"
  }
 },
 {
  "label": "ft_MGetSens( <@nHoriz>, <@nVert>, <@nDouble> ) -> NIL",
  "documentation": "Get the mouse sensitivity parameters",
  "arguments": [
   {
    "label": "<nHoriz>",
    "documentation": "is the percentage of maximum horizontal sensitivity. PASSED BY REFERENCE."
   },
   {
    "label": "<nVert>",
    "documentation": "is the percentage of maximum vertical sensitivity. PASSED BY REFERENCE."
   },
   {
    "label": "<nDouble>",
    "documentation": "is the percentage of maximum sensitivity for doubling the mouse cursor's speed on the screen. PASSED BY REFERENCE."
   }
  ],
  "name": "ft_MGetSens",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_MGetX() -> nRowPos",
  "documentation": "Get mouse cursor row position",
  "arguments": [],
  "name": "ft_MGetX",
  "return": {
   "name": "<nRowPos>",
   "help": "which is the row position of mouse in virtual screen coordinates."
  }
 },
 {
  "label": "ft_MGetY() -> nColPos",
  "documentation": "Get mouse cursor column position",
  "arguments": [],
  "name": "ft_MGetY",
  "return": {
   "name": "<nColPos>",
   "help": "Column position of mouse in virtual screen coordinates"
  }
 },
 {
  "label": "ft_MHideCrs() -> NIL",
  "documentation": "Decrement internal mouse cursor flag and hide mouse cursor",
  "arguments": [],
  "name": "ft_MHideCrs",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Mil2Civ( <cCIVTIME> ) -> dMILTIME",
  "documentation": "Convert time in military format to civilian format.",
  "arguments": [
   {
    "label": "<cMILTIME>",
    "documentation": "character string of form hhmm, where 0<=hh<24."
   }
  ],
  "name": "ft_Mil2Civ",
  "return": {
   "name": "<cCIVTIME>",
   "help": "character string of form hh:mm (am,pm,n or m), where 0<hh<12."
  }
 },
 {
  "label": "ft_Mil2Min( <cMILTIME> ) -> nMINUTE",
  "documentation": "Convert time in military format to number of minute of day.",
  "arguments": [
   {
    "label": "<cMILTIME>",
    "documentation": "character string of form hhmm, where 0<=hh<24."
   }
  ],
  "name": "ft_Mil2Min",
  "return": {
   "name": "<nMINOFDAY>",
   "help": "numeric value representing minute of day."
  }
 },
 {
  "label": "ft_Min2Dhm( <nMinutes> ) -> aDHM_",
  "documentation": "Convert numeric minutes to days, hours and minutes.",
  "arguments": [
   {
    "label": "<nMinutes>",
    "documentation": "the number of minutes."
   }
  ],
  "name": "ft_Min2Dhm",
  "return": {
   "name": "<aDHM_>",
   "help": " where: aDHM_[ 1 ] = cDAYS, aDHM_[ 2 ] = cHours, aDHM_[ 3 ] = cMinutes"
  }
 },
 {
  "label": "ft_Min2Mil( <nMINUTE> ) -> cMILTIME",
  "documentation": "Convert minute of day to military format time.",
  "arguments": [
   {
    "label": "<nMINUTE>",
    "documentation": "numeric integer representing minute of day."
   }
  ],
  "name": "ft_Min2Mil",
  "return": {
   "name": "<cMILTIME>",
   "help": "character string of form hhmm, where 0<=hh<24."
  }
 },
 {
  "label": "ft_MInit() -> lMouseStatus",
  "documentation": "Initialize the mouse driver, vars and return status of mouse",
  "arguments": [],
  "name": "ft_MInit",
  "return": {
   "name": "",
   "help": "An logical representing the mouse status (.F. == mouse not installed)"
  }
 },
 {
  "label": "ft_MInRegion( <nT>, <nL>, <nB>, <nR> ) -> lInRegion",
  "documentation": "Test if the mouse cursor is in the passed region",
  "arguments": [
   {
    "label": "<nT>",
    "documentation": ", <nL> <nB> <nR> are the four corners of the screen region."
   }
  ],
  "name": "ft_MInRegion",
  "return": {
   "name": "",
   "help": ".T. if mouse is in specified region."
  }
 },
 {
  "label": "ft_MkDir(  <cDirName> ) -> nResult",
  "documentation": "Create a subdirectory",
  "arguments": [
   {
    "label": "<cDirName>",
    "documentation": "is the name of the directory to create."
   }
  ],
  "name": "ft_MkDir",
  "return": {
   "name": "",
   "help": "0   if successful 3   if Path Not Found 5   if Access Denied or directory already exists 99  if invalid parameters passed"
  }
 },
 {
  "label": "ft_MMickeys( @<nX>, @<nY> ) -> NIL",
  "documentation": "Get mickeys",
  "arguments": [
   {
    "label": "<nX>",
    "documentation": "is a variable that will receive the vertical mickey count."
   },
   {
    "label": "<nY>",
    "documentation": "is a variable that will receive the horizontal mickey count."
   }
  ],
  "name": "ft_MMickeys",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Month( [ <dGivenDate> ], [nMonthNum] ) -> aDateInfo",
  "documentation": "Return Calendar or Fiscal Month Data",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any date format.  Defaults to current system date if not supplied."
   },
   {
    "label": "<nMonthNum>",
    "documentation": "is a number from 1 to 12 signifying a month. Defaults to current month if not supplied."
   }
  ],
  "name": "ft_Month",
  "return": {
   "name": "",
   "help": "A three element array containing the following data: aDateInfo[ 1 ] - The year and month as a character string \"YYYYMM\" aDateInfo[ 2 ] - The beginning date of the month aDateInfo[ 3 ] - The ending date of the month"
  }
 },
 {
  "label": "ft_MReset() -> nMouseStatus",
  "documentation": "Reset mouse driver and return status of mouse",
  "arguments": [],
  "name": "ft_MReset",
  "return": {
   "name": "",
   "help": "An integer representing the mouse status (0 == mouse not installed)"
  }
 },
 {
  "label": "ft_MSetPage( <@nPage> ) -> NIL",
  "documentation": "Set the display page for the mouse pointer",
  "arguments": [
   {
    "label": "<nPage>",
    "documentation": "is the desired display page."
   }
  ],
  "name": "ft_MSetPage",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_MSetPos( <nX>, <nY> ) -> NIL",
  "documentation": "Position the mouse cursor using virtual screen coordinates",
  "arguments": [
   {
    "label": "<nX>",
    "documentation": "is the desired mouse row."
   },
   {
    "label": "<nY>",
    "documentation": "is the desired mouse column."
   }
  ],
  "name": "ft_MSetPos",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_MSetPos( <nX>, <nY> ) -> NIL",
  "documentation": "Position the mouse cursor using text screen coordinates",
  "arguments": [
   {
    "label": "<nX>",
    "documentation": "is the desired mouse row."
   },
   {
    "label": "<nY>",
    "documentation": "is the desired mouse column."
   }
  ],
  "name": "ft_MSetPos",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_MSetSens( <nHoriz>, <nVert>, <nDouble> ) -> NIL",
  "documentation": "Set the mouse sensitivity parameters",
  "arguments": [
   {
    "label": "<nHoriz>",
    "documentation": "is the sensitivity of the mouse on the horizontal axis. This value is the integer percentage of highest sensitivity and thus has a range of 1 to 100. The default value is 50 and at this setting about 3.2 inches of mouse movement will move the mouse cursor across the screen. If NIL, the current value is used."
   },
   {
    "label": "<nVert>",
    "documentation": "is the relative sensitivity of the mouse on the vertical axis. The value is an integer percentage of the highest sensitivity and thus has a range of 1 to 100. The default value is 50 and requires about 2 inches of mouse movement will move from top to bottom of the screen.If NIL, the current value is used."
   },
   {
    "label": "<nDouble>",
    "documentation": "is the relative sensitivity of the mouse to doubling the ratio of cursor movement to mouse movement. The default value is 50. If NIL, the current value is used."
   }
  ],
  "name": "ft_MSetSens",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_MShowCrs() -> NIL",
  "documentation": "Increment internal cursor flag and display mouse cursor",
  "arguments": [],
  "name": "ft_MShowCrs",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_MVersion( <@nMinor>, <@nType>, <@nIRQ>  ) -> <nMajor>",
  "documentation": "Get the mouse driver version",
  "arguments": [
   {
    "label": "<nMinor>",
    "documentation": "is the Minor version number. PASSED BY REFERENCE."
   },
   {
    "label": "<nType>",
    "documentation": "is the Mouse type. PASSED BY REFERENCE. 1 = Bus Mouse 2 = Serial Mouse 3 = InPort Mouse 4 = PS/2 Mouse 5 = HP Mouse"
   },
   {
    "label": "<nIRQ>",
    "documentation": "is the IRQ number used for the mouse. PASSED BY REFERENCE. 0 = PS/2 2,3,4,5 or 7 = IRQ number"
   }
  ],
  "name": "ft_MVersion",
  "return": {
   "name": "<nMajor>",
   "help": "which is the major version number of the mouse driver."
  }
 },
 {
  "label": "ft_MXLimit( <nX1>, <nX2> ) -> NIL",
  "documentation": "Set vertical bounds of mouse using virtual screen coord.",
  "arguments": [
   {
    "label": "<nX1>",
    "documentation": "is the top row limit."
   },
   {
    "label": "<nX2>",
    "documentation": "is the bottom row limit."
   }
  ],
  "name": "ft_MXLimit",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_MYLimit( <nY1>, <nY2> ) -> NIL",
  "documentation": "Set horiz. bounds of mouse using virtual screen coordinates",
  "arguments": [
   {
    "label": "<nY1>",
    "documentation": "is the left column limit."
   },
   {
    "label": "<nY2>",
    "documentation": "is the right column limit."
   }
  ],
  "name": "ft_MYLimit",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_NetPV( <nInitialInvestment>, <nInterestRate>, <aCashFlow> ; [, <nNoOfCashFlows> ] ) -> nNetPV",
  "documentation": "Calculate net present value",
  "arguments": [
   {
    "label": "<nInitialInvestment>",
    "documentation": "is the amount of cash invested for purposes of generating the cash flows."
   },
   {
    "label": "<nInterestRate>",
    "documentation": "is the annual interest rate used to discount expected cash flows (10.5% = 10.5, not .105)."
   },
   {
    "label": "<aCashFlow>",
    "documentation": "is an array of the expected cash receipts each year."
   },
   {
    "label": "<nNoOfCashFlows>",
    "documentation": "is the number of years cash flows are expected (optional, Len( aCashFlow ) )."
   }
  ],
  "name": "ft_NetPV",
  "return": {
   "name": "",
   "help": "The difference between the initial investment and the discounted cash flow in dollars."
  }
 },
 {
  "label": "ft_NoOccur( <cCheckFor>, <cCheckIn> ; [, <lIgnoreCase> ] ) -> <nOccurrences>",
  "documentation": "Find the number of times one string occurs in another",
  "arguments": [
   {
    "label": "<cCheckFor>",
    "documentation": "is the string to search for"
   },
   {
    "label": "<cCheckIn>",
    "documentation": "is the string to search"
   },
   {
    "label": "<lIgnoreCase>",
    "documentation": "is a boolean variable to force case sensitivity (optional, defaults to .T.)."
   }
  ],
  "name": "ft_NoOccur",
  "return": {
   "name": "",
   "help": "The number of times <cCheckFor> appears in <cCheckIn>"
  }
 },
 {
  "label": "ft_NToW( <nNumber> ) -> cWords",
  "documentation": "Translate numeric value to words",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "An integer to translate"
   }
  ],
  "name": "ft_NToW",
  "return": {
   "name": "",
   "help": "A text string representing <nNumber>"
  }
 },
 {
  "label": "ft_NumLock( [ <lNewSetting> ] ) -> lCurrentSetting",
  "documentation": "Return status of NumLock key",
  "arguments": [
   {
    "label": "<lNewSetting>",
    "documentation": "is optional and if supplied is the new setting for the CapLock key.  Specify .T. to turn CapLock on, or .F. to turn it off."
   }
  ],
  "name": "ft_NumLock",
  "return": {
   "name": "",
   "help": "lValue is .T. if NumLock is set, .F. if it isn't set.  The value returned represents the setting in effect prior to any changes that might by made by <lNewSetting>."
  }
 },
 {
  "label": "ft_NWLStat() -> nStatNum",
  "documentation": "Return the current Novell NetWare logical station number",
  "arguments": [],
  "name": "ft_NWLStat",
  "return": {
   "name": "",
   "help": "A numeric corresponding to the current logical station number assigned by NetWare."
  }
 },
 {
  "label": "ft_NWSemClose( <nHandle> )  -> nRc",
  "documentation": "Close a NetWare semaphore",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "is the semaphore handle, returned from a previous call to ft_NWSemOpen()."
   }
  ],
  "name": "ft_NWSemClose",
  "return": {
   "name": "",
   "help": "nRc, a numeric, as follows: 0 - success 255 - invalid semaphore handle"
  }
 },
 {
  "label": "ft_NWSemEx( <nHandle>, <@nValue>, <@nOpenCnt> ) -> nRc",
  "documentation": "Examine a NetWare semaphore's value and open count",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "is the semaphore handle, returned from a previous call to ft_NWSemOpen()."
   },
   {
    "label": "<@nValue>",
    "documentation": "will get the current semaphore value.  THIS NUMERIC ARGUMENT MUST BE PASSED BY REFERENCE!"
   },
   {
    "label": "<@nOpenCnt>",
    "documentation": "will get the current number of workstations that have opened the semaphore.  THIS NUMERIC ARGUMENT MUST BE PASSED BY REFERENCE!"
   }
  ],
  "name": "ft_NWSemEx",
  "return": {
   "name": "",
   "help": "nRc, a numeric, as follows: 0 - success 255 - invalid semaphore handle In addition, nValue will be set to the semaphore's current value, and nOpenCnt will be set to the number of stations that have opened the semaphore."
  }
 },
 {
  "label": "ft_NWSemLock( <cSemaphore>, <@nHandle> ) -> lRet",
  "documentation": "Perform a semaphore \"lock\"",
  "arguments": [
   {
    "label": "<cSemaphore>",
    "documentation": "is the name of a semaphore you want to \"lock.\""
   },
   {
    "label": "<nHandle>",
    "documentation": "is the semaphore's handle, if you get the lock. THIS MUST BE PASSED BY REFERENCE!"
   }
  ],
  "name": "ft_NWSemLock",
  "return": {
   "name": "",
   "help": "lRet == .T. if you get the lock, .T. if you don't. If the lock succeeds, <nHandle> will contain the semaphore handle.  If it fails, the value of <nHandle> is undefined."
  }
 },
 {
  "label": "ft_NWSemOpen( <cName>, <nInitVal>, <@nHandle>, <@nOpenCnt> ) -> nRc",
  "documentation": "Open or create a NetWare semaphore",
  "arguments": [
   {
    "label": "<cName>",
    "documentation": "is the semaphore name, maximum length is 127 characters."
   },
   {
    "label": "<nInitVal>",
    "documentation": "is the initial value for the semaphore.  It must start as a positive number, to a maximum of 127."
   },
   {
    "label": "<@nHandle>",
    "documentation": "is the semaphore handle.  THIS MUST BE PASSED BY REFERENCE!  On exit, <nHandle> will contain a numeric value that refers to the opened semaphore.  You will need it to pass to other semaphore functions!  PASS IT BY REFERENCE!"
   },
   {
    "label": "<@nOpenCnt>",
    "documentation": "is the number of stations that have opened the semaphore.  THIS MUST BE PASSED BY REFERENCE! On exit, <nOpenCnt> will contain a numeric value."
   }
  ],
  "name": "ft_NWSemOpen",
  "return": {
   "name": "",
   "help": "nRc, a numeric result code, as follows: 0 - success 254 - Invalid semaphore name length 255 - Invalid semaphore value <nHandle> will contain the semaphore handle, and <nOpenCnt> will contain the number of stations that have opened the semaphore."
  }
 },
 {
  "label": "ft_NWSemSig( nHandle ) -> nRc",
  "documentation": "Signal a NetWare semaphore (increment)",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "is the semaphore handle, returned from a previous call to ft_NWSemOpen()."
   }
  ],
  "name": "ft_NWSemSig",
  "return": {
   "name": "",
   "help": "nRc, a numeric, as follows 0 - success 1 - semaphore overflow ( value > 127 ) 255 - invalid semaphore handle"
  }
 },
 {
  "label": "ft_NWSemUnlock( <nHandle> ) -> lRet",
  "documentation": "\"Unlock\" a semaphore locked by ft_NWSemLock()",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "is the semaphore handle returned from ft_NWSemLock()"
   }
  ],
  "name": "ft_NWSemUnlock",
  "return": {
   "name": "",
   "help": "lRet == .T. if you successfully unlock the semaphore, .F. if you don't.  If this call fails, it could be that you're passing an invalid semaphore handle."
  }
 },
 {
  "label": "ft_NWSemWait( <nHandle> [, nTimeout ] ) -> nRc",
  "documentation": "Wait on a NetWare semaphore (decrement)",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "is the semaphore handle, returned from a previous call to ft_NWSemOpen()."
   },
   {
    "label": "<nTimeOut>",
    "documentation": "is an optional parameter telling how long you wish to wait on this semaphore.  This is a numeric indicating the number of clock ticks (approx 1/18 sec ) to wait.  A zero (the default) means \"don't wait.\""
   }
  ],
  "name": "ft_NWSemWait",
  "return": {
   "name": "",
   "help": "nRc, a numeric, as follows: 0 - success 254 - timeout failure 255 - invalid semaphore handle"
  }
 },
 {
  "label": "ft_NWUID( [ <nConnection> ] ) -> cUid",
  "documentation": "Return the current Novell NetWare User ID",
  "arguments": [
   {
    "label": "<nConnection>",
    "documentation": "is a connection number, or logical station number, to find a userid for.  Under NetWare 286, this number can be from 1 to 100.  Under NetWare 386, 1-250.  If not supplied, ft_NWUID() defaults to the current connection (i.e., the connection running the application)."
   }
  ],
  "name": "ft_NWUID",
  "return": {
   "name": "",
   "help": "A string containing the userid, or \"login name.\" The maximum length of this string, as defined by current versions of Novell NetWare, is 48 characters."
  }
 },
 {
  "label": "ft_OnTick( bCode, nInterval )",
  "documentation": "Evaluate a designated code block at a designated interval.",
  "arguments": [
   {
    "label": "<bCode>",
    "documentation": "is the code block to evaluate."
   },
   {
    "label": "<nInterval>",
    "documentation": "is the number of clock ticks to wait between evaluations of the code block."
   }
  ],
  "name": "ft_OnTick",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Origin() -> cString",
  "documentation": "Report the drive, path and filename of the current program",
  "arguments": [],
  "name": "ft_Origin",
  "return": {
   "name": "",
   "help": "A string containing the full drive/directory/filename of the currently executing file."
  }
 },
 {
  "label": "ft_outp( <nPort>, <nValue> ) -> lResult",
  "documentation": "Write a byte to a specified I/O port",
  "arguments": [
   {
    "label": "<nPort>",
    "documentation": "is the port from which to retrieve the byte."
   },
   {
    "label": "<nValue>",
    "documentation": "is the value between 0 and 255 to write to the port."
   }
  ],
  "name": "ft_outp",
  "return": {
   "name": "",
   "help": ".T. if all parameters were valid and the byte was written to the port. .F. if invalid parameters were passed."
  }
 },
 {
  "label": "ft_PChr( <cString> )  ->  <cPrinterFormat>",
  "documentation": "Convert printer control codes",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "is the representation of the printer control codes in text, numeric, hexadecimal, Epson command format, or any combination separated by commas."
   }
  ],
  "name": "ft_PChr",
  "return": {
   "name": "",
   "help": "A character string of printer control codes."
  }
 },
 {
  "label": "ft_Peek( <nSegment>, <nOffset> ) -> nValue",
  "documentation": "Retrieve a byte from a specified memory location.",
  "arguments": [
   {
    "label": "<nSegment>",
    "documentation": "is the segment of the desired memory address."
   },
   {
    "label": "<nOffset>",
    "documentation": "is the offset of the desired memory address."
   }
  ],
  "name": "ft_Peek",
  "return": {
   "name": "<nValue>",
   "help": "will be a value from 0 to 255 if all parameters were valid and the function was able to retrieve the desired byte. <nValue> will be -1 if invalid parameters were passed."
  }
 },
 {
  "label": "ft_Pegs() -> NIL",
  "documentation": "PEGS GAME (all work and no play...)",
  "arguments": [],
  "name": "ft_Pegs",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Pending( <cMsg>, [ <nRow> ], [ <nCol> ], ; [ <nWait> ], [ <cColor> ] ) -> NIL",
  "documentation": "Display same-line pending messages after a wait.",
  "arguments": [
   {
    "label": "<cMsg>",
    "documentation": "is the message string to display."
   },
   {
    "label": "<nRow>",
    "documentation": "is an optional screen row for message display, default row 24."
   },
   {
    "label": "<nCol>",
    "documentation": "is an optional screen col for message display, default col 0."
   },
   {
    "label": "<nWait>",
    "documentation": "is an optional wait (sec) between messages, default 5 sec."
   },
   {
    "label": "<cColor>",
    "documentation": "is an optional color string for displayed messages, default is white text over red background."
   }
  ],
  "name": "ft_Pending",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_PickDay() -> cDayOfWeek",
  "documentation": "Picklist of days of week",
  "arguments": [],
  "name": "ft_PickDay",
  "return": {
   "name": "",
   "help": "Character string containing day of week"
  }
 },
 {
  "label": "ft_Poke( <nSegment>, <nOffset>, <nValue> ) -> lResult",
  "documentation": "Write a byte to a specified memory location",
  "arguments": [
   {
    "label": "<nSegment>",
    "documentation": "is the segment of the desired memory address."
   },
   {
    "label": "<nOffset>",
    "documentation": "is the offset of the desired memory address."
   },
   {
    "label": "<nValue>",
    "documentation": "is the value to write to the desired memory address."
   }
  ],
  "name": "ft_Poke",
  "return": {
   "name": "<lResult>",
   "help": "will be .T. if all parameters were valid and the function was able to write the desired byte. <lResult> will be .F. if invalid parameters were passed."
  }
 },
 {
  "label": "ft_PopVid() -> <nStackSize>",
  "documentation": "Restore previously saved video states.",
  "arguments": [],
  "name": "ft_PopVid",
  "return": {
   "name": "",
   "help": "The number of items remaining in the internal stack."
  }
 },
 {
  "label": "ft_Proper( <cString> ) -> cProperName",
  "documentation": "Convert a string to proper-name case",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "is the string to be converted."
   }
  ],
  "name": "ft_Proper",
  "return": {
   "name": "",
   "help": "A string of the same length as <cString>, only converted to proper name case (upper/lower case)."
  }
 },
 {
  "label": "ft_PrtScr( [ <lSetStat> ] ) -> lCurStat",
  "documentation": "Enable or disable the Print Screen key",
  "arguments": [
   {
    "label": "<lSetStat>",
    "documentation": "set to .T. will enable the Print Screen key, .F. will disable it.  If omitted, leaves status as is."
   }
  ],
  "name": "ft_PrtScr",
  "return": {
   "name": "",
   "help": "The current state: .T. if enabled, .F. if disabled."
  }
 },
 {
  "label": "ft_PushVid() -> <nStackSize>",
  "documentation": "Save current video states on internal stack.",
  "arguments": [],
  "name": "ft_PushVid",
  "return": {
   "name": "",
   "help": "The current size of the internal stack (i.e. the number of times ft_PushVid() has been called)."
  }
 },
 {
  "label": "ft_PutKey( <nKeyValue> ) -> lResult",
  "documentation": "Stuff a keystroke into the keyboard buffer",
  "arguments": [
   {
    "label": "<nKeyValue>",
    "documentation": "is the Inkey() value of the keystroke to be stuffed."
   }
  ],
  "name": "ft_PutKey",
  "return": {
   "name": "",
   "help": ".T. if the keystroke was put into the keyboard buffer. .F. if nKeyValue was invalid or the buffer was full."
  }
 },
 {
  "label": "ft_Qtr( [ <dGivenDate> ], [ <nQtrNum> ] ) -> aDateInfo",
  "documentation": "Return Calendar or Fiscal Quarter Data.",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any date format.  Defaults to current system date if not supplied."
   },
   {
    "label": "<nQtrNum>",
    "documentation": "is a number from 1 to 4 signifying a quarter. Defaults to current quarter if not supplied."
   }
  ],
  "name": "ft_Qtr",
  "return": {
   "name": "",
   "help": "A three element array containing the following data: aDateInfo[ 1 ] - The year and quarter as a character string \"YYYYQQ\" aDateInfo[ 2 ] - The beginning date of the quarter aDateInfo[ 3 ] - The ending date of the quarter"
  }
 },
 {
  "label": "ft_Rand1( <nMax> ) -> nRand",
  "documentation": "Generate a random number",
  "arguments": [
   {
    "label": "<nMax>",
    "documentation": "Maximum limit of value to be produced."
   }
  ],
  "name": "ft_Rand1",
  "return": {
   "name": "",
   "help": "nRand is a random number between 0 (inclusive) and <nMax> (exclusive)."
  }
 },
 {
  "label": "ft_RAt2( <cSearch>, <cTarget> [, <nOccurs> [, <lCaseSens> ] ] ) -> nPos",
  "documentation": "Find position of the reversed nth occurrence of a substring",
  "arguments": [
   {
    "label": "<cSearch>",
    "documentation": "is the character substring to search for."
   },
   {
    "label": "<cTarget>",
    "documentation": "is the character string to search."
   },
   {
    "label": "<nOccurs>",
    "documentation": "is the occurrence of cSearch to look for, defaults to 1."
   },
   {
    "label": "<lCaseSens>",
    "documentation": "is a logical value denoting case sensitivity. If .F., then search is NOT sensitive to case, defaults to .T."
   }
  ],
  "name": "ft_RAt2",
  "return": {
   "name": "",
   "help": "The position of the nth occurrence of a reversed substring"
  }
 },
 {
  "label": "ft_Reboot( <nBootType> ) -> NIL",
  "documentation": "Force a warm or cold boot",
  "arguments": [
   {
    "label": "<nBootType>",
    "documentation": "is used to indicate the type of reboot.  A value of zero will cause a cold boot, while any other value will cause a warm boot."
   }
  ],
  "name": "ft_Reboot",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_RestArr( <cFileName>, <nErrorCode> ) -> aArray",
  "documentation": "Restore a Clipper array from a disc file",
  "arguments": [
   {
    "label": "<cFileName>",
    "documentation": "is a DOS file name."
   },
   {
    "label": "<nErrorCode>",
    "documentation": "will return any DOS file error. All arguments are required."
   }
  ],
  "name": "ft_RestArr",
  "return": {
   "name": "",
   "help": "Return an array variable."
  }
 },
 {
  "label": "ft_RestAtt( <nTop>, <nLeft>, <nBottom>, <nRight>, <cAttributes> ) -> NIL",
  "documentation": "Restore the attribute bytes of a specified screen region.",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": ", <nLeft>, <nBottom>, and <nRight> define the screen region."
   },
   {
    "label": "<cAttributes>",
    "documentation": "is a character string containing the attribute bytes for the screen region.  This will most often be a string previously returned by ft_SaveAtt(), but any character string may be used (provided it is of the proper size)."
   }
  ],
  "name": "ft_RestAtt",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_RestSets( [ <aOldSets> ] ) -> NIL",
  "documentation": "Restore status of all SET command settings",
  "arguments": [],
  "name": "ft_RestSets",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_RevAttr( <nTRow>, <nLCol>, <nBRow>, <nRCol> ) -> NIL",
  "documentation": "Reverse colors of specified screen coordinates",
  "arguments": [
   {
    "label": "<nTRow>",
    "documentation": ", <nLCol>, <nBRow>, and <nRCol> are the coordinates of the screen region."
   }
  ],
  "name": "ft_RevAttr",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_RevChr( <nTRow>, <nLCol> ) -> NIL",
  "documentation": "Reverse the color of a single character on the screen",
  "arguments": [
   {
    "label": "<nTRow>",
    "documentation": ", <nLCol> are the screen coordinates of the character."
   }
  ],
  "name": "ft_RevChr",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_RgnStack( <cAction>, [ <nTop> ], [ <nLeft> ], [ <nBottom> ], [ <nRight> ] ) -> NIL",
  "documentation": "Push or pop a saved screen region on or off the stack",
  "arguments": [
   {
    "label": "<cAction>",
    "documentation": "determines what action ft_RgnStack() will take.  The allowable values for this parameter are \"push\", \"pop\", and \"pop all\". If the function is called with any other string as the first parameter no action is performed."
   },
   {
    "label": "<cAction>",
    "documentation": "with a value of \"push\" will push a saved screen region onto the stack.  A value of \"pop\" will restore the most recently pushed screen region.  \"pop all\" tells the function to restore all screen images which are currently on the stack. The use of <nTop>, <nLeft>, <nBottom>, and <nRight> depends on the"
   },
   {
    "label": "<cAction>",
    "documentation": "parameter.  If <cAction> is \"push\", the next four parameters define the screen region to save.  If <cAction> is \"pop\" or \"pop all\" the following four parameters are ignored."
   }
  ],
  "name": "ft_RgnStack",
  "return": {
   "name": "",
   "help": "ft_RgnStack() returns NIL."
  }
 },
 {
  "label": "ft_RmDir( <cDirName> ) -> nResult",
  "documentation": "Delete a subdirectory",
  "arguments": [
   {
    "label": "<cDirName>",
    "documentation": "is the name of the directory to delete."
   }
  ],
  "name": "ft_RmDir",
  "return": {
   "name": "",
   "help": "0   if successful 3   if Path Not Found 5   if Access Denied (directory not empty) 16  if attempt to delete current directory. 99  if invalid parameters passed"
  }
 },
 {
  "label": "ft_Round( <nNumber> [, <nRoundToAmount>           ; [, <cRoundType>  [, <cRoundDirection>   ; [, <nAcceptableError> ] ] ] ] )            -> nNumber",
  "documentation": "Rounds a number to a specific place",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "is the number to round"
   },
   {
    "label": "<nRoundToAmount>",
    "documentation": "is the fraction to round to or the number of places, default is 2."
   },
   {
    "label": "<cRoundType>",
    "documentation": "is the type of rounding desired \"D\" for Decimal       (3 for thousandth, 1/1000)  (default) \"F\" for Fraction      (3 for thirds, 1/3) \"W\" for Whole numbers (3 for thousand, 1000)"
   },
   {
    "label": "<cRoundDirection>",
    "documentation": "is the direction to round the number toward \"U\" to round Up      1.31 ->  1.4 -1.31 -> -1.4 \"D\" to round Down    1.36 ->  1.3 -1.36 -> -1.3 \"N\" to round Normal  1.5  ->  2 -1.5  -> -2 1.49 ->  1 -1.49 -> -1"
   },
   {
    "label": "<nAcceptableError>",
    "documentation": "is the amount that is considered acceptable to be within, i.e., if you're within this amount of the number you don't need to round"
   }
  ],
  "name": "ft_Round",
  "return": {
   "name": "",
   "help": "The number, rounded as specified."
  }
 },
 {
  "label": "ft_RstRgn( <cScreen>, [ <nTop> ], [ <nLeft> ] ) -> NIL",
  "documentation": "Restore region of the screen saved with ft_SavRgn()",
  "arguments": [
   {
    "label": "<cScreen>",
    "documentation": "is a screen region previously returned from ft_SavRgn()."
   },
   {
    "label": "<nTop>",
    "documentation": "and <nLeft> are optional parameters that define a new location for the upper left corner of the screen area contained in <cScreen>. Allowable values are 0 through 255."
   }
  ],
  "name": "ft_RstRgn",
  "return": {
   "name": "",
   "help": "ft_RstRgn() returns NIL."
  }
 },
 {
  "label": "ft_SaveArr( <aArray>, <cFileName>, <nErrorCode> ) -> lRet",
  "documentation": "Save Clipper array to a disc file.",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "is any Clipper array except those containing compiled code blocks."
   },
   {
    "label": "<cFileName>",
    "documentation": "is a DOS file name."
   },
   {
    "label": "<nErrorCode>",
    "documentation": "will return any DOS file error. All arguments are required."
   }
  ],
  "name": "ft_SaveArr",
  "return": {
   "name": "",
   "help": ".F. if there was a DOS file error or the array contained code blocks, otherwise returns .T."
  }
 },
 {
  "label": "ft_SaveAtt( <nTop>, <nLeft>, <nBottom>, <nRight> ) -> cAttributes",
  "documentation": "Save the attribute bytes of a specified screen region.",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": ", <nLeft>, <nBottom>, and <nRight> define the screen region."
   }
  ],
  "name": "ft_SaveAtt",
  "return": {
   "name": "",
   "help": "A character string containing the screen attribute bytes for the specified region.  If the memory to store the return value could not be allocated, the function returns NIL."
  }
 },
 {
  "label": "ft_SaveSets() -> aOldSets",
  "documentation": "Save the status of all the SET command settings",
  "arguments": [],
  "name": "ft_SaveSets",
  "return": {
   "name": "",
   "help": "An array containing the values of the supported SETs."
  }
 },
 {
  "label": "ft_SavRgn( <nTop>, <nLeft>, <nBottom>, <nRight> ) -> cScreen",
  "documentation": "Save a screen region for later display",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": ", <nLeft>, <nBottom>, and <nRight> define the portion of the screen to save.  Allowable values are 0 through 255."
   }
  ],
  "name": "ft_SavRgn",
  "return": {
   "name": "",
   "help": "ft_SavRgn() returns the saved screen region and its coordinates as a character string."
  }
 },
 {
  "label": "ft_ScanCode() -> cCode",
  "documentation": "Wait for keypress and return keyboard scan code",
  "arguments": [],
  "name": "ft_ScanCode",
  "return": {
   "name": "",
   "help": "A two-character string, corresponding to the keyboard scan code."
  }
 },
 {
  "label": "ft_SetAttr( <nTRow>, <nLCol>, <nBRow>, <nRCol>, <nColor> ) -> NIL",
  "documentation": "Change color attributes of screen region",
  "arguments": [
   {
    "label": "<nTRow>",
    "documentation": ", <nLCol>, <nBRow>, and <nRCol> are the coordinates of the screen region."
   },
   {
    "label": "<nColor>",
    "documentation": "is an integer representing the new color attribute. The formula is: nFore + ( nBack * 16 )"
   }
  ],
  "name": "ft_SetAttr",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_SetCentury( [ <lNewSetState> ] ) -> <lOldState>",
  "documentation": "Check/Set the CENTURY Setting",
  "arguments": [],
  "name": "ft_SetCentury",
  "return": {
   "name": "",
   "help": "The state of the CENTURY setting upon entry to the routine"
  }
 },
 {
  "label": "ft_SetDate( <dDate> ) -> <lResult>",
  "documentation": "Set the DOS system date",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "is a Clipper date variable that you want to set the current DOS system date to. It is up to you to send in a valid date.  The year must be within the range 1980 through 2099.  If DOS thinks the date is not valid, it won't change the date."
   }
  ],
  "name": "ft_SetDate",
  "return": {
   "name": "<lResult>",
   "help": "is simply the result of ft_int86(), passed back to your program."
  }
 },
 {
  "label": "ft_SetMode( <nMode> ) -> NIL",
  "documentation": "Set the video mode",
  "arguments": [
   {
    "label": "<nMode>",
    "documentation": "is one of the DOS video modes."
   }
  ],
  "name": "ft_SetMode",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_SetRate( [ <nDelayTime> ] [, <nRepeatRate> ] ) -> NIL",
  "documentation": "Set the keyboard delay and repeat rate on PC/AT & PS/2",
  "arguments": [
   {
    "label": "<nDelayTime>",
    "documentation": "is the keyboard delay time."
   },
   {
    "label": "<nRepeatRate>",
    "documentation": "is the keyboard repeat rate. ┌───────────────────────┐  ┌────────────────────────┐ │ nDelayTime      DELAY │  │ RepeatRate      SPEED  │ ├───────────────────────┤  ├────────────────────────┤ │     0           250ms │  │    0           30.0cps │ │     1 (default) 500ms │  │    1           26.7cps │ │     2           750ms │  │    2           24.0cps │ │     3          1000ms │  │    3           21.8cps │ └───────────────────────┘  │    4           20.0cps │ │    5           18.5cps │ │    6           17.1cps │ │    7           16.0cps │ │    8           15.0cps │ │    9           13.3cps │ │   10           12.0cps │ │   11           10.9cps │ │   12 (default) 10.0cps │ │   13            9.2cps │ │   14            8.6cps │ │   15            8.0cps │ │   16            7.5cps │ │   17            6.7cps │ │   18            6.0cps │ │   19            5.5cps │ │   20            5.0cps │ │   21            4.6cps │ │   22            4.3cps │ │   23            4.0cps │ │   24            3.7cps │ │   25            3.3cps │ │   26            3.0cps │ │   27            2.7cps │ │   28            2.5cps │ │   29            2.3cps │ │   30            2.1cps │ │   31            2.0cps │ └────────────────────────┘"
   }
  ],
  "name": "ft_SetRate",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_SetTime( <cTime> ) -> <lResult>",
  "documentation": "Set the DOS system time",
  "arguments": [
   {
    "label": "<cTime>",
    "documentation": "is a string in the form <hh:mm:ss> that you want to set the current DOS system time to. Use 24-hour time.  It is up to you to send in a valid time.  If DOS doesn't think it is valid, it won't reset the time anyway."
   }
  ],
  "name": "ft_SetTime",
  "return": {
   "name": "<lResult>",
   "help": "is simply the result of ft_int86(), passed back to your program."
  }
 },
 {
  "label": "ft_SetVCur( [ <nPage> ], [ <nRow> ], [ <nCol> ] ) -> NIL",
  "documentation": "Set the cursor position on a specified video page",
  "arguments": [
   {
    "label": "<nPage>",
    "documentation": "is the video page (defaults to current page, determined by ft_GetVPg()"
   },
   {
    "label": "<nRow>",
    "documentation": "is the row coordinate (defaults to 0 )"
   },
   {
    "label": "<nCol>",
    "documentation": "is the column coordinate (defaults to 0 )"
   }
  ],
  "name": "ft_SetVCur",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_SetVPg( <nPage> ) -> NIL",
  "documentation": "Set the current video page",
  "arguments": [
   {
    "label": "<nMode>",
    "documentation": "is a valid video page."
   }
  ],
  "name": "ft_SetVPg",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Shadow( <nTop>, <nLeft>, <nBottom>, <nRight> [ ,<nAttr>] ) -> NIL",
  "documentation": "Draw a non-destructive shadow on the screen",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": "is the top row of the shadow area."
   },
   {
    "label": "<nLeft>",
    "documentation": "is the upper left column of the shadow area."
   },
   {
    "label": "<nBottom>",
    "documentation": "is the bottom row of the shadow area."
   },
   {
    "label": "<nRight>",
    "documentation": "is the lower right column of the shadow area."
   },
   {
    "label": "<nAttr>",
    "documentation": "is optional and is the screen attribute to use for drawing the shadow.  If not specified, the default is 8."
   }
  ],
  "name": "ft_Shadow",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Shift() -> lValue",
  "documentation": "Determine status of shift key",
  "arguments": [],
  "name": "ft_Shift",
  "return": {
   "name": "",
   "help": ".T. if a shift key is pressed, .F. if otherwise."
  }
 },
 {
  "label": "ft_SInkey( [ <nWaitTime> ] ) -> nKey",
  "documentation": "Replacement for Inkey() that tests for SET KEY procedures",
  "arguments": [
   {
    "label": "<nWaitTime>",
    "documentation": "is the number of seconds to wait.  If zero, ft_SInkey() will wait indefinitely for a keypress.  If not passed, ft_SInkey() does not wait for a keypress.  If NIL, it is treated the same as 0."
   }
  ],
  "name": "ft_SInkey",
  "return": {
   "name": "",
   "help": "The Inkey() value of the key pressed."
  }
 },
 {
  "label": "ft_Sleep( <nSeconds>, [<nInitial>] ) -> nil",
  "documentation": "Wait for a specified amount of time",
  "arguments": [
   {
    "label": "<nSeconds>",
    "documentation": "is the number of seconds to pause"
   },
   {
    "label": "<nInitial>",
    "documentation": "is an optional clock value (from a call to Seconds()) from which the <nSeconds> seconds are to elapse. Useful for setting a minimum time between the start of events which could take a variable amount of time due to the execution of intervening code."
   }
  ],
  "name": "ft_Sleep",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Sqzn( <nValue> [, <nSize> [, <nDecimals> ] ] ) -> cCompressed",
  "documentation": "Compress a numeric value into a character string",
  "arguments": [],
  "name": "ft_Sqzn",
  "return": {
   "name": "",
   "help": "cCompressed  - Compressed string, 50% the size of nSize"
  }
 },
 {
  "label": "ft_SToD( <cDateStr> ) -> dDateType",
  "documentation": "Convert a date string to a Clipper date data type",
  "arguments": [
   {
    "label": "<cDateStr>",
    "documentation": "is a Clipper string in the format \"CCYYMMDD\"."
   }
  ],
  "name": "ft_SToD",
  "return": {
   "name": "",
   "help": "A Clipper date type."
  }
 },
 {
  "label": "ft_Sys2Mil() -> cMILTIME",
  "documentation": "Convert system time to military time format.",
  "arguments": [],
  "name": "ft_Sys2Mil",
  "return": {
   "name": "<cMILTIME>",
   "help": "character string of form hhmm, where 0<=hh<24."
  }
 },
 {
  "label": "ft_SysMem() -> nMemSize",
  "documentation": "Determine the amount of conventional memory installed",
  "arguments": [],
  "name": "ft_SysMem",
  "return": {
   "name": "",
   "help": "A numeric corresponding to the number of KiB memory."
  }
 },
 {
  "label": "ft_TempFil( [ <cPath> ] [, <lHide> ] ) -> cFileSpec",
  "documentation": "Create a file with a unique name",
  "arguments": [
   {
    "label": "<cPath>",
    "documentation": "is the directory where you want to create the temporary file.  If you omit this argument, the root of the current drive is assumed (\"\\\"). If <lHide> is .T., then the file will be created with the hidden attribute set.  The default is .F."
   }
  ],
  "name": "ft_TempFil",
  "return": {
   "name": "<cFileSpec>",
   "help": "should be your path, including the name of the newly created unique file.  You are safe to create a new file with this filename. If a DOS error occurred when trying to create the file, a null string will be returned."
  }
 },
 {
  "label": "ft_Unsqzn( <cCompressed>, <nSize> [, <nDecimals> ] ) -> nValue",
  "documentation": "Uncompress a numeric compressed by ft_Sqzn()",
  "arguments": [
   {
    "label": "<cCompressed>",
    "documentation": "- Compressed string, obtained from ft_Sqzn()"
   },
   {
    "label": "<nSize>",
    "documentation": "- Size of numeric field"
   },
   {
    "label": "<nDecimals>",
    "documentation": "- Optional number of decimal places"
   }
  ],
  "name": "ft_Unsqzn",
  "return": {
   "name": "",
   "help": "nValue       - Uncompressed numeric value"
  }
 },
 {
  "label": "ft_VidStr( <nRow>, <nCol>, <cString> [, <nColor> ] ) -> NIL",
  "documentation": "Display string on screen in specified attribute",
  "arguments": [
   {
    "label": "<nRow>",
    "documentation": "and <nCol> are the screen coordinates."
   },
   {
    "label": "<cString>",
    "documentation": "is the string to be printed on the screen."
   },
   {
    "label": "<nColor>",
    "documentation": "is an integer representing the color attribute. The formula is: nFore + ( nBack * 16 ) ft_VidStr() will display the string in the current color if"
   },
   {
    "label": "<nColor>",
    "documentation": "is not passed."
   }
  ],
  "name": "ft_VidStr",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_Week( [ <dGivenDate> ], [ <nWeekNum> ] ) -> aDateinfo",
  "documentation": "Return calendar or fiscal week data",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any date format.  Defaults to current system date if not supplied."
   },
   {
    "label": "<nWeekNum>",
    "documentation": "is a number from 1 to 53 signifying a week. Defaults to current week if not supplied."
   }
  ],
  "name": "ft_Week",
  "return": {
   "name": "",
   "help": "A three element array containing the following data: aDateInfo[ 1 ] - The year and week as a character string \"YYYYWW\" aDateInfo[ 2 ] - The beginning date of the week aDateInfo[ 3 ] - The ending date of the week"
  }
 },
 {
  "label": "ft_Workdays( [ <dStart> ], [ <dStop> ] ) -> nDays",
  "documentation": "Return number of work days between two dates",
  "arguments": [
   {
    "label": "<dStart>",
    "documentation": "is the beginning value for the date range."
   },
   {
    "label": "<dStop>",
    "documentation": "is the ending value for the date range."
   }
  ],
  "name": "ft_Workdays",
  "return": {
   "name": "",
   "help": "The number of work days (Monday through Friday) between two dates."
  }
 },
 {
  "label": "ft_WoY( <dDate> ) -> <nResult>",
  "documentation": "Find number of week within year",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "is a date in the form \"mm/dd/yy\" or \"mm/dd/yyyy\""
   }
  ],
  "name": "ft_WoY",
  "return": {
   "name": "",
   "help": "Return numeric position of week within the year or NIL if parameter does not conform."
  }
 },
 {
  "label": "ft_WrtChr( <nRow>, <nCol>, <cChar>, <nColor> ) -> NIL",
  "documentation": "Display character on screen",
  "arguments": [
   {
    "label": "<nRow>",
    "documentation": "and <nCol> are the screen coordinates."
   },
   {
    "label": "<cChar>",
    "documentation": "is the single character to print on the screen."
   },
   {
    "label": "<nColor>",
    "documentation": "is an integer representing the color attribute. The formula is: nFore + ( nBack * 16 )"
   }
  ],
  "name": "ft_WrtChr",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_XBox( [ <cJustType> ], [ <cRetWait> ], [ <cBorType> ],   ; [ <cBorColor> ], [ <cBoxColor> ], [ <nStartRow> ], ; [ <nStartCol> ], <cLine1>,  <cLine2>, <cLine3>,    ; <cLine4>, <cLine5>, <cLine6>, <cLine7>, <cLine8> ) -> NIL",
  "documentation": "Display a self-sizing message box and message",
  "arguments": [
   {
    "label": "<cJustType>",
    "documentation": "is a character indicating the type of text justification. \"L\" or \"l\" will cause the text to be left-justified in the box. Centered text is the default."
   },
   {
    "label": "<cRetWait>",
    "documentation": "is a character which determines if the function will wait for a keypress after displaying the box.  \"W\" or \"w\" will cause the function to wait for a keypress before returning control to the calling routine.  Not waiting is the default"
   },
   {
    "label": "<cBorType>",
    "documentation": "is a character which determines whether a single or double border will be displayed.  \"D\" or \"d\" will cause a double border to be displayed.  A single border is the default."
   },
   {
    "label": "<cBorColor>",
    "documentation": "is a character string denoting the border color.  'N/W' is the default if this parameter is not a string."
   },
   {
    "label": "<cBoxColor>",
    "documentation": "is a character string denoting the text color.  'W/N' is the default if this parameter is not a string."
   },
   {
    "label": "<nStartRow>",
    "documentation": "is a number denoting the starting row.  If '99' is passed, the box is centered vertically.  If necessary, nStartRow is decreased so the entire box can be displayed."
   },
   {
    "label": "<nStartCol>",
    "documentation": "is a number denoting the starting column.  If '99' is passed, the box is centered horizontally.  If necessary, nStartCol is decreased so the entire box can be displayed."
   },
   {
    "label": "<cLine1>",
    "documentation": "thru <cLine8> are 1 to 8 character strings to be displayed. They are truncated to fit on the screen if necessary."
   }
  ],
  "name": "ft_XBox",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "ft_XToY( <xValueToConvert>, <cTypeToConvertTo> ; [, <lWantYesNo> ] ) -> xResult",
  "documentation": "Convert from any data type to any other data type",
  "arguments": [
   {
    "label": "<xValueToConvert>",
    "documentation": "is the value to convert."
   },
   {
    "label": "<cTypeToConvertTo>",
    "documentation": "is the type of value to convert to (\"C\",\"D\",\"L\",\"N\",\"A\" or \"B\")."
   },
   {
    "label": "<lWantYesNo>",
    "documentation": "is a logical to signal if 'Y' or 'N' is to be returned if Converting a logical, otherwise '.T.' or '.F.' will be returned for logicals."
   }
  ],
  "name": "ft_XToY",
  "return": {
   "name": "",
   "help": "The original value converted to the new type."
  }
 },
 {
  "label": "ft_Year( [ <dGivenDate> ] ) -> aDateInfo",
  "documentation": "Return calendar or fiscal year data",
  "arguments": [
   {
    "label": "<dGivenDate>",
    "documentation": "is any valid date in any date format.  Defaults to current system date if not supplied."
   }
  ],
  "name": "ft_Year",
  "return": {
   "name": "",
   "help": "A three element array containing the following data: aDateInfo[ 1 ] - The year as a character string \"YYYY\" aDateInfo[ 2 ] - The beginning date of the year aDateInfo[ 3 ] - The ending date of the year"
  }
 },
 {
  "label": "FToC( <nFloatingPointNumber> ) --> cFloatingPointNumber ",
  "documentation": "",
  "arguments": [
   {
    "label": "<nFloatingPointNumber>",
    "documentation": "Designate any Harbour number."
   }
  ],
  "name": "FToC",
  "return": {
   "name": "",
   "help": "FToC() return a string with the size of DOUBLE. ATTENTION: different implementations or platforms of Harbour, they could produce different format in the string returned by FToC()."
  }
 },
 {
  "label": "FV( nDeposit, nInterest, nPeriods ) --> nFutureValue",
  "documentation": "Future value of a capital",
  "arguments": [
   {
    "label": "<nDeposit>",
    "documentation": "amount of money invested per period"
   },
   {
    "label": "<nInterest>",
    "documentation": "rate of interest per period, 1 == 100%"
   },
   {
    "label": "<nPeriods>",
    "documentation": "period count"
   }
  ],
  "name": "FV",
  "return": {
   "name": "<nFutureValue>",
   "help": "Total value of the capital after <nPeriods> of paying <nDeposit> and <nInterest> interest being paid every period and added to the capital (resulting in compound interest)"
  }
 },
 {
  "label": "FWrite( <nHandle>, <cBuffer>, [<nBytes>] ) --> nBytesWritten",
  "documentation": "Writes characters to a file.",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "File handle number."
   },
   {
    "label": "<cBuffer>",
    "documentation": "Character expression to be written."
   },
   {
    "label": "<nBytes>",
    "documentation": "The number of bytes to write."
   }
  ],
  "name": "FWrite",
  "return": {
   "name": "<nBytesWritten>",
   "help": "the number of bytes successfully written."
  }
 },
 {
  "label": "gdImageArc( <pImage>, <cx>, <cy>, <w>, <h>, <s>, <e>, <nColor> ) --> NIL",
  "documentation": "Draws a partial ellipse centered at a given point.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<cx>",
    "documentation": "- center point horizontal position"
   },
   {
    "label": "<cy>",
    "documentation": "- center point vertical position"
   },
   {
    "label": "<w>",
    "documentation": "- width"
   },
   {
    "label": "<h>",
    "documentation": "- height"
   },
   {
    "label": "<s>",
    "documentation": "- start degree"
   },
   {
    "label": "<e>",
    "documentation": "- end degree"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   }
  ],
  "name": "gdImageArc",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageArc( <pImage>, <cx>, <cy>, <w>, <h>, <s>, <e>, <nColor>, <nStyle> ) --> NIL",
  "documentation": "Draws a partial filled ellipse centered at a given point.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<cx>",
    "documentation": "- center point horizontal position"
   },
   {
    "label": "<cy>",
    "documentation": "- center point vertical position"
   },
   {
    "label": "<w>",
    "documentation": "- width"
   },
   {
    "label": "<h>",
    "documentation": "- height"
   },
   {
    "label": "<s>",
    "documentation": "- start degree"
   },
   {
    "label": "<e>",
    "documentation": "- end degree"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   },
   {
    "label": "<nStyle>",
    "documentation": "- fill style"
   }
  ],
  "name": "gdImageArc",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageCreate( <nPixelWidth>, <nPixelHeight> ) --> <pImage>",
  "documentation": "Create a palette-based image in memory with no more that 256 colors.",
  "arguments": [
   {
    "label": "<nPixelWidth>",
    "documentation": "- image width"
   },
   {
    "label": "<nPixelHeight>",
    "documentation": "- image height"
   }
  ],
  "name": "gdImageCreate",
  "return": {
   "name": "<pImage>",
   "help": "- Image pointer"
  }
 },
 {
  "label": "gdImageCreateFromGD( <cFile> | <nHandle> | <pPointer> [, <nSize> ] ) --> <pImage>",
  "documentation": "Load a GD image file.",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "- Image file name"
   },
   {
    "label": "<nHandle>",
    "documentation": "- File handle"
   },
   {
    "label": "<pPointer>",
    "documentation": "- Memory image pointer"
   },
   {
    "label": "<nSize>",
    "documentation": "- Image size"
   }
  ],
  "name": "gdImageCreateFromGD",
  "return": {
   "name": "<pImage>",
   "help": "- Image pointer"
  }
 },
 {
  "label": "gdImageCreateFromGif( <cFile> | <nHandle> | <pPointer> [, <nSize> ] ) --> <pImage>",
  "documentation": "Load a Gif image file.",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "- Image file name"
   },
   {
    "label": "<nHandle>",
    "documentation": "- File handle"
   },
   {
    "label": "<pPointer>",
    "documentation": "- Memory image pointer"
   },
   {
    "label": "<nSize>",
    "documentation": "- Image size"
   }
  ],
  "name": "gdImageCreateFromGif",
  "return": {
   "name": "<pImage>",
   "help": "- Image pointer"
  }
 },
 {
  "label": "gdImageCreateFromJpeg( <cFile> | <nHandle> | <pPointer> [, <nSize> ] ) --> <pImage>",
  "documentation": "Load a JPEG image file.",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "- Image file name"
   },
   {
    "label": "<nHandle>",
    "documentation": "- File handle"
   },
   {
    "label": "<pPointer>",
    "documentation": "- Memory image pointer"
   },
   {
    "label": "<nSize>",
    "documentation": "- Image size"
   }
  ],
  "name": "gdImageCreateFromJpeg",
  "return": {
   "name": "<pImage>",
   "help": "- Image pointer"
  }
 },
 {
  "label": "gdImageCreateFromPng( <cFile> | <nHandle> | <pPointer> [, <nSize> ] ) --> <pImage>",
  "documentation": "Load a PNG image file.",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "- Image file name"
   },
   {
    "label": "<nHandle>",
    "documentation": "- File handle"
   },
   {
    "label": "<pPointer>",
    "documentation": "- Memory image pointer"
   },
   {
    "label": "<nSize>",
    "documentation": "- Image size"
   }
  ],
  "name": "gdImageCreateFromPng",
  "return": {
   "name": "<pImage>",
   "help": "- Image pointer"
  }
 },
 {
  "label": "gdImageCreateFromWBmp( <cFile> | <nHandle> | <pPointer> [, <nSize> ] ) --> <pImage>",
  "documentation": "Load a WBmp image file.",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "- Image file name"
   },
   {
    "label": "<nHandle>",
    "documentation": "- File handle"
   },
   {
    "label": "<pPointer>",
    "documentation": "- Memory image pointer"
   },
   {
    "label": "<nSize>",
    "documentation": "- Image size"
   }
  ],
  "name": "gdImageCreateFromWBmp",
  "return": {
   "name": "<pImage>",
   "help": "- Image pointer"
  }
 },
 {
  "label": "gdImageCreateTrueColor( <nPixelWidth>, <nPixelHeight> ) --> <pImage>",
  "documentation": "Create a true color image in memory.",
  "arguments": [
   {
    "label": "<nPixelWidth>",
    "documentation": "- image width"
   },
   {
    "label": "<nPixelHeight>",
    "documentation": "- image height"
   }
  ],
  "name": "gdImageCreateTrueColor",
  "return": {
   "name": "<pImage>",
   "help": "- Image pointer"
  }
 },
 {
  "label": "gdImageDashedLine( <pImage>, <x1>, <y1>, <x2>, <y2>, <nColor> ) --> NIL",
  "documentation": "Draws a dashed line between two end points (x1, y1 and x2, y2) with a particular color index.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<x1>",
    "documentation": "- 1st point horizontal position"
   },
   {
    "label": "<y1>",
    "documentation": "- 1st point vertical position"
   },
   {
    "label": "<x2>",
    "documentation": "- 2nd point horizontal position"
   },
   {
    "label": "<y2>",
    "documentation": "- 2nd point vertical position"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   }
  ],
  "name": "gdImageDashedLine",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageFill( <pImage>, <x>, <y>, <nColor> ) --> NIL",
  "documentation": "floods a portion of the image with the specified color.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<x>",
    "documentation": "- start point horizontal position"
   },
   {
    "label": "<y>",
    "documentation": "- start point vertical position"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index of filling color"
   }
  ],
  "name": "gdImageFill",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageFilledEllipse( <pImage>, <cx>, <cy>, <w>, <h>, <nColor> ) --> NIL",
  "documentation": "Draws a filled ellipse centered at a given point.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<cx>",
    "documentation": "- center point horizontal position"
   },
   {
    "label": "<cy>",
    "documentation": "- center point vertical position"
   },
   {
    "label": "<w>",
    "documentation": "- width"
   },
   {
    "label": "<h>",
    "documentation": "- height"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   }
  ],
  "name": "gdImageFilledEllipse",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageFilledPolygon( <pImage>, <aVerticies>, <nColor> ) --> NIL",
  "documentation": "Draws a filled polygon with verticies (at least 3) with a particular color index.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<aVerticies>",
    "documentation": "- Array of point array { <x>, <y> } where"
   },
   {
    "label": "<x>",
    "documentation": "is horizontal position"
   },
   {
    "label": "<y>",
    "documentation": "is vertical position"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   }
  ],
  "name": "gdImageFilledPolygon",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageFilledRectangle( <pImage>, <x1>, <y1>, <x2>, <y2>, <nColor> ) --> NIL",
  "documentation": "Draws a filled rectangle with a particular color index.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<x1>",
    "documentation": "- upper left point horizontal position"
   },
   {
    "label": "<y1>",
    "documentation": "- upper left point vertical position"
   },
   {
    "label": "<x2>",
    "documentation": "- lower right point horizontal position"
   },
   {
    "label": "<y2>",
    "documentation": "- lower right point vertical position"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   }
  ],
  "name": "gdImageFilledRectangle",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageFillToBorder( <pImage>, <x>, <y>, <nBorder>, <nColor> ) --> NIL",
  "documentation": "floods a portion of the image with the specified color.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<x>",
    "documentation": "- start point horizontal position"
   },
   {
    "label": "<y>",
    "documentation": "- start point vertical position"
   },
   {
    "label": "<nBorder>",
    "documentation": "- Color index where fill stops"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index of filling color"
   }
  ],
  "name": "gdImageFillToBorder",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageGD( <pImage>, <cFile> | <nHandle> ) --> NIL",
  "documentation": "Save a GD image.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<cFile>",
    "documentation": "- Image file name"
   },
   {
    "label": "<nHandle>",
    "documentation": "- File handle"
   }
  ],
  "name": "gdImageGD",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageGif( <pImage>, <cFile> | <nHandle> ) --> NIL",
  "documentation": "Save a GIF image.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<cFile>",
    "documentation": "- Image file name"
   },
   {
    "label": "<nHandle>",
    "documentation": "- File handle"
   }
  ],
  "name": "gdImageGif",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageJpeg( <pImage>, <cFile> | <nHandle> [, <nCompressionLevel> ] ) --> NIL",
  "documentation": "Save a JPEG image.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<cFile>",
    "documentation": "- Image file name"
   },
   {
    "label": "<nHandle>",
    "documentation": "- File handle"
   },
   {
    "label": "<nCompressionLevel>",
    "documentation": "- a numeric value between 0=max compression and 95=min compression (best quality) default is -1=auto"
   }
  ],
  "name": "gdImageJpeg",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageLine( <pImage>, <x1>, <y1>, <x2>, <y2>, <nColor> ) --> NIL",
  "documentation": "Draws a line between two end points (x1, y1 and x2, y2) with a particular color index.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<x1>",
    "documentation": "- 1st point horizontal position"
   },
   {
    "label": "<y1>",
    "documentation": "- 1st point vertical position"
   },
   {
    "label": "<x2>",
    "documentation": "- 2nd point horizontal position"
   },
   {
    "label": "<y2>",
    "documentation": "- 2nd point vertical position"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   }
  ],
  "name": "gdImageLine",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageOpenPolygon( <pImage>, <aVerticies>, <nColor> ) --> NIL",
  "documentation": "Draws an open polygon with verticies (at least 3) with a particular color index.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<aVerticies>",
    "documentation": "- Array of point array { <x>, <y> } where"
   },
   {
    "label": "<x>",
    "documentation": "is horizontal position"
   },
   {
    "label": "<y>",
    "documentation": "is vertical position"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   }
  ],
  "name": "gdImageOpenPolygon",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImagePng( <pImage>, <cFile> | <nHandle> [, <nCompressionLevel> ] ) --> NIL",
  "documentation": "Save a PNG image.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<cFile>",
    "documentation": "- Image file name"
   },
   {
    "label": "<nHandle>",
    "documentation": "- File handle"
   },
   {
    "label": "<nCompressionLevel>",
    "documentation": "- a numeric value between 0=no compression and 9=max compression default is -1=auto"
   }
  ],
  "name": "gdImagePng",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImagePolygon( <pImage>, <aVerticies>, <nColor> ) --> NIL",
  "documentation": "Draws a closed polygon with verticies (at least 3) with a particular color index.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<aVerticies>",
    "documentation": "- Array of point array { <x>, <y> } where"
   },
   {
    "label": "<x>",
    "documentation": "is horizontal position"
   },
   {
    "label": "<y>",
    "documentation": "is vertical position"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   }
  ],
  "name": "gdImagePolygon",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageRectangle( <pImage>, <x1>, <y1>, <x2>, <y2>, <nColor> ) --> NIL",
  "documentation": "Draws a rectangle with a particular color index.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<x1>",
    "documentation": "- upper left point horizontal position"
   },
   {
    "label": "<y1>",
    "documentation": "- upper left point vertical position"
   },
   {
    "label": "<x2>",
    "documentation": "- lower right point horizontal position"
   },
   {
    "label": "<y2>",
    "documentation": "- lower right point vertical position"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   }
  ],
  "name": "gdImageRectangle",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageSetAntiAliased( <pImage>, <nColor> ) --> NIL",
  "documentation": "specify the actual foreground color to be used when drawing antialiased lines.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index of filling color"
   }
  ],
  "name": "gdImageSetAntiAliased",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageSetAntiAliasedDontBlend( <pImage>, <nColor> ) --> NIL",
  "documentation": "indicate the special color that the foreground should stand out more clearly against.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index of filling color"
   }
  ],
  "name": "gdImageSetAntiAliasedDontBlend",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageSetBrush( <pImage>, <pBrush> ) --> NIL",
  "documentation": "A \"brush\" is an image used to draw wide, shaped strokes in another image.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<pBrush>",
    "documentation": "- Brush Image pointer"
   }
  ],
  "name": "gdImageSetBrush",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageSetPixel( <pImage>, <x>, <y>, <nColor> ) --> NIL",
  "documentation": "Set a pixel to a particular color index.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<x>",
    "documentation": "- Horizontal position"
   },
   {
    "label": "<y>",
    "documentation": "- Vertical position"
   },
   {
    "label": "<nColor>",
    "documentation": "- Color index"
   }
  ],
  "name": "gdImageSetPixel",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageSetStyle( <pImage>, <aStyle> ) --> NIL",
  "documentation": "set any desired series of colors to be repeated during the drawing of a line.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<aStyle>",
    "documentation": "- Array of colors and special colors used to \"style\" a line"
   }
  ],
  "name": "gdImageSetStyle",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageSetThickness( <pImage>, <nThickness> ) --> NIL",
  "documentation": "determines the width of lines drawn in pixels.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<nThickness>",
    "documentation": "- width of line in pixel"
   }
  ],
  "name": "gdImageSetThickness",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageSetTile( <pImage>, <pTile> ) --> NIL",
  "documentation": "A \"tile\" is an image used to fill an area with a repeated pattern.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<pTile>",
    "documentation": "- Tile Image pointer"
   }
  ],
  "name": "gdImageSetTile",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "gdImageWBmp( <pImage>, <cFile> | <nHandle> [, <nFGcolor> ] ) --> NIL",
  "documentation": "Save a WBMP image.",
  "arguments": [
   {
    "label": "<pImage>",
    "documentation": "- Image pointer"
   },
   {
    "label": "<cFile>",
    "documentation": "- Image file name"
   },
   {
    "label": "<nHandle>",
    "documentation": "- File handle"
   },
   {
    "label": "<nFGcolor>",
    "documentation": "- foreground color value to be used as foreground, the others are background"
   }
  ],
  "name": "gdImageWBmp",
  "return": {
   "name": "",
   "help": "NIL"
  }
 },
 {
  "label": "GetE( <cEnviroment> ) --> cReturn",
  "documentation": "Obtains a system environmental setting.",
  "arguments": [
   {
    "label": "<cEnviroment>",
    "documentation": "Environmental variable to obtain."
   }
  ],
  "name": "GetE",
  "return": {
   "name": "<cReturn>",
   "help": "Value of the Environment Variable."
  }
 },
 {
  "label": "GetEnv( <cEnviroment> ) --> cReturn",
  "documentation": "Obtains a system environmental setting.",
  "arguments": [
   {
    "label": "<cEnviroment>",
    "documentation": "Environmental variable to obtain."
   }
  ],
  "name": "GetEnv",
  "return": {
   "name": "<cReturn>",
   "help": "Value of the Environment Variable."
  }
 },
 {
  "label": "GetPrec() -> nDigits",
  "documentation": "Get precision of math functions",
  "arguments": [],
  "name": "GetPrec",
  "return": {
   "name": "",
   "help": "nDigits        digit count between 1 and 16"
  }
 },
 {
  "label": "gt_AsciiSum( <cStr> ) --> nSum",
  "documentation": "Sum the ASCII values in a string.",
  "arguments": [
   {
    "label": "<cStr>",
    "documentation": "- The string to sum"
   }
  ],
  "name": "gt_AsciiSum",
  "return": {
   "name": "<nSum>",
   "help": "- The sum of all ASCII values in <cStr>."
  }
 },
 {
  "label": "gt_AscPos( <cStr>, <nPos> ) --> nAscVal",
  "documentation": "Return the ASCII value of a specified character in a string",
  "arguments": [
   {
    "label": "<cStr>",
    "documentation": "- The string"
   },
   {
    "label": "<nPos>",
    "documentation": "- The position in <cStr>"
   }
  ],
  "name": "gt_AscPos",
  "return": {
   "name": "<nAscVal>",
   "help": "- The ASCII value of hb_BSubStr( <cStr>, <nPos>, 1 )"
  }
 },
 {
  "label": "gt_AtDiff( <cStr1>, <cStr2> ) --> nPos",
  "documentation": "Return the position where two strings begin to differ",
  "arguments": [
   {
    "label": "<cStr1>",
    "documentation": "- A character string to compare"
   },
   {
    "label": "<cStr2>",
    "documentation": "- The string to compare with"
   }
  ],
  "name": "gt_AtDiff",
  "return": {
   "name": "<nPos>",
   "help": "- The position in <cStr2> where <cStr1> begins to differ"
  }
 },
 {
  "label": "gt_CharEven( <cStr> ) --> cRet",
  "documentation": "Return a string of all the characters in even positions",
  "arguments": [
   {
    "label": "<cStr>",
    "documentation": "- A character string to extract chars from"
   }
  ],
  "name": "gt_CharEven",
  "return": {
   "name": "<cRet>",
   "help": "- A string of all the chars in even positions"
  }
 },
 {
  "label": "gt_CharMix( <cStr1>, <cStr2> ) --> cRet",
  "documentation": "Amalgamate two strings to form the return value",
  "arguments": [
   {
    "label": "<cStr1>",
    "documentation": "- A character string to mix"
   },
   {
    "label": "<cStr2>",
    "documentation": "- A character string to mix with"
   }
  ],
  "name": "gt_CharMix",
  "return": {
   "name": "<cRet>",
   "help": "- A string consisting of all the characters in <cStr1> mixed with all the characters in <cStr2>"
  }
 },
 {
  "label": "gt_CharOdd( <cStr> ) --> cRet",
  "documentation": "Return a string of all the characters in odd positions",
  "arguments": [
   {
    "label": "<cStr>",
    "documentation": "- A character string to extract chars from"
   }
  ],
  "name": "gt_CharOdd",
  "return": {
   "name": "<cRet>",
   "help": "- A string of all the chars in odd positions"
  }
 },
 {
  "label": "gt_ChrCount( <cChr>, <cStr> ) --> nFreq",
  "documentation": "Count the number of times a character appears in a string",
  "arguments": [
   {
    "label": "<cChr>",
    "documentation": "- The character to find the frequence of"
   },
   {
    "label": "<cStr>",
    "documentation": "- The string in which to find the character"
   }
  ],
  "name": "gt_ChrCount",
  "return": {
   "name": "",
   "help": "nFreq   - The number of times <cChr> occurs in <cStr>"
  }
 },
 {
  "label": "gt_ChrFirst( <cChars>, <cStr> ) --> nAsc",
  "documentation": "Find which character occurs first in a string",
  "arguments": [
   {
    "label": "<cChars>",
    "documentation": "- The set of characters to find"
   },
   {
    "label": "<cStr>",
    "documentation": "- The input string"
   }
  ],
  "name": "gt_ChrFirst",
  "return": {
   "name": "<nAsc>",
   "help": "- The ASCII value of the first character in <cChars> which appears first in <cStr>"
  }
 },
 {
  "label": "gt_ChrTotal( <cChrs>, <cStr> ) --> nTotOcc",
  "documentation": "Find number of times a set of characters appears in a string",
  "arguments": [
   {
    "label": "<cChrs>",
    "documentation": "- The set of characters"
   },
   {
    "label": "<cStr>",
    "documentation": "- The string to search"
   }
  ],
  "name": "gt_ChrTotal",
  "return": {
   "name": "<nTotOcc>",
   "help": "- The number of times the characters specified in <cChrs> appears in <cStr>"
  }
 },
 {
  "label": "gt_ClrFlag( <cFlagString>, [<nStart>], [<nEnd>] ) --> cFlagString",
  "documentation": "Set a number of flags to FALSE in a bit flag string.",
  "arguments": [
   {
    "label": "<cFlagString>",
    "documentation": "is a bit flag string created with gt_NewFlag()"
   },
   {
    "label": "<nStart>",
    "documentation": "is the starting flag. This is an optional numeric value. If not supplied it defaults to 1."
   },
   {
    "label": "<nEnd>",
    "documentation": "is the ending flag. This is an optional numeric value. If not supplied it defaults to <nStart>."
   }
  ],
  "name": "gt_ClrFlag",
  "return": {
   "name": "",
   "help": "The bit map string with the new flag settings."
  }
 },
 {
  "label": "gt_IsFlag( <cFlagString>, [<nFlag>] ) --> lSetting",
  "documentation": "Test the setting of a flag in a bit flag string.",
  "arguments": [
   {
    "label": "<cFlagString>",
    "documentation": "is a bit flag string created with gt_NewFlag()"
   },
   {
    "label": "<nFlag>",
    "documentation": "is the flag to be tested."
   }
  ],
  "name": "gt_IsFlag",
  "return": {
   "name": "",
   "help": "A boolean value, TRUE if the flag is on, FALSE if it's off."
  }
 },
 {
  "label": "gt_NewFlag( <nFlagCount> ) --> cFlagString",
  "documentation": "Create a new bit flag string.",
  "arguments": [
   {
    "label": "<nFlagCount>",
    "documentation": "is the number of flags you wish to store."
   }
  ],
  "name": "gt_NewFlag",
  "return": {
   "name": "",
   "help": "A string to hold the bit flags. All flags are set to FALSE."
  }
 },
 {
  "label": "gt_SetFlag( <cFlagString>, [<nStart>], [<nEnd>] ) --> cFlagString",
  "documentation": "Set a number of flags to TRUE in a bit flag string.",
  "arguments": [
   {
    "label": "<cFlagString>",
    "documentation": "is a bit flag string created with gt_NewFlag()"
   },
   {
    "label": "<nStart>",
    "documentation": "is the starting flag. This is an optional numeric value. If not supplied it defaults to 1."
   },
   {
    "label": "<nEnd>",
    "documentation": "is the ending flag. This is an optional numeric value. If not supplied it defaults to <nStart>."
   }
  ],
  "name": "gt_SetFlag",
  "return": {
   "name": "",
   "help": "The bit map string with the new flag settings."
  }
 },
 {
  "label": "gt_StrCount( <cChrs>, <cStr> ) --> nFreq",
  "documentation": "Count the number of times a substring appears in a string",
  "arguments": [
   {
    "label": "<cChrs>",
    "documentation": "- The substring to find the frequence of"
   },
   {
    "label": "<cStr>",
    "documentation": "- The string in which to find the character"
   }
  ],
  "name": "gt_StrCount",
  "return": {
   "name": "<nFreq>",
   "help": "- The number of times <cChrs> occurs in <cStr>"
  }
 },
 {
  "label": "gt_StrCSPN( <cString>, <cSet> ) --> nLength",
  "documentation": "Return length of prefix in string of chars NOT in set.",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "- The string to find the prefix in"
   },
   {
    "label": "<cSet>",
    "documentation": "- The set of characters"
   }
  ],
  "name": "gt_StrCSPN",
  "return": {
   "name": "<nLength>",
   "help": "- The length of a string upto a character in the set"
  }
 },
 {
  "label": "gt_StrDiff( <cStr1>, <cStr2> ) --> cRet",
  "documentation": "Return a string where it begins to differ from another",
  "arguments": [
   {
    "label": "<cStr1>",
    "documentation": "- A character string to compare"
   },
   {
    "label": "<cStr2>",
    "documentation": "- The string to compare with"
   }
  ],
  "name": "gt_StrDiff",
  "return": {
   "name": "<cRet>",
   "help": "- A string beginning at the position in <cStr2> where <cStr1> begins to differ from <cStr1>"
  }
 },
 {
  "label": "gt_StrExpand( <cStr>, [<nNum>], [<cChar>] ) --> cRet",
  "documentation": "Insert fillers between characters in a passed string",
  "arguments": [
   {
    "label": "<cStr1>",
    "documentation": "- A character string to insert chars into"
   },
   {
    "label": "<nNum>",
    "documentation": "- The number of fill characters to insert (default 1)"
   },
   {
    "label": "<cChar>",
    "documentation": "- The fill chararacter (default space)"
   }
  ],
  "name": "gt_StrExpand",
  "return": {
   "name": "<cRet>",
   "help": "- The input string with fill characters inserted between every character in the original."
  }
 },
 {
  "label": "gt_StrLeft( <cStr>, <cChars> ) --> nLen",
  "documentation": "Find length of prefix of a string",
  "arguments": [
   {
    "label": "<cStr>",
    "documentation": "- The input string"
   },
   {
    "label": "<cChars>",
    "documentation": "- The set of characters to find"
   }
  ],
  "name": "gt_StrLeft",
  "return": {
   "name": "",
   "help": "nLen     - The length of the prefix found."
  }
 },
 {
  "label": "gt_StrPBRK( <cStr>, <cSet> ) --> cString",
  "documentation": "Return string after 1st char from a set",
  "arguments": [
   {
    "label": "<cStr>",
    "documentation": "- The input string"
   },
   {
    "label": "<cSet>",
    "documentation": "- The set of characters to find"
   }
  ],
  "name": "gt_StrPBRK",
  "return": {
   "name": "<cString>",
   "help": "- The input string after the first occurance of any character from <cSet>"
  }
 },
 {
  "label": "gt_StrRight( <cStr>, <cChars> ) --> nLen",
  "documentation": "Find length of a suffix of a string",
  "arguments": [
   {
    "label": "<cStr>",
    "documentation": "- The input string"
   },
   {
    "label": "<cChars>",
    "documentation": "- The set of characters to find"
   }
  ],
  "name": "gt_StrRight",
  "return": {
   "name": "<nLen>",
   "help": "- The length of the prefix found."
  }
 },
 {
  "label": "HardCR( <cString> ) --> cConvertedString",
  "documentation": "Replace all soft carriage returns with hard carriages returns.",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "is a string of chars to convert."
   }
  ],
  "name": "HardCR",
  "return": {
   "name": "<cConvertedString>",
   "help": "Transformed string."
  }
 },
 {
  "label": "hb_ADel( <aArray>, [<nPos>], [<lAutoSize>] ) --> aArray",
  "documentation": "Delete an element from an array.",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "Name of array from which an element is to be removed."
   },
   {
    "label": "<nPos>",
    "documentation": "Subscript of the element to be removed. Default value: 1."
   },
   {
    "label": "<lAutoSize>",
    "documentation": "Boolean flag specifying if the array will be resized or not. Default value: .F. (no resize)."
   }
  ],
  "name": "hb_ADel",
  "return": {
   "name": "<aArray>",
   "help": "an array pointer reference."
  }
 },
 {
  "label": "hb_AIns( <aArray>, [<nPos>], [<xValue>], [<lAutoSize>] ) --> aArray",
  "documentation": "Inserts a value at an array subscript position and optionally increases the length of array.",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "The array name into which the value <xValue> will be inserted."
   },
   {
    "label": "<nPos>",
    "documentation": "Subscript position in <aArray>. Default: 1st position"
   },
   {
    "label": "<xValue>",
    "documentation": "Value to be inserted"
   },
   {
    "label": "<lAutoSize>",
    "documentation": "Boolean flag to increase or not the size of <aArray>. Default value: .F."
   }
  ],
  "name": "hb_AIns",
  "return": {
   "name": "",
   "help": "A reference to array <aArray>"
  }
 },
 {
  "label": "hb_AScan( <aArray>, <xSearch>, [<nStart>], [<nCount>], [<lExact>] ) --> nPosition",
  "documentation": "Scan array elements for a specified condition",
  "arguments": [
   {
    "label": "<aArray>",
    "documentation": "Array to be scanned."
   },
   {
    "label": "<xSearch>",
    "documentation": "Expression to search for in <aArray>"
   },
   {
    "label": "<nStart>",
    "documentation": "Beginning subscript position at which to start the search. Default value: 1"
   },
   {
    "label": "<nCount>",
    "documentation": "Number of elements to be scanned within <aArray>. Default value: All elements."
   },
   {
    "label": "<lExact>",
    "documentation": "Boolean flag specifying if an \"Exact\" search will be performed or not. Default value: .F."
   }
  ],
  "name": "hb_AScan",
  "return": {
   "name": "<nPosition>",
   "help": "A numeric value > 0 indicating the array position where <xSearch> was found, or 0 if nothing found."
  }
 },
 {
  "label": "hb_At( <cSearch>, <cString>, [<nStart>], [<nEnd>] ) --> nPos",
  "documentation": "Locates the position of a substring in a main string.",
  "arguments": [
   {
    "label": "<cSearch>",
    "documentation": "Substring to search for"
   },
   {
    "label": "<cString>",
    "documentation": "Main string"
   },
   {
    "label": "<nStart>",
    "documentation": "First position to search in <cString>, by default 1"
   },
   {
    "label": "<nEnd>",
    "documentation": "End position to search, by default <cString> length"
   }
  ],
  "name": "hb_At",
  "return": {
   "name": "",
   "help": "hb_At() return the starting position of the first occurrence of the substring in the main string"
  }
 },
 {
  "label": "hb_AtI( <cSearch>, <cString>, [<nStart>], [<nEnd>] ) --> nPos",
  "documentation": "Locates the position of a substring in a main string.",
  "arguments": [
   {
    "label": "<cSearch>",
    "documentation": "the sub-string to search for"
   },
   {
    "label": "<cString>",
    "documentation": "The main string to search into, for <cSearch>"
   },
   {
    "label": "<nStart>",
    "documentation": "Beginning search position into <cString>, default: 1"
   },
   {
    "label": "<nEnd>",
    "documentation": "Ending search position, default: Length of <cString> (i.e. entire <cString>)"
   }
  ],
  "name": "hb_AtI",
  "return": {
   "name": "",
   "help": "hb_AtI() returns the position (if any), into main string, where first time the substring appears."
  }
 },
 {
  "label": "hb_ATokens( <cString>, [<cDelim>|<lEOL>], [<lSkipStrings>], ; [<lDoubleQuoteOnly>] ) --> aTokens",
  "documentation": "Parses a complex string (e.g. a sentence or multi-line text) into individual tokens (words or other string chunks depending on delimiter used).",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Complex string to be parsed."
   },
   {
    "label": "<cDelim>",
    "documentation": "|<lEOL Character(s) used as delimiter of separate tokens. If <lEOL> flag defined instead of <cDelim>, then end of line marker(s) will be used as delimiter."
   },
   {
    "label": "<lSkipStrings>",
    "documentation": "Boolean flag indicating if quoted substrings will be tokenized or not."
   },
   {
    "label": "<lDoubleQuoteOnly>",
    "documentation": "Boolean flag indicating that only double-quoted substrings will be tokenized."
   }
  ],
  "name": "hb_ATokens",
  "return": {
   "name": "<aTokens>",
   "help": "A character array, filled with the individual tokens found."
  }
 },
 {
  "label": "hb_cdpSelect( [<cNewLang>] ) --> cOldLang",
  "documentation": "Select the active code page by language ID",
  "arguments": [
   {
    "label": "<cNewLang>",
    "documentation": "The optional ID of the language module. Possible values for <cNewLang> are below as defined in the Codepage library, sorted by language."
   },
   {
    "label": "<table>",
    "documentation": " Language              Codepage       <cNewLang> Bulgarian             866            BG866 Bulgarian             ISO-8859-5     BGISO Bulgarian             MIK            BGMIK Bulgarian             Windows-1251   BGWIN Croatian              437            HR437 Croatian              852            HR852 Croatian              Windows-1250   HRWIN Czech                 852            CS852 Czech                 ISO-8859-2     CSISO Czech                 KAM            CSKAM Czech                 Windoes-1250   CSWIN English               437            EN French                850            FR850 German                850            DE850 German                ISO-8859-1     DEWIN Greek                 737            EL737 Greek                 Windows-1253   ELWIN Hungarian (ntxhu852)  852            HU852C Hungarian (sixhu852)  852            HU852 Hungarian (sixhu852)  CWI-2          HUCWI Hungarian             ISO-8859-2     HUISO Hungarian             Windows-1250   HUWIN Italian               437            IT437 Italian               850            IT850 Italian               ISO-8859-1b    ITISB Italian               ISO-8859-1     ITISO Lithuanian            Windows-1257   LTWIN Polish                852            PL852 Polish                ISO-8859-2     PLISO Polish                Mazowia        PLMAZ Polish                Windows-1250   PLWIN Portuguese            850            PT850 Portuguese            ISO-8859-1     PTISO Russian               866            RU866 Russian               KOI-8          RUKOI8 Russian               Windows-1251   RU1251 Serbian               Windows-1251   SRWIN Slovak                852            SK852 Slovak                ISO-8859-2     SKISO Slovak                Kamenicky      SKKAM Slovak                Windows-1250   SKWIN Slovenian             437            SL437 Slovenian             852            SL852 Slovenian             ISO-8859-2     SLISO Slovenian             Windows-1250   SLWIN Spanish               850            ES850 Spanish               ISO-8859-1     ESWIN Spanish Modern        ISO-8859-1     ESMWIN Swedish               850            SV850 Swedish (Clipper)     437            SV437C Swedish               ISO-8859-1     SVWIN Turkish               857            TR857 Turkish               Windows-1254   TRWIN Ukrainian             866            UA866 Ukrainian             KOI-8U         UAKOI8 Ukrainian             Windows-1251   UA1251"
   },
   {
    "label": "</table>",
    "documentation": ""
   }
  ],
  "name": "hb_cdpSelect",
  "return": {
   "name": "<cOldLang>",
   "help": "The old language identifier"
  }
 },
 {
  "label": "hb_ColorIndex( <cColorSpec>, <nIndex> ) --> cColor",
  "documentation": "Extract one color from a full color-spec string.",
  "arguments": [
   {
    "label": "<cColorSpec>",
    "documentation": "is a color list"
   },
   {
    "label": "<nIndex>",
    "documentation": "is the position of the color item to be extracted, the first position is the zero."
   }
  ],
  "name": "hb_ColorIndex",
  "return": {
   "name": "",
   "help": "The selected color string, or if anything goes wrong, an empty string."
  }
 },
 {
  "label": "hb_DiskSpace( [<cDrive>] [, <nType>] ) --> nDiskBytes",
  "documentation": "Get the amount of space available on a disk",
  "arguments": [
   {
    "label": "<cDrive>",
    "documentation": "The drive letter you are requesting info on. The default is A:"
   },
   {
    "label": "<nType>",
    "documentation": "The type of space being requested. The default is HB_DISK_AVAIL."
   }
  ],
  "name": "hb_DiskSpace",
  "return": {
   "name": "<nDiskBytes>",
   "help": "The number of bytes on the requested disk that match the requested type."
  }
 },
 {
  "label": "hb_DToT( <dDate> [, <cTime|nSeconds>] ) --> <tDateTime>",
  "documentation": "Create a <tDateTime> value from a <dDate> parameter",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "Any valid date expression. Optional: <cTime|nSeconds> representing a time of the day value."
   },
   {
    "label": "<cTime>",
    "documentation": "is a string in a valid time format: \"hh:mm:ss.nnn\"."
   },
   {
    "label": "<nSeconds>",
    "documentation": "is a numeric value in seconds in the range from 0 to 86399.999~ ( 60 secs * 60 mins * 24 hours - 1 millisecond )"
   }
  ],
  "name": "hb_DToT",
  "return": {
   "name": "<tDateTime>",
   "help": "a dateTime value"
  }
 },
 {
  "label": "hb_eol() --> cString",
  "documentation": "Returns the newline character(s) to use with the current OS",
  "arguments": [],
  "name": "hb_eol",
  "return": {
   "name": "<cString>",
   "help": "A character string containing the character or characters required to move the screen cursor or print head to the start of a new line."
  }
 },
 {
  "label": "hb_FEof( <nHandle> ) --> lIsEof",
  "documentation": "Check for end-of-file.",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "The handle of an open file."
   }
  ],
  "name": "hb_FEof",
  "return": {
   "name": "<lIsEof>",
   "help": ".T. if the file handle is at end-of-file, otherwise .F."
  }
 },
 {
  "label": "hb_FLock( <nHandle>, <nOffset>, <nBytes> [, <nType ] ) --> lSuccess",
  "documentation": "Locks part or all of any file",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "OS file handle set>  Offset of the first byte of the region to be locked."
   },
   {
    "label": "<nBytes>",
    "documentation": "Number of bytes to be locked. e>    The type (read or write) of lock requested."
   }
  ],
  "name": "hb_FLock",
  "return": {
   "name": "<lSuccess>",
   "help": ".T. if the lock was obtained, else .F."
  }
 },
 {
  "label": "hb_FUnlock( <nHandle>, <nOffset>, <nBytes> ) --> lSuccess",
  "documentation": "Unlocks part or all of any file",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "OS file handle set>  Offset of the first byte of the region to be locked."
   },
   {
    "label": "<nBytes>",
    "documentation": "Number of bytes to be locked."
   }
  ],
  "name": "hb_FUnlock",
  "return": {
   "name": "<lSuccess>",
   "help": ".T. if the lock was removed, else .F."
  }
 },
 {
  "label": "hb_gcAll()",
  "documentation": "Scans the memory and releases all garbage memory blocks.",
  "arguments": [],
  "name": "hb_gcAll"
 },
 {
  "label": "hb_GetEnv( <cEnviroment>, [<cDefaultValue>] ) --> cReturn",
  "documentation": "Obtains a system environmental setting.",
  "arguments": [
   {
    "label": "<cEnviroment>",
    "documentation": "Environmental variable to obtain."
   },
   {
    "label": "<cDefaultValue>",
    "documentation": "Optional value to return if <cEnvironment> is not found."
   }
  ],
  "name": "hb_GetEnv",
  "return": {
   "name": "<cReturn>",
   "help": "Value of the environment variable or <cDefaultValue> or an empty string."
  }
 },
 {
  "label": "hb_GetZipComment( <szFile> ) --> <szComment>",
  "documentation": "Return the comment of an zip file",
  "arguments": [
   {
    "label": "<szFile>",
    "documentation": "File to get the comment from"
   }
  ],
  "name": "hb_GetZipComment",
  "return": {
   "name": "<szComment>",
   "help": "The comment that was stored in <szFile>"
  }
 },
 {
  "label": "hb_HAllocate( <hTable>, <nItems> )",
  "documentation": "Preallocates a hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<nItems>",
    "documentation": "number of items to preallocate in the hash table"
   }
  ],
  "name": "hb_HAllocate"
 },
 {
  "label": "hb_Hash( [ <Key1>, <Value1> ], [ <KeyN>, <ValueN> ], ... ) -> hTable",
  "documentation": "Returns a hash table",
  "arguments": [
   {
    "label": "<Key1>",
    "documentation": "entry key; can be of type: number, date, datetime, string, pointer"
   },
   {
    "label": "<Value1>",
    "documentation": "entry value; can be of type: block, string, numeric, date/datetime, logical, nil, pointer, array, hash table Equivalent to: ``` hTable := { => } hTable := { <Key1> => <Value1>, <Key2> => <Value2>, <KeyN> => <ValueN> } ```"
   }
  ],
  "name": "hb_Hash",
  "return": {
   "name": "",
   "help": "A hash table built from the initial key/value pairs"
  }
 },
 {
  "label": "hb_HAutoAdd( <hTable>, [<lFlag>] ) -> <lPreviousFlag>",
  "documentation": "Sets the 'auto add' flag for the hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<lFlag>",
    "documentation": "a logical value indicating to turn on or off the 'auto add' flag of the hash table"
   }
  ],
  "name": "hb_HAutoAdd",
  "return": {
   "name": "",
   "help": "The previous value of the 'auto add' flag"
  }
 },
 {
  "label": "hb_HBinary( <hTable>, [<lFlag>] ) -> <lPreviousFlag>",
  "documentation": "Sets the 'binary' flag for the hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<lFlag>",
    "documentation": "a logical value indicating to turn on or off the 'binary' flag of the hash table"
   }
  ],
  "name": "hb_HBinary",
  "return": {
   "name": "",
   "help": "The previous value of the 'binary' flag"
  }
 },
 {
  "label": "hb_HCaseMatch( <hTable>, [<lFlag>] ) -> <lPreviousFlag>",
  "documentation": "Sets the 'case match' flag for the hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<lFlag>",
    "documentation": "a logical value indicating to turn on or off the 'case match' flag of the hash table"
   }
  ],
  "name": "hb_HCaseMatch",
  "return": {
   "name": "",
   "help": "The previous value of the 'case match' flag"
  }
 },
 {
  "label": "hb_HClone( <hTable> ) -> <hsDestination>",
  "documentation": "Creates a copy of a hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   }
  ],
  "name": "hb_HClone",
  "return": {
   "name": "",
   "help": "A cloned copy of the hash table"
  }
 },
 {
  "label": "hb_HCopy( <hsDestination>, <hsSource>, [<nStart>], [<nCount>] ) -> <hsDestination>",
  "documentation": "Adds entries from the source hash table to the destination hash table",
  "arguments": [
   {
    "label": "<hsDestination>",
    "documentation": "a destination hash table"
   },
   {
    "label": "<hsSource>",
    "documentation": "a source hash table"
   },
   {
    "label": "<nStart>",
    "documentation": "starting index, defaults to 1 if omitted"
   },
   {
    "label": "<nCount>",
    "documentation": "counter, defaults to (length) - <nStart> is omitted"
   }
  ],
  "name": "hb_HCopy",
  "return": {
   "name": "",
   "help": "The destination hash table"
  }
 },
 {
  "label": "hb_HDefault( <hTable>, <DefaultValue> ) -> <OldDefaultValue>",
  "documentation": "Returns/sets a default value for a hash table.",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<DefaultValue>",
    "documentation": ""
   }
  ],
  "name": "hb_HDefault",
  "return": {
   "name": "",
   "help": "The previous default value assigned to the hash table"
  }
 },
 {
  "label": "hb_HDel( <hTable>, <Key> ) -> <hTable>",
  "documentation": "Removes a key/value pair from a hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<Key>",
    "documentation": "key to be removed from the hash table; can be of type: number, date, datetime, string, pointer"
   }
  ],
  "name": "hb_HDel",
  "return": {
   "name": "",
   "help": "The hash table"
  }
 },
 {
  "label": "hb_HDelAt( <hTable>, <nPosition> ) -> <hTable>",
  "documentation": "Removes an entry from a hash table based on its index position",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<nPosition>",
    "documentation": "the position of an entry within the hash table that will be deleted"
   }
  ],
  "name": "hb_HDelAt",
  "return": {
   "name": "",
   "help": "The hash table"
  }
 },
 {
  "label": "hb_HEval( <hTable>, <bBlock>, [<nStart>], [<nCount>] ) -> <hTable>",
  "documentation": "Evaluate a code block across the contents of a hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<bBlock>",
    "documentation": "code block to be evaluated"
   },
   {
    "label": "<nStart>",
    "documentation": "starting index, defaults to 1 if omitted"
   },
   {
    "label": "<nCount>",
    "documentation": "counter, defaults to (length) - <nStart> is omitted"
   }
  ],
  "name": "hb_HEval",
  "return": {
   "name": "",
   "help": "The hash table"
  }
 },
 {
  "label": "hb_HFill( <hTable>, <Value> ) -> <hTable>",
  "documentation": "Fills a hash table with a value",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<Value>",
    "documentation": "fill value; can be of type: block, string, numeric, date/datetime, logical, nil, pointer, array, hash table"
   }
  ],
  "name": "hb_HFill",
  "return": {
   "name": "",
   "help": "The hash table"
  }
 },
 {
  "label": "hb_HGet( <hTable>, <Key> ) -> <Value>",
  "documentation": "Returns a hash value",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<Key>",
    "documentation": "key to be retrieve from the hash table; can be of type: number, date, datetime, string, pointer"
   }
  ],
  "name": "hb_HGet",
  "return": {
   "name": "",
   "help": "Either the value within the hash table for the given key. An array access error occurs of the key is not found"
  }
 },
 {
  "label": "hb_HGetDef( <hTable>, <Key>, [<DefaultValue>] ) -> <Value>",
  "documentation": "Returns a hash value, or a default value if the key is not present",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<Key>",
    "documentation": "key to be retrieve from the hash table; can be of type: number, date, datetime, string, pointer"
   },
   {
    "label": "<DefaultValue>",
    "documentation": "a default value to be returned if the hash table does not contain the key"
   }
  ],
  "name": "hb_HGetDef",
  "return": {
   "name": "",
   "help": "Either the value within the hash table for the given key, or the default value."
  }
 },
 {
  "label": "hb_HHasKey( <hTable>, <Key> ) -> lExists",
  "documentation": "Determines whether a hash table has an entry with a give key",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<Key>",
    "documentation": "a key value to be queried for; can be of type: number, date, datetime, string, pointer"
   }
  ],
  "name": "hb_HHasKey",
  "return": {
   "name": "",
   "help": "A logical value indicating whether the key exists within the hash table"
  }
 },
 {
  "label": "hb_HKeyAt( <hTable>, <nPosition> ) -> <Key>",
  "documentation": "Gets a hash table key at a given position",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<nPosition>",
    "documentation": "the position of an entry within the hash table that will be returned"
   }
  ],
  "name": "hb_HKeyAt",
  "return": {
   "name": "",
   "help": "The key at the given position of the hash table; the type will be one: number, date, datetime, string, pointer"
  }
 },
 {
  "label": "hb_HKeys( <hTable> ) -> <aKeys>",
  "documentation": "Returns an array of the keys of a hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   }
  ],
  "name": "hb_HKeys",
  "return": {
   "name": "",
   "help": "An array of all the hash table keys"
  }
 },
 {
  "label": "hb_HMerge( <hsDestination>, <hsSource>, <bBlock>|<nPosition> ) -> <hsDestination>",
  "documentation": "Merges a source hash table into a destination hash table",
  "arguments": [
   {
    "label": "<hsDestination>",
    "documentation": "a destination hash table"
   },
   {
    "label": "<hsSource>",
    "documentation": "a source hash table"
   },
   {
    "label": "<bBlock>",
    "documentation": "a code block that will be evaluated for each entry within the source hash table; the code block will be passed the entry key, value and position; if the code block returns a true value, the entry will be added to the destination hash table"
   },
   {
    "label": "<nPosition>",
    "documentation": "the position of an entry within the source hash table that will be appended to the destination hash table TODO: the source code passes either a number or HB_HASH_UNION; research this"
   }
  ],
  "name": "hb_HMerge",
  "return": {
   "name": "",
   "help": "The destination hash table with the contents of the source hash table merged"
  }
 },
 {
  "label": "hb_HPairAt( <hTable>, <nPosition> ) -> <aKeyValue>",
  "documentation": "Returns a two-dimensional array of a hash table entry key/value pair",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<nPosition>",
    "documentation": "the position of an entry within the hash table that will be returned"
   }
  ],
  "name": "hb_HPairAt",
  "return": {
   "name": "",
   "help": "A two-dimensional array of the key/value pair entry of the hash table"
  }
 },
 {
  "label": "hb_HPos( <hTable>, <Key> ) -> nPosition",
  "documentation": "Locates the index of a key within a hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<Key>",
    "documentation": "key for which its position is to be determined; can be of type: number, date, datetime, string, pointer"
   }
  ],
  "name": "hb_HPos",
  "return": {
   "name": "",
   "help": "A integer number being the index position of the key within the hash table. TODO: what is the return value if the key does not exist?  zero (0)?  RTE?"
  }
 },
 {
  "label": "hb_HScan( <hTable>, <Value>, [<nStart>], [<nCount>, [<lExact>] ) -> nPosition",
  "documentation": "Scans a hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<Value>",
    "documentation": "to be located within the hash table"
   },
   {
    "label": "<nStart>",
    "documentation": "starting index, defaults to 1 if omitted"
   },
   {
    "label": "<nCount>",
    "documentation": "counter, defaults to (length) - <nStart> is omitted"
   },
   {
    "label": "<lExact>",
    "documentation": "logical value indicating whether the comparison is to be be exact or not"
   }
  ],
  "name": "hb_HScan",
  "return": {
   "name": "",
   "help": "The position of the located value within the hash table, or zero (0) if not found."
  }
 },
 {
  "label": "hb_HSet( <hTable>, <Key>, <Value> ) -> <hTable>",
  "documentation": "Sets a hash value",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<Key>",
    "documentation": "the key of the entry to be set; can be of type: number, date, datetime, string, pointer"
   },
   {
    "label": "<Value>",
    "documentation": "the entry value"
   }
  ],
  "name": "hb_HSet",
  "return": {
   "name": "",
   "help": "The hash table"
  }
 },
 {
  "label": "hb_HSort( <hTable> ) -> <hsSortedTable>",
  "documentation": "Reorganizes the internal list of the hash table to be sorted",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   }
  ],
  "name": "hb_HSort",
  "return": {
   "name": "",
   "help": "The hash table sorted TODO: is the original table altered?"
  }
 },
 {
  "label": "hb_HValueAt( <hTable>, <nPosition>, [<NewValue>] ) -> <Value>",
  "documentation": "Gets/sets a hash value at a given position",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   },
   {
    "label": "<nPosition>",
    "documentation": "the position of an entry within the hash table that will be returned"
   },
   {
    "label": "<NewValue>",
    "documentation": "a new value to be assigned to the hash table at the given position"
   }
  ],
  "name": "hb_HValueAt",
  "return": {
   "name": "",
   "help": "The existing value, or the new value if it is given"
  }
 },
 {
  "label": "hb_HValues( <hTable> ) -> <aValues>",
  "documentation": "Returns an array of the values of a hash table",
  "arguments": [
   {
    "label": "<hTable>",
    "documentation": "a hash table"
   }
  ],
  "name": "hb_HValues",
  "return": {
   "name": "",
   "help": "An array of all the hash values"
  }
 },
 {
  "label": "hb_idleAdd( <bAction> ) --> nHandle",
  "documentation": "Adds the background task.",
  "arguments": [
   {
    "label": "<bAction>",
    "documentation": "is a codeblock that will be executed during idle states. There are no arguments passed to this codeblock during evaluation."
   }
  ],
  "name": "hb_idleAdd",
  "return": {
   "name": "<nHandle>",
   "help": "The handle (an integer value) that identifies the task. This handle can be used for deleting the task."
  }
 },
 {
  "label": "hb_idleDel( <nHandle> ) --> bAction",
  "documentation": "Removes the background task from the list of tasks.",
  "arguments": [
   {
    "label": "<nHandle>",
    "documentation": "is the identifier of the task returned by the hb_idleAdd() function."
   }
  ],
  "name": "hb_idleDel",
  "return": {
   "name": "<bAction>",
   "help": "NIL if invalid handle is passed or a codeblock that was passed to hb_idleAdd() function"
  }
 },
 {
  "label": "hb_idleState()",
  "documentation": "Evaluates a single background task and calls the garbage collector.",
  "arguments": [],
  "name": "hb_idleState"
 },
 {
  "label": "hb_inetAccept( <socket> ) --> <SOCKET>",
  "documentation": "Wait until a socket is ready",
  "arguments": [],
  "name": "hb_inetAccept",
  "return": {
   "name": "<socket>",
   "help": "a socket previously created / opened"
  }
 },
 {
  "label": "hb_inetAddress( <socket> ) --> cResult",
  "documentation": "Get a remote server address",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetAddress",
  "return": {
   "name": "",
   "help": "Server address"
  }
 },
 {
  "label": "hb_inetCleanup()",
  "documentation": "Terminate Harbour INET support",
  "arguments": [],
  "name": "hb_inetCleanup"
 },
 {
  "label": "hb_inetClearError( <socket> )",
  "documentation": "Clear the socket error value",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetClearError"
 },
 {
  "label": "hb_inetClearPeriodCallback( <socket> )",
  "documentation": "Clear the periodic callback value of a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetClearPeriodCallback"
 },
 {
  "label": "hb_inetClearTimeLimit( <socket> )",
  "documentation": "Clear the time limit value of a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetClearTimeLimit"
 },
 {
  "label": "hb_inetClearTimeout( <socket> )",
  "documentation": "Clear the timeout value of a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetClearTimeout"
 },
 {
  "label": "hb_inetClose( <socket> ) --> nResult",
  "documentation": "Close an INET socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetClose",
  "return": {
   "name": "",
   "help": "Returns 0 on success or -1 on error; on error, the error code is set; (actually, on success the socket error code is set to 1 -- socket closed )"
  }
 },
 {
  "label": "hb_inetConnect( <cAddress>, <nPort> ) --> <SOCKET>  hb_inetConnect( <cAddress>, <nPort>, <socket> ) --> NIL",
  "documentation": "Connect a socket to a remote server by IP address or name",
  "arguments": [
   {
    "label": "<cAddress>",
    "documentation": ""
   },
   {
    "label": "<nPort>",
    "documentation": ""
   },
   {
    "label": "<socket>",
    "documentation": ""
   }
  ],
  "name": "hb_inetConnect",
  "return": {
   "name": "",
   "help": "(First form) INET socket (Second form has no return value)"
  }
 },
 {
  "label": "hb_inetConnectIP( <cAddress>, <nPort> ) --> <SOCKET>  hb_inetConnectIP( <cAddress>, <nPort>, <socket> ) --> NIL",
  "documentation": "Connect to a remote server by IP address",
  "arguments": [
   {
    "label": "<cAddress>",
    "documentation": ""
   },
   {
    "label": "<nPort>",
    "documentation": ""
   },
   {
    "label": "<socket>",
    "documentation": ""
   }
  ],
  "name": "hb_inetConnectIP",
  "return": {
   "name": "",
   "help": "(First form) INET socket (Second form has no return value)"
  }
 },
 {
  "label": "hb_inetCount( <socket> ) --> nResult",
  "documentation": "Get the number of bytes last read or sent",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetCount",
  "return": {
   "name": "",
   "help": "Last socket operation character count"
  }
 },
 {
  "label": "hb_inetCreate( [ <nTimeout> ] ) --> <SOCKET>",
  "documentation": "Create an INET socket",
  "arguments": [
   {
    "label": "<nTimeout>",
    "documentation": "Socket timeout (optional) TODO: what is the scale (seconds, milliseconds?)"
   }
  ],
  "name": "hb_inetCreate",
  "return": {
   "name": "",
   "help": "An INET socket"
  }
 },
 {
  "label": "hb_inetCRLF() --> cResult",
  "documentation": "Get a CRLF sequence for internet protocols",
  "arguments": [],
  "name": "hb_inetCRLF",
  "return": {
   "name": "",
   "help": "Internet CRLF sequence"
  }
 },
 {
  "label": "hb_inetDataReady( <socket>, [ <nMillisec> ] ) --> nResult",
  "documentation": "Get whether there is data ready in a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<nMillisec>",
    "documentation": ""
   }
  ],
  "name": "hb_inetDataReady",
  "return": {
   "name": "",
   "help": "If there is data available 1 (one) is returned, 0 (zero) if there is no data and -1 if there is an  error."
  }
 },
 {
  "label": "hb_inetDGram( [<lBroadcast>] ) --> <SOCKET>",
  "documentation": "Create a datagram socket",
  "arguments": [
   {
    "label": "<lBroadcast>",
    "documentation": ""
   }
  ],
  "name": "hb_inetDGram",
  "return": {
   "name": "",
   "help": "An INET socket"
  }
 },
 {
  "label": "hb_inetDGramBind( <nPort>, [<cAddress> [, <lBroadcast>] ] ) --> <SOCKET>",
  "documentation": "Create a bound datagram socket",
  "arguments": [
   {
    "label": "<nPort>",
    "documentation": ""
   },
   {
    "label": "<cAddress>",
    "documentation": ""
   },
   {
    "label": "<bBroadcast>",
    "documentation": ""
   }
  ],
  "name": "hb_inetDGramBind",
  "return": {
   "name": "",
   "help": "An INET socket"
  }
 },
 {
  "label": "hb_inetDGramRecv( <socket>, @<cBuffer> [, <nSize> ] ) --> nBytesRead",
  "documentation": "Get data from a datagram socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<cBuffer>",
    "documentation": "is the target buffer and must be passed by reference"
   },
   {
    "label": "<nSize>",
    "documentation": ""
   }
  ],
  "name": "hb_inetDGramRecv",
  "return": {
   "name": "",
   "help": "Returns number of bytes read, or -1 on error"
  }
 },
 {
  "label": "hb_inetDGramSend( <socket>, <cAddress>, <nPort>, <cBuffer> [, <nSize> ] ) --> nBytesSent",
  "documentation": "Send data to a datagram socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<cAddress>",
    "documentation": ""
   },
   {
    "label": "<nPort>",
    "documentation": ""
   },
   {
    "label": "<cBuffer>",
    "documentation": ""
   },
   {
    "label": "<nSize>",
    "documentation": ""
   }
  ],
  "name": "hb_inetDGramSend",
  "return": {
   "name": "",
   "help": "Returns number of bytes sent, or -1 on error"
  }
 },
 {
  "label": "hb_inetErrorCode( <socket> ) --> nResult",
  "documentation": "Get the last INET error code",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetErrorCode",
  "return": {
   "name": "",
   "help": "Last error code"
  }
 },
 {
  "label": "hb_inetErrorDesc( <socket> ) --> cResult",
  "documentation": "Get the last INET error code description",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetErrorDesc",
  "return": {
   "name": "",
   "help": "System-dependent error string"
  }
 },
 {
  "label": "hb_inetFD( <socket> [, <lNoSocket> ] ) --> nResult",
  "documentation": "?",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<lNoSocket>",
    "documentation": ""
   }
  ],
  "name": "hb_inetFD",
  "return": {
   "name": "",
   "help": "?"
  }
 },
 {
  "label": "hb_inetGetAlias( <cName> ) --> aHosts",
  "documentation": "Get an array of aliases of a server",
  "arguments": [
   {
    "label": "<cName>",
    "documentation": ""
   }
  ],
  "name": "hb_inetGetAlias",
  "return": {
   "name": "",
   "help": "Array of server aliases"
  }
 },
 {
  "label": "hb_inetGetHosts( <cName> ) --> aHosts",
  "documentation": "Get an array of IP addresses of a host",
  "arguments": [
   {
    "label": "<cName>",
    "documentation": ""
   }
  ],
  "name": "hb_inetGetHosts",
  "return": {
   "name": "",
   "help": "An array of IP addresses"
  }
 },
 {
  "label": "hb_inetGetRcvBufSize( <socket> ) --> nResult",
  "documentation": "Get the socket receive buffer size",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetGetRcvBufSize",
  "return": {
   "name": "",
   "help": "Returns the socket receive buffer size or -1 if the socket is closed or an error occurs"
  }
 },
 {
  "label": "hb_inetGetSndBufSize( <socket> ) --> nResult",
  "documentation": "Get the socket send buffer size",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetGetSndBufSize",
  "return": {
   "name": "",
   "help": "Returns the socket send buffer size or -1 if the socket is closed or an error occurs"
  }
 },
 {
  "label": "hb_inetInit() --> lResult",
  "documentation": "Activate Harbour INET support",
  "arguments": [],
  "name": "hb_inetInit",
  "return": {
   "name": "",
   "help": "Returns .T. or .F. whether the internal INET system was successfully initialized"
  }
 },
 {
  "label": "hb_inetIsSocket( <socket> ) --> lResult",
  "documentation": "Get whether a variable is a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetIsSocket",
  "return": {
   "name": "",
   "help": "Returns whether the passed parameter is a socket"
  }
 },
 {
  "label": "hb_inetPeriodCallback( <socket> [, <xCallback> ] ) --> xPreviousCallback",
  "documentation": "Get or change the periodic callback value of a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<xCallback>",
    "documentation": "a new periodic callback"
   }
  ],
  "name": "hb_inetPeriodCallback",
  "return": {
   "name": "",
   "help": "The previous periodic callback value"
  }
 },
 {
  "label": "hb_inetPort( <socket> ) --> cResult",
  "documentation": "Get the port a socket is bound to.",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetPort",
  "return": {
   "name": "",
   "help": "Port name the socket is bound to."
  }
 },
 {
  "label": "hb_inetRecv( <socket>, @<cResult>, [ <nAmount> ] ) --> nResult",
  "documentation": "Read from a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<cResult>",
    "documentation": "is the target buffer and must be passed by reference"
   },
   {
    "label": "<nAmount>",
    "documentation": "is the upper limit of characters to be read from the socket. If not passed this defaults to the length of <cResult>"
   }
  ],
  "name": "hb_inetRecv",
  "return": {
   "name": "",
   "help": "The number of the characters read from the socket."
  }
 },
 {
  "label": "hb_inetRecvAll( <socket>, @<cResult>, [ <nAmount> ] ) --> nResult",
  "documentation": "Read from a socket without blocking",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<cResult>",
    "documentation": "is the target buffer and must be passed by reference"
   },
   {
    "label": "<nAmount>",
    "documentation": "is the upper limit of characters to be read from the socket. If not passed this defaults to the length of <cResult>"
   }
  ],
  "name": "hb_inetRecvAll",
  "return": {
   "name": "",
   "help": "The number of the characters read from the socket. Might be less than <nAmount> on premature socket closing or on network error."
  }
 },
 {
  "label": "hb_inetRecvEndblock( <socket> [, <cBlock >[, @<nBytesRead> [, <nMaxLength> [, <nBufSize> ]]]] ) --> cResult",
  "documentation": "Read a block from a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<cBlock>",
    "documentation": ""
   },
   {
    "label": "<nBytesRead>",
    "documentation": ""
   },
   {
    "label": "<nMaxLength>",
    "documentation": ""
   },
   {
    "label": "<nBufSize>",
    "documentation": ""
   }
  ],
  "name": "hb_inetRecvEndblock",
  "return": {
   "name": "",
   "help": "Block read"
  }
 },
 {
  "label": "hb_inetRecvLine( <socket> [, @<nBytesRead>, [, <nMaxLength> [, <nBufSize> ]]] ) --> cResult",
  "documentation": "Read a line from a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<nBytesRead>",
    "documentation": "must be passed by reference"
   },
   {
    "label": "<nMaxLength>",
    "documentation": ""
   },
   {
    "label": "<nBufSize>",
    "documentation": ""
   }
  ],
  "name": "hb_inetRecvLine",
  "return": {
   "name": "",
   "help": "Line read"
  }
 },
 {
  "label": "hb_inetSend( <socket>, <cBuffer> [, <nLength> ] ) --> nResult",
  "documentation": "Sent data through a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<cBuffer>",
    "documentation": ""
   },
   {
    "label": "<nLength>",
    "documentation": ""
   }
  ],
  "name": "hb_inetSend",
  "return": {
   "name": "",
   "help": "The amount of data written, 0 (zero) if the socket is closed, or -1 on an error"
  }
 },
 {
  "label": "hb_inetSendAll( <socket>, <cBuffer> [, <nLength> ] ) --> nResult",
  "documentation": "Send data through a socket with blocking",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<cBuffer>",
    "documentation": ""
   },
   {
    "label": "<nLength>",
    "documentation": ""
   }
  ],
  "name": "hb_inetSendAll",
  "return": {
   "name": "",
   "help": "The amount of data written, 0 (zero) if the socket is closed, or -1 on an error"
  }
 },
 {
  "label": "hb_inetServer( <port> [, <cBindAddr> [, <nListenLimit> ]]  ) --> <SOCKET>",
  "documentation": "Create a socket bound to a port",
  "arguments": [
   {
    "label": "<port>",
    "documentation": ""
   },
   {
    "label": "<cBindAddr>",
    "documentation": ""
   },
   {
    "label": "<nListenLimit>",
    "documentation": "is an internal parameter and rarely needs to be passed, defaults to 10"
   }
  ],
  "name": "hb_inetServer",
  "return": {
   "name": "",
   "help": "An INET socket"
  }
 },
 {
  "label": "hb_inetSetRcvBufSize( <socket>, <nSize> ) --> nSize",
  "documentation": "Set the receive buffer size of a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<nSize>",
    "documentation": ""
   }
  ],
  "name": "hb_inetSetRcvBufSize",
  "return": {
   "name": "",
   "help": "Returns the passed <nSize> or -1 on error"
  }
 },
 {
  "label": "hb_inetSetSndBufSize( <socket>, <nSize> ) --> nSize",
  "documentation": "Set the send buffer size of a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<nSize>",
    "documentation": ""
   }
  ],
  "name": "hb_inetSetSndBufSize",
  "return": {
   "name": "",
   "help": "Returns the passed <nSize> or -1 on error"
  }
 },
 {
  "label": "hb_inetstatus( <socket> ) --> nResult",
  "documentation": "Get the status of a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   }
  ],
  "name": "hb_inetstatus",
  "return": {
   "name": "",
   "help": "Returns 1 (one) if the socket exists, -1 if it does not"
  }
 },
 {
  "label": "hb_inetTimeLimit( <socket> [, <nTimeLimit> ) --> NIL",
  "documentation": "Get or change the time limit value of a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<nTimeLimit>",
    "documentation": ""
   }
  ],
  "name": "hb_inetTimeLimit",
  "return": {
   "name": "",
   "help": "Returns the previous time limit value of the socket"
  }
 },
 {
  "label": "hb_inetTimeout( <socket> [, <nTimeout> ] ) --> nPreviousTimeout",
  "documentation": "Get or change the timeout value of a socket",
  "arguments": [
   {
    "label": "<socket>",
    "documentation": "a socket previously created / opened"
   },
   {
    "label": "<nTimeout>",
    "documentation": "is the new socket timeout value"
   }
  ],
  "name": "hb_inetTimeout",
  "return": {
   "name": "",
   "help": "Returns the previous timeout value of the socket"
  }
 },
 {
  "label": "hb_keyPut( <nInkeyCode> )",
  "documentation": "Put an inkey code to the keyboard buffer.",
  "arguments": [
   {
    "label": "<nInkeyCode>",
    "documentation": "is the inkey code, which should be inserted into the keyboard buffer."
   }
  ],
  "name": "hb_keyPut",
  "return": {
   "name": "",
   "help": "There is no return value."
  }
 },
 {
  "label": "hb_langErrMsg( <nErrorCode> ) --> cErrorMessage",
  "documentation": "Description of an error code using current language",
  "arguments": [
   {
    "label": "<nErrorCode>",
    "documentation": "is one of the generic error codes (`EG_...`) defined in error.ch"
   }
  ],
  "name": "hb_langErrMsg",
  "return": {
   "name": "",
   "help": "hb_langErrMsg() return the error message string represented by the code <nErrorCode>."
  }
 },
 {
  "label": "hb_langMessage( <nMsg>[, <cLangID>] ) --> cMessage",
  "documentation": "Returns international strings messages and errors",
  "arguments": [
   {
    "label": "<nMsg>",
    "documentation": "is the message number to get."
   },
   {
    "label": "<cLangID>",
    "documentation": "is an optional language module ID. Uses the currently selected language module, if not specified."
   }
  ],
  "name": "hb_langMessage",
  "return": {
   "name": "",
   "help": "hb_langMessage() return the text associated with the code <nMsg>."
  }
 },
 {
  "label": "hb_langName( [<cLangID>] ) --> cLangName",
  "documentation": "Return the name of the language module",
  "arguments": [
   {
    "label": "<cLangID>",
    "documentation": "is an optional language module ID. Uses the currently selected language module, if not specified."
   }
  ],
  "name": "hb_langName",
  "return": {
   "name": "<cLangName>",
   "help": "Name of the language module"
  }
 },
 {
  "label": "hb_langSelect( [<cNewLang>][, <cCodepage>] ) --> cOldLang",
  "documentation": "Select a specific nation message module",
  "arguments": [
   {
    "label": "<cNewLang>",
    "documentation": "The optional ID of the language module. Possible values for <cNewLang> are below as defined in the Lang library, sorted by language."
   },
   {
    "label": "<cCodepage>",
    "documentation": "Optional codepage ID into which the language module strings are automatically converted by Harbour."
   },
   {
    "label": "<table>",
    "documentation": " Language              <cNewLang> Basque                eu Belorussian           be Bulgarian             bg Catalan               ca Chinese Traditional   zh Chinese Simplified    zh_sim Croatian              hr Czech                 cs Dutch                 nl Esperanto             eo French                fr Galician              gl German                de Greek                 el Hebrew                he Hungarian             hu Icelandic             is Indonesian            id Italian               it Korean                ko Lithuanian            lt Polish                pl Portuguese            pt Romanian              ro Russian               ru Serbian (cyrillic)    sr_cyr Serbian (latin)       sr_lat Slovak                sk Slovenian             sl Spanish               es Swedish               sv Turkish               tr Ukrainian             uk"
   },
   {
    "label": "</table>",
    "documentation": ""
   }
  ],
  "name": "hb_langSelect",
  "return": {
   "name": "<cOldLang>",
   "help": "The old language identifier"
  }
 },
 {
  "label": "hb_LeftEq( <cString>, <cSubString> ) --> lMatch",
  "documentation": "Checks if a sub-string matches to leftmost part of a string.",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Main string of comparison."
   },
   {
    "label": "<cSubString>",
    "documentation": "Sub-string compared to leftmost part of <cString>"
   }
  ],
  "name": "hb_LeftEq",
  "return": {
   "name": "<lMatch>",
   "help": "Boolean flag indicating if the matching was successful"
  }
 },
 {
  "label": "hb_LeftEqI( <cString>, <cSubString> ) --> lMatch",
  "documentation": "Checks if a sub-string matches to leftmost part of a string.",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Main string of comparison."
   },
   {
    "label": "<cSubString>",
    "documentation": "Sub-string compared to leftmost part of <cString>."
   }
  ],
  "name": "hb_LeftEqI",
  "return": {
   "name": "<lMatch>",
   "help": "Boolean flag indicating if the matching was successful."
  }
 },
 {
  "label": "hb_matherBlock( [<bNewBlock>] ) --> bOldBlock",
  "documentation": "Set/Get math error handling codeblock",
  "arguments": [
   {
    "label": "<bNewBlock>",
    "documentation": ""
   }
  ],
  "name": "hb_matherBlock",
  "return": {
   "name": "<bOldBlock>",
   "help": "is the current error handler codeblock"
  }
 },
 {
  "label": "hb_matherMode( [<nNewMode>] ) --> nOldMode",
  "documentation": "Set/Get math error handling mode",
  "arguments": [
   {
    "label": "<table-noheader>",
    "documentation": " HB_MATH_ERRMODE_DEFAULT HB_MATH_ERRMODE_CDEFAULT HB_MATH_ERRMODE_USER HB_MATH_ERRMODE_USERDEFAULT HB_MATH_ERRMODE_USERCDEFAULT"
   },
   {
    "label": "</table>",
    "documentation": ""
   }
  ],
  "name": "hb_matherMode",
  "return": {
   "name": "<nOldMode>",
   "help": "old math error handling mode"
  }
 },
 {
  "label": "hb_MemoRead( <cFileName> ) --> cString",
  "documentation": "Return the text file's contents as a character string",
  "arguments": [
   {
    "label": "<cFileName>",
    "documentation": "is the file name to read from disk. It must include the file extension. If file to be read lives in another directory, you must include the path."
   }
  ],
  "name": "hb_MemoRead",
  "return": {
   "name": "",
   "help": "Returns the contents of a text file as a character string. If <cFileName> cannot be found or read hb_MemoRead() returns an empty string (\"\")."
  }
 },
 {
  "label": "hb_MemoWrit( <cFileName>, <cString> ) --> lSuccess",
  "documentation": "Write a memo field or character string to a text file on disk",
  "arguments": [
   {
    "label": "<cFileName>",
    "documentation": "is the file name to be written to disk. It must include the file extension. If file to be read lives in another directory, you must include the path."
   },
   {
    "label": "<cString>",
    "documentation": "Is the memo field or character string, to be write to"
   },
   {
    "label": "<cFile>",
    "documentation": "."
   }
  ],
  "name": "hb_MemoWrit",
  "return": {
   "name": "",
   "help": "Function returns true (.T.) if the writing operation was successful; otherwise, it returns false (.F.)."
  }
 },
 {
  "label": "hb_ntoc( <nValue>, [<nDecs>] ) --> cValue",
  "documentation": "Converts a numeric value to string",
  "arguments": [
   {
    "label": "<nValue>",
    "documentation": "is the numeric value to convert."
   },
   {
    "label": "<nDecs>",
    "documentation": "decimal digits to retain (if any)."
   }
  ],
  "name": "hb_ntoc",
  "return": {
   "name": "<cValue>",
   "help": "A string representation of <nValue>"
  }
 },
 {
  "label": "hb_ntos( <nValue> ) --> cValue",
  "documentation": "Converts a numeric value to string.",
  "arguments": [
   {
    "label": "<nValue>",
    "documentation": "is the numeric value to convert."
   }
  ],
  "name": "hb_ntos",
  "return": {
   "name": "<cValue>",
   "help": "A string representation of <nValue>"
  }
 },
 {
  "label": "hb_PIsByRef( nParam ) --> lParamIsByRef",
  "documentation": "Determine if a parameter is passed by reference.",
  "arguments": [
   {
    "label": "<nParam>",
    "documentation": "is the parameter number to test."
   }
  ],
  "name": "hb_PIsByRef",
  "return": {
   "name": "<lVarIsByRef>",
   "help": "a logical value indicating if the parameter is passed by reference to actual function or procedure."
  }
 },
 {
  "label": "hb_PValue( <nArg> ) --> xExp",
  "documentation": "Retrieves the value of an argument.",
  "arguments": [],
  "name": "hb_PValue",
  "return": {
   "name": "<xExp>",
   "help": "Returns the value stored by an argument."
  }
 },
 {
  "label": "hb_RAt( <cSearch>, <cString>, [<nStart>], [<nEnd>] ) --> nPos",
  "documentation": "Searches for last occurrence a substring of a string.",
  "arguments": [
   {
    "label": "<cSearch>",
    "documentation": "Substring to search for"
   },
   {
    "label": "<cString>",
    "documentation": "Main string"
   },
   {
    "label": "<nStart>",
    "documentation": "First position to search in <cString>, by default 1."
   },
   {
    "label": "<nEnd>",
    "documentation": "End position to search, by default <cString> length"
   }
  ],
  "name": "hb_RAt",
  "return": {
   "name": "",
   "help": "hb_RAt() return the location of beginning position of last occurrence a substring of a string."
  }
 },
 {
  "label": "hb_SetBuffer( [<nWriteBuffer>], [<nExtractBuffer>], [<nReadBuffer>] ) --> NIL",
  "documentation": "",
  "arguments": [
   {
    "label": "<nWriteBuffer>",
    "documentation": "The size of the write buffer."
   },
   {
    "label": "<nExtractBuffer>",
    "documentation": "The size of the extract buffer."
   },
   {
    "label": "<nReadBuffer>",
    "documentation": "The size of the read buffer."
   }
  ],
  "name": "hb_SetBuffer",
  "return": {
   "name": "<NIL>",
   "help": "This function always returns NIL."
  }
 },
 {
  "label": "hb_SetDiskZip( <bBlock> ) --> .T.",
  "documentation": "Set an codeblock for disk changes",
  "arguments": [
   {
    "label": "<bBlock>",
    "documentation": "an Code block that contains an function that will be performed when the need of changing disk are need."
   }
  ],
  "name": "hb_SetDiskZip",
  "return": {
   "name": "",
   "help": "It always returns True"
  }
 },
 {
  "label": "hb_SetKeyCheck( <nKey> [, <p1> ][, <p2> ][, <p3> ] )",
  "documentation": "Implements common hot-key activation code",
  "arguments": [
   {
    "label": "<nKey>",
    "documentation": "is a numeric key value to be tested code-block, if executed"
   },
   {
    "label": "<p1>",
    "documentation": "..<p3> are optional parameters that will be passed to the code-block"
   }
  ],
  "name": "hb_SetKeyCheck",
  "return": {
   "name": "",
   "help": "True if there is a hot-key associated with <nKey> and it was executed; otherwise False If there is a hot-key association (before checking any condition): - if there is a condition-block, it is passed one parameter - <nKey> - when the hot-key code-block is called, it is passed 1 to 4 parameters, depending on the parameters passed to hb_SetKeyCheck().  Any parameters so passed are directly passed to the code-block, with an additional parameter being <nKey>"
  }
 },
 {
  "label": "hb_SetKeyGet( <nKey> [, <bConditionByRef> ] )",
  "documentation": "Determine a set-key code block and condition-block",
  "arguments": [
   {
    "label": "<anKey>",
    "documentation": "is an numeric key value"
   },
   {
    "label": "<bConditionByRef>",
    "documentation": "is an optional return-parameter"
   }
  ],
  "name": "hb_SetKeyGet",
  "return": {
   "name": "",
   "help": "Current assigned action-block"
  }
 },
 {
  "label": "hb_SetKeySave( [ <OldKeys> ] )",
  "documentation": "Returns a copy of internal set-key list, optionally overwriting",
  "arguments": [
   {
    "label": "<OldKeys>",
    "documentation": "is an optional set-key list from a previous call to hb_SetKeySave(), or NIL to clear current set-key list"
   }
  ],
  "name": "hb_SetKeySave",
  "return": {
   "name": "",
   "help": "Current set-key list"
  }
 },
 {
  "label": "hb_SetMacro( <nOption>, [<lOnOff>] ) --> lOldSetting",
  "documentation": "Enable/disable the macro compiler runtime features.",
  "arguments": [
   {
    "label": "<nOption>",
    "documentation": "One of the `HB_SM_*` constants defined in set.ch."
   },
   {
    "label": "<lOnOff>",
    "documentation": ".T. to enable or .F. to disable a feature"
   }
  ],
  "name": "hb_SetMacro",
  "return": {
   "name": "",
   "help": "hb_SetMacro() return the old state of requested feature."
  }
 },
 {
  "label": "hb_SetZipComment( <cComment> ) --> NIL",
  "documentation": "Set an Zip archive Comment",
  "arguments": [
   {
    "label": "<cComment>",
    "documentation": "Comment to add to the zip archive"
   }
  ],
  "name": "hb_SetZipComment",
  "return": {
   "name": "<NIL>",
   "help": "this function always return NIL"
  }
 },
 {
  "label": "hb_Translate( <cSrcText>, [<cPageFrom>], [<cPageTo>] ) --> cDstText",
  "documentation": "Translate a string from one code page to the other",
  "arguments": [
   {
    "label": "<cSrcText>",
    "documentation": "Is the source string to translate."
   },
   {
    "label": "<cPageFrom>",
    "documentation": "Is the optional character code page ID of the source string. If not specified, the default code page is used."
   },
   {
    "label": "<cPageTo>",
    "documentation": "Is the optional character code page ID of the destination string. If not specified, the default code page is used."
   }
  ],
  "name": "hb_Translate",
  "return": {
   "name": "",
   "help": "hb_Translate() return destination string converted from the source string."
  }
 },
 {
  "label": "hb_UnzipFile( <cFile>, <bBlock>, <lWithPath>, <cPassword>, <cPath>, <cFile> | <aFile>, <pFileProgress> ) --> lCompress",
  "documentation": "Unzip a compressed file",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "Name of the zip file to extract"
   },
   {
    "label": "<bBlock>",
    "documentation": "Code block to execute while extracting"
   },
   {
    "label": "<lWithPath>",
    "documentation": "Toggle to create directory if needed"
   },
   {
    "label": "<cPassword>",
    "documentation": "Password to use to extract files"
   },
   {
    "label": "<cPath>",
    "documentation": "Path to extract the files to - mandatory"
   },
   {
    "label": "<cFile>",
    "documentation": "| <aFiles> A File or Array of files to extract - mandatory"
   },
   {
    "label": "<pFileProgress>",
    "documentation": "Code block for File Progress"
   }
  ],
  "name": "hb_UnzipFile",
  "return": {
   "name": "<lCompress>",
   "help": ".T. if all file was successfully restored, otherwise .F."
  }
 },
 {
  "label": "hb_ValToStr( <xValue> ) --> cString",
  "documentation": "Converts any scalar type to a string.",
  "arguments": [
   {
    "label": "<xValue>",
    "documentation": "is any scalar argument."
   }
  ],
  "name": "hb_ValToStr",
  "return": {
   "name": "<cString>",
   "help": "A string representation of <xValue> using default conversions."
  }
 },
 {
  "label": "hb_Week( <dDate>, [@<nYear>], [@<nDayOfWeek>] ) --> nWeekNumber",
  "documentation": "Returns the week number of year.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "Any valid date expression."
   },
   {
    "label": "<nYear>",
    "documentation": "Optional parameter to hold the year of the given date."
   },
   {
    "label": "<nDayOfWeek>",
    "documentation": "Optional parameter to hold the day number of week."
   }
  ],
  "name": "hb_Week",
  "return": {
   "name": "<nWeekNumber>",
   "help": "The ordinal week number of the year into which falls the given <dDate>."
  }
 },
 {
  "label": "hb_ZipDeleteFiles( <cFile>, <cFiletoDelete> | <aFiles> | <nFilePos> ) --> <lDeleted>",
  "documentation": "Delete files from an zip archive",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "The name of the zip files from where the files will be deleted"
   },
   {
    "label": "<cFiletoDelete>",
    "documentation": "An File to be removed _or_"
   },
   {
    "label": "<aFiles>",
    "documentation": "An Array of Files to be removed _or_"
   },
   {
    "label": "<nFilePos>",
    "documentation": "The Position of the file to be removed"
   }
  ],
  "name": "hb_ZipDeleteFiles",
  "return": {
   "name": "<lDeleted>",
   "help": "If the files are deleted, it will return .T.; otherwise it will return .F. in the following cases: Spanned Archives; the file(s) could not be found in the zip file."
  }
 },
 {
  "label": "hb_ZipFile( <cFile>, <cFileToCompress> | <aFiles>, <nLevel>, <bBlock>, <lOverWrite>, <cPassword>, <lWithPath>, <lWithDrive>, <pFileProgress> ) --> lCompress",
  "documentation": "Create a zip file",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "Name of the zip file to create"
   },
   {
    "label": "<cFileToCompress>",
    "documentation": "Name of a file to Compress, Drive and/or path can be used _or_"
   },
   {
    "label": "<aFiles>",
    "documentation": "An array containing files to compress, Drive and/or path can be used"
   },
   {
    "label": "<nLevel>",
    "documentation": "Compression level ranging from 0 to 9"
   },
   {
    "label": "<bBlock>",
    "documentation": "Code block to execute while compressing"
   },
   {
    "label": "<lOverWrite>",
    "documentation": "Toggle to overwrite the file if exists"
   },
   {
    "label": "<cPassword>",
    "documentation": "Password to encrypt the files"
   },
   {
    "label": "<lWithPath>",
    "documentation": "Toggle to store the path or not"
   },
   {
    "label": "<lWithDrive>",
    "documentation": "Toggle to store the Drive letter and path or not"
   },
   {
    "label": "<pFileProgress>",
    "documentation": "Code block for File Progress"
   }
  ],
  "name": "hb_ZipFile",
  "return": {
   "name": "<lCompress>",
   "help": ".T. if file was create, otherwise .F."
  }
 },
 {
  "label": "hb_ZipFileByPKSpan( <cFile>, <cFileToCompress> | <aFiles>, <nLevel>, <bBlock>, <lOverWrite>, <cPassword>, <lWithPath>, <lWithDrive>, <pFileProgress> ) --> lCompress",
  "documentation": "Create a zip file on removable media",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "Name of the zip file"
   },
   {
    "label": "<cFileToCompress>",
    "documentation": "Name of a file to Compress, Drive and/or path can be used _or_"
   },
   {
    "label": "<aFiles>",
    "documentation": "An array containing files to compress, Drive and/or path can be used"
   },
   {
    "label": "<nLevel>",
    "documentation": "Compression level ranging from 0 to 9"
   },
   {
    "label": "<bBlock>",
    "documentation": "Code block to execute while compressing"
   },
   {
    "label": "<lOverWrite>",
    "documentation": "Toggle to overwrite the file if exists"
   },
   {
    "label": "<cPassword>",
    "documentation": "Password to encrypt the files"
   },
   {
    "label": "<lWithPath>",
    "documentation": "Toggle to store the path or not"
   },
   {
    "label": "<lWithDrive>",
    "documentation": "Toggle to store the Drive letter and path or not"
   },
   {
    "label": "<pFileProgress>",
    "documentation": "Code block for File Progress"
   }
  ],
  "name": "hb_ZipFileByPKSpan",
  "return": {
   "name": "<lCompress>",
   "help": ".T. if file was create, otherwise .F."
  }
 },
 {
  "label": "hb_ZipFileByTDSpan( <cFile>, <cFileToCompress> | <aFiles>, <nLevel>, <bBlock>, <lOverWrite>, <cPassword>, <iSize>, <lWithPath>, <lWithDrive>, <pFileProgress>) --> lCompress",
  "documentation": "Create a zip file",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "Name of the zip file"
   },
   {
    "label": "<cFileToCompress>",
    "documentation": "Name of a file to Compress, Drive and/or path can be used _or_"
   },
   {
    "label": "<aFiles>",
    "documentation": "An array containing files to compress, Drive and/or path can be used"
   },
   {
    "label": "<nLevel>",
    "documentation": "Compression level ranging from 0 to 9"
   },
   {
    "label": "<bBlock>",
    "documentation": "Code block to execute while compressing"
   },
   {
    "label": "<lOverWrite>",
    "documentation": "Toggle to overwrite the file if exists"
   },
   {
    "label": "<cPassword>",
    "documentation": "Password to encrypt the files"
   },
   {
    "label": "<iSize>",
    "documentation": "Size of the archive, in bytes. Default is 1457664 bytes"
   },
   {
    "label": "<lWithPath>",
    "documentation": "Toggle to store the path or not"
   },
   {
    "label": "<lWithDrive>",
    "documentation": "Toggle to store the Drive letter and path or not"
   },
   {
    "label": "<pFileProgress>",
    "documentation": "Code block for File Progress"
   }
  ],
  "name": "hb_ZipFileByTDSpan",
  "return": {
   "name": "<lCompress>",
   "help": ".T. if file was create, otherwise .F."
  }
 },
 {
  "label": "hb_ZipTestPK( <cFile> ) --> <nReturnCode>",
  "documentation": "Test pkSpanned zip files",
  "arguments": [
   {
    "label": "<cFile>",
    "documentation": "File to be tested."
   }
  ],
  "name": "hb_ZipTestPK",
  "return": {
   "name": "<nReturn>",
   "help": "A code that tells if the current disk is the last of a pkSpanned disk set."
  }
 },
 {
  "label": "hbmisc_DaysInMonth( <dDate> ) --> nDays",
  "documentation": "Gets the days in a month.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "A valid date."
   }
  ],
  "name": "hbmisc_DaysInMonth",
  "return": {
   "name": "<nDays>",
   "help": "The number of days of the month."
  }
 },
 {
  "label": "Header() --> nBytes",
  "documentation": "Return the length of a database file header",
  "arguments": [],
  "name": "Header",
  "return": {
   "name": "<nBytes>",
   "help": "The numeric size of a database file header in bytes"
  }
 },
 {
  "label": "HexaToDec( <cN> ) --> <cNr>",
  "documentation": "Converts a Hexa Value to Decimal",
  "arguments": [
   {
    "label": "<cN>",
    "documentation": "NUMBER TO BE CONVERTED"
   }
  ],
  "name": "HexaToDec",
  "return": {
   "name": "<cNr>",
   "help": "NUMBER CONVERTED"
  }
 },
 {
  "label": "I2Bin( <nNumber> ) --> cBuffer",
  "documentation": "Convert Harbour numeric into signed short encoded bytes",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "is a numeric value to convert (decimal digits are ignored)."
   }
  ],
  "name": "I2Bin",
  "return": {
   "name": "",
   "help": "I2Bin() return two bytes character string that contains 16-bit encoded signed short integer (least significant byte first)."
  }
 },
 {
  "label": "IndexExt() --> cExtension",
  "documentation": "Returns the file extension of the index module used in an application",
  "arguments": [],
  "name": "IndexExt",
  "return": {
   "name": "<cExtension>",
   "help": "Current driver file extension"
  }
 },
 {
  "label": "IndexKey( <nOrder> ) --> cIndexKey",
  "documentation": "Yields the key expression of a specified index file.",
  "arguments": [
   {
    "label": "<nOrder>",
    "documentation": "Index order number"
   }
  ],
  "name": "IndexKey",
  "return": {
   "name": "<cIndexKey>",
   "help": "The index key"
  }
 },
 {
  "label": "IndexOrd() --> nPosition",
  "documentation": "Returns the numeric position of the controlling index.",
  "arguments": [],
  "name": "IndexOrd",
  "return": {
   "name": "<nPosition>",
   "help": "Ordinal position of a controling index"
  }
 },
 {
  "label": "Infinity( [<lPlatformIndependant>] ) --> nLargestNumber",
  "documentation": "Returns the largest floating point number available in the system",
  "arguments": [],
  "name": "Infinity",
  "return": {
   "name": "<nLargestNumber>",
   "help": "the largest floating point number available in the system"
  }
 },
 {
  "label": "Inkey( [<nTimeout>] [, <nEvents>] ) --> nKey",
  "documentation": "Extracts the next key code from the Harbour keyboard buffer.",
  "arguments": [
   {
    "label": "<nTimeout>",
    "documentation": "is an optional timeout value in seconds, with a granularity of 1/10th of a second. If omitted, Inkey() returns immediately. If set to 0, Inkey() waits until an input event occurs. If set to any other value, Inkey() will return either when an input event occurs or when the timeout period has elapsed. If only this parameter is specified and it is not numeric, it will be treated as if it were 0. But if both parameters are specified and this parameter is not numeric, it will be treated as if it were not present."
   },
   {
    "label": "<nEvents>",
    "documentation": "is an optional mask of input events that are to be enabled. If omitted, defaults to `hb_set.HB_SET_EVENTMASK`. Valid input masks are in inkey.ch and are explained below. It is recommended that the mask names be used rather than their numeric values, in case the numeric values change in future releases of Harbour. To allow more than one type of input event, simply add the various mask names together."
   },
   {
    "label": "<table>",
    "documentation": " inkey.ch            Meaning INKEY_MOVE          Mouse motion events are allowed INKEY_LDOWN         The mouse left click down event is allowed INKEY_LUP           The mouse left click up event is allowed INKEY_RDOWN         The mouse right click down event is allowed INKEY_RUP           The mouse right click up event is allowed INKEY_KEYBOARD      All keyboard events are allowed INKEY_ALL           All mouse and keyboard events are allowed HB_INKEY_EXTENDED   Extended keyboard codes are used."
   },
   {
    "label": "</table>",
    "documentation": " If the parameter is not numeric, it will be treated as if it were set to `hb_set.HB_SET_EVENTMASK`."
   }
  ],
  "name": "Inkey",
  "return": {
   "name": "",
   "help": "0 in case of timeout with no input event, otherwise returns a value in the range -47 to 386 for keyboard events or the range 1001 to 1007 for mouse events. Mouse events and non-printable keyboard events are represented by the `K_<event>` values listed in inkey.ch. Keyboard event return codes in the range 32 through 127 are equivalent to the printable ASCII character set. Keyboard event return codes in the range 128 through 255 are assumed to be printable, but results may vary based on hardware and nationality. If HB_INKEY_EXTENDED mode is used, then the return value for keyboard events ranges from 1 through 767 and 1077 through 1491, although not all codes are used. Extended key codes consist of the PC keyboard scan code and one or more offset values. If no keyboard modifier was used, then HB_INKEY_NONE is added. The <Alt> key adds HB_INKEY_ALT, the <Ctrl> key adds HB_INKEY_CTRL, the <Shift> key adds HB_INKEY_SHIFT, and enhanced keys (<KeyPad+/> and <CursorPad> keys) add HB_INKEY_ENHANCED. For example, <F1> is scan code 59, so if you just press <F1>, you get key code 315, but <Alt+F1> gives 443, <Ctrl+F1> gives 571, and <Shift+F1> gives 699. And <NumPad+/> gives 1077, 1205, 1333, and 1461. At this time, the only value that can combine with other values is HB_INKEY_ENHANCED (i.e., there are no <Alt+Ctrl> combinations, etc.) Note: The extended key code set is larger than the normal key code set. As a result, if you switch between the normal and extended modes, you need to be aware that some codes get translated into a zero in normal mode (because there is no corresponding code in normal mode) and that these codes get removed from the keyboard input buffer in normal mode and you won't be able to go back and fetch them later in extended mode."
  }
 },
 {
  "label": "Int( <nNumber> ) --> nIntNumber",
  "documentation": "Return the integer port of a numeric value.",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "Any  numeric value."
   }
  ],
  "name": "Int",
  "return": {
   "name": "<nIntNumber>",
   "help": "The integer portion of the numeric value."
  }
 },
 {
  "label": "IsAffirm( <cChar> ) --> lTrueOrFalse",
  "documentation": "Checks if passed char is an affirmation char",
  "arguments": [
   {
    "label": "<cChar>",
    "documentation": "is a char or string of chars"
   }
  ],
  "name": "IsAffirm",
  "return": {
   "name": "<lTrueOrFalse>",
   "help": "True if passed char is an affirmation char, otherwise false"
  }
 },
 {
  "label": "IsAlpha( <cString> ) --> lAlpha",
  "documentation": "Checks if leftmost character in a string is an alphabetic character",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Any character string"
   }
  ],
  "name": "IsAlpha",
  "return": {
   "name": "<lAlpha>",
   "help": "Logical true (.T.) or false (.F.)."
  }
 },
 {
  "label": "IsBin( <cN> ) --> <cNr>",
  "documentation": "Check if the value is a Binary  Number",
  "arguments": [
   {
    "label": "<cN>",
    "documentation": "STRING TO BE CHECKED"
   }
  ],
  "name": "IsBin",
  "return": {
   "name": "<cNr>",
   "help": ".T. IF THE STRING IS BYNARY, otherwise .F."
  }
 },
 {
  "label": "IsDec( <cN> ) --> <cNr>",
  "documentation": "Check if the value is a Decimal  Number",
  "arguments": [
   {
    "label": "<cN>",
    "documentation": "STRING TO BE CHECKED"
   }
  ],
  "name": "IsDec",
  "return": {
   "name": "<cNr>",
   "help": ".T. IF THE STRING IS DECIMAL;otherwise .F."
  }
 },
 {
  "label": "IsDigit( <cString> ) --> lDigit",
  "documentation": "Checks if leftmost character is a digit character",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Any character string"
   }
  ],
  "name": "IsDigit",
  "return": {
   "name": "<lDigit>",
   "help": "Logical true (.T.) or false (.F.)."
  }
 },
 {
  "label": "IsDisk( <cDrive> ) --> lSuccess",
  "documentation": "Verify if a drive is ready",
  "arguments": [
   {
    "label": "<cDrive>",
    "documentation": "An valid drive letter"
   }
  ],
  "name": "IsDisk",
  "return": {
   "name": "<lSuccess>",
   "help": ".T. is the drive is ready, otherwise .F."
  }
 },
 {
  "label": "IsHexa( <cN> ) --> <cNr>",
  "documentation": "Check if the value is a Hexal  Number",
  "arguments": [
   {
    "label": "<cN>",
    "documentation": "STRING TO BE CHECKED"
   }
  ],
  "name": "IsHexa",
  "return": {
   "name": "<cNr>",
   "help": ".T. IF THE STRING IS HEXA;otherwise .F."
  }
 },
 {
  "label": "IsLeap( [<dDate>] ) -> lIsLeap",
  "documentation": "determines of year of date is a leap year",
  "arguments": [],
  "name": "IsLeap"
 },
 {
  "label": "IsLeapYear( <dDate> ) --> lTrueOrFalse",
  "documentation": "Checks if the given date is a leap year.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "A valid date."
   }
  ],
  "name": "IsLeapYear",
  "return": {
   "name": "<lTrueOrFalse>",
   "help": "A logical that indicates if the date year is leap"
  }
 },
 {
  "label": "IsLeapYr( [<dDate>] ) --> <lIsLeap>",
  "documentation": "Test if a date falls in a leap year.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "is an optional date. If not supplied is defaults to the value returned from Date()."
   }
  ],
  "name": "IsLeapYr",
  "return": {
   "name": "",
   "help": ".T. if <dDate> falls in a leap year, .F. if not."
  }
 },
 {
  "label": "IsLower( <cString> ) --> lLower",
  "documentation": "Checks if leftmost character is an lowercased letter.",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Any character string"
   }
  ],
  "name": "IsLower",
  "return": {
   "name": "<lLower>",
   "help": "Logical true (.T.) or false (.F.)."
  }
 },
 {
  "label": "IsNegative( <cChar> ) --> lTrueOrFalse",
  "documentation": "Checks if passed char is a negation char.",
  "arguments": [
   {
    "label": "<cChar>",
    "documentation": "is a char or string of chars"
   }
  ],
  "name": "IsNegative",
  "return": {
   "name": "<lTrueOrFalse>",
   "help": "True if passed char is a negation char, otherwise false."
  }
 },
 {
  "label": "IsOctal( <cN> ) --> <cNr>",
  "documentation": "Check if the value is a Octal  Number",
  "arguments": [
   {
    "label": "<cN>",
    "documentation": "STRING TO BE CHECKED"
   }
  ],
  "name": "IsOctal",
  "return": {
   "name": "<cNr>",
   "help": ".T. IF THE STRING IS OCTAL;otherwise .F."
  }
 },
 {
  "label": "IsUpper( <cString> ) --> lUpper",
  "documentation": "Checks if leftmost character is an uppercased letter.",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Any character string"
   }
  ],
  "name": "IsUpper",
  "return": {
   "name": "<lUpper>",
   "help": "Logical true (.T.) or false (.F.)."
  }
 },
 {
  "label": "JustLeft( <[@]cString>, [<cChar>|<nChar>] ) -> cJustifiedString",
  "documentation": "Move characters from the beginning to the end of a string",
  "arguments": [],
  "name": "JustLeft"
 },
 {
  "label": "JustRight( <[@]cString>, [<cChar>|<nChar>] ) -> cJustifiedString",
  "documentation": "Move characters from the end to the beginning of a string",
  "arguments": [],
  "name": "JustRight"
 },
 {
  "label": "KSetCaps( [<lNewSwitch>] ) -> lOldSwitch",
  "documentation": "",
  "arguments": [],
  "name": "KSetCaps"
 },
 {
  "label": "KSetIns( [<lNewSwitch>] ) -> lOldSwitch",
  "documentation": "",
  "arguments": [],
  "name": "KSetIns"
 },
 {
  "label": "KSetNum( [<lNewSwitch>] ) -> lOldSwitch",
  "documentation": "",
  "arguments": [],
  "name": "KSetNum"
 },
 {
  "label": "KSetScroll( [<lNewSwitch>] ) -> lOldSwitch",
  "documentation": "",
  "arguments": [],
  "name": "KSetScroll"
 },
 {
  "label": "L2Bin( <nNumber> ) --> cBuffer",
  "documentation": "Convert Harbour numeric into signed long encoded bytes",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "is a numeric value to convert (decimal digits are ignored)."
   }
  ],
  "name": "L2Bin",
  "return": {
   "name": "",
   "help": "L2Bin() return four bytes character string that contains 32-bit encoded signed long integer (least significant byte first)."
  }
 },
 {
  "label": "LastDayOM( [<dDate|nMonth>] ) -> nDaysInMonth",
  "documentation": "Returns the the number of days in the month.",
  "arguments": [],
  "name": "LastDayOM"
 },
 {
  "label": "LastKey( [<nInputMask>] ) --> nKey",
  "documentation": "Get the last key extracted from the keyboard buffer.",
  "arguments": [
   {
    "label": "<nInputMask>",
    "documentation": "is an optional integer value composed of one or more INKEY_ or HB_INKEY_ constants. The sole purpose of this argument is to allow switching between using HB_INKEY_EXTENDED key codes and using the normal CA-Cl*pper-compatible key codes"
   }
  ],
  "name": "LastKey",
  "return": {
   "name": "<nKey>",
   "help": "The last key extracted from the keyboard buffer."
  }
 },
 {
  "label": "LastRec() | RecCount()* --> nRecords",
  "documentation": "Returns the number of records in an active work area or database.",
  "arguments": [],
  "name": "LastRec",
  "return": {
   "name": "<nRecords >",
   "help": "The number of records"
  }
 },
 {
  "label": "Left( <cString>, <nLen> ) --> cReturn",
  "documentation": "Extract the leftmost substring of a character expression",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Main character to be parsed"
   },
   {
    "label": "<nLen>",
    "documentation": "Number of bytes to return beginning at the leftmost position"
   }
  ],
  "name": "Left",
  "return": {
   "name": "<cReturn>",
   "help": "Substring of evaluation"
  }
 },
 {
  "label": "Len( <cString> | <aArray> ) --> nLength",
  "documentation": "Returns size of a string or size of an array.",
  "arguments": [
   {
    "label": "<acString>",
    "documentation": "is a character string or the array to check."
   }
  ],
  "name": "Len",
  "return": {
   "name": "",
   "help": "The length of the string or the number of elements that contains an array."
  }
 },
 {
  "label": "Log( <nNumber> ) --> nLog",
  "documentation": "Returns the natural logarithm of a number.",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "Any numeric expression."
   }
  ],
  "name": "Log",
  "return": {
   "name": "<nExponent>",
   "help": "The natural logarithm of <nNumber>."
  }
 },
 {
  "label": "Log10( <nNumber> ) -> nLogarithm",
  "documentation": "Decadic logarithm of a number",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "number to logarithm"
   }
  ],
  "name": "Log10",
  "return": {
   "name": "<nLogarithm>",
   "help": "decadic logarithm of <nNumber>"
  }
 },
 {
  "label": "Lower( <cString> ) --> cLowerString",
  "documentation": "Universally lowercases a character string expression.",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Any character expression."
   }
  ],
  "name": "Lower",
  "return": {
   "name": "<cLowerString>",
   "help": "Lowercased value of <cString>"
  }
 },
 {
  "label": "LTrim( <cString> ) --> cReturn",
  "documentation": "Removes leading spaces from a string",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Character expression with leading spaces"
   }
  ],
  "name": "LTrim",
  "return": {
   "name": "",
   "help": "LTrim() returns a copy of the original string with leading spaces removed."
  }
 },
 {
  "label": "LUpdate() --> dModification",
  "documentation": "Yields the date the database was last updated.",
  "arguments": [],
  "name": "LUpdate",
  "return": {
   "name": "<dModification>",
   "help": "The date of the last modification."
  }
 },
 {
  "label": "MakeDir( <cDirectory> ) --> nError",
  "documentation": "Create a new directory",
  "arguments": [
   {
    "label": "<cDirectory>",
    "documentation": "The name of the directory you want to create."
   }
  ],
  "name": "MakeDir",
  "return": {
   "name": "<nError>",
   "help": "0 if directory was successfully created, otherwise the number of the last error."
  }
 },
 {
  "label": "Mantissa( <nFloatingPointNumber> ) --> nMantissa",
  "documentation": "Evaluate the mantissa of a floating point number",
  "arguments": [
   {
    "label": "<nFloatingPointNumber>",
    "documentation": "Designate any Harbour number."
   }
  ],
  "name": "Mantissa",
  "return": {
   "name": "",
   "help": "Mantissa() returns the mantissa of the <nFloatingPointNumber> number."
  }
 },
 {
  "label": "Max( <xValue>, <xValue1> ) --> xMax",
  "documentation": "Returns the maximum of two numbers or dates.",
  "arguments": [
   {
    "label": "<xValue>",
    "documentation": "Any date or numeric value."
   },
   {
    "label": "<xValue1>",
    "documentation": "Any date or numeric value (same type as <xValue>)."
   }
  ],
  "name": "Max",
  "return": {
   "name": "<xMax>",
   "help": "The larger numeric (or later date) value."
  }
 },
 {
  "label": "MaxCol() --> nPosition",
  "documentation": "Returns the maximum number of columns in the current video mode",
  "arguments": [],
  "name": "MaxCol",
  "return": {
   "name": "<nPosition>",
   "help": "The maximum number of columns possible in current video mode"
  }
 },
 {
  "label": "MaxRow() --> nPosition",
  "documentation": "Returns the current screen row position",
  "arguments": [],
  "name": "MaxRow",
  "return": {
   "name": "<nPosition>",
   "help": "The maximum number of rows possible in current video mode"
  }
 },
 {
  "label": "MCol() --> nMouseColumn",
  "documentation": "Returns the mouse cursor column position.",
  "arguments": [],
  "name": "MCol",
  "return": {
   "name": "<nMouseColumn>",
   "help": "The mouse cursor column position."
  }
 },
 {
  "label": "MD( <cDir> ) -> <lSucess>",
  "documentation": "Creates a Directory",
  "arguments": [
   {
    "label": "<cDir>",
    "documentation": "DIRECTORY TO BE CREATED"
   }
  ],
  "name": "MD",
  "return": {
   "name": "<lSucess>",
   "help": ".T. IF SUCCESSFUL; otherwise .F."
  }
 },
 {
  "label": "MDY( [<dDate>] ) -> cDateString",
  "documentation": "Returns the date as a string in Month DD, YY or Month DD, YYYY",
  "arguments": [],
  "name": "MDY"
 },
 {
  "label": "MemoRead( <cFileName> ) --> cString",
  "documentation": "Return the text file's contents as a character string",
  "arguments": [
   {
    "label": "<cFileName>",
    "documentation": "is the file name to read from disk. It must include the file extension. If file to be read lives in another directory, you must include the path."
   }
  ],
  "name": "MemoRead",
  "return": {
   "name": "",
   "help": "Returns the contents of a text file as a character string. If <cFileName> cannot be found or read MemoRead() returns an empty string (\"\")."
  }
 },
 {
  "label": "MemoTran( <cString>, <cHard>, <cSoft> ) --> cConvertedString",
  "documentation": "Converts hard and soft carriage returns within strings.",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "is a string of chars to convert."
   },
   {
    "label": "<cHard>",
    "documentation": "is the character to replace hard returns with. If not specified defaults to semicolon."
   },
   {
    "label": "<cSoft>",
    "documentation": "is the character to replace soft returns with. If not specified defaults to single space."
   }
  ],
  "name": "MemoTran",
  "return": {
   "name": "<cConvertedString>",
   "help": "Transformed string."
  }
 },
 {
  "label": "MemoWrit( <cFileName>, <cString> ) --> lSuccess",
  "documentation": "Write a memo field or character string to a text file on disk",
  "arguments": [
   {
    "label": "<cFileName>",
    "documentation": "is the file name to be written to disk. It must include the file extension. If file to be read lives in another directory, you must include the path."
   },
   {
    "label": "<cString>",
    "documentation": "Is the memo field or character string, to be write to"
   },
   {
    "label": "<cFile>",
    "documentation": "."
   }
  ],
  "name": "MemoWrit",
  "return": {
   "name": "",
   "help": "Function returns true (.T.) if the writing operation was successful; otherwise, it returns false (.F.)."
  }
 },
 {
  "label": "MemVarBlock( <cMemvarName> ) --> bBlock",
  "documentation": "Returns a codeblock that sets/gets a value of memvar variable",
  "arguments": [
   {
    "label": "<cMemvarName>",
    "documentation": "- a string that contains the name of variable"
   }
  ],
  "name": "MemVarBlock",
  "return": {
   "name": "<bBlock>",
   "help": "a codeblock that sets/get the value of variable"
  }
 },
 {
  "label": "Min( <xValue>, <xValue1> ) --> xMin",
  "documentation": "Determines the minimum of two numbers or dates.",
  "arguments": [
   {
    "label": "<xValue>",
    "documentation": "Any date or numeric value."
   },
   {
    "label": "<xValue1>",
    "documentation": "Any date or numeric value."
   }
  ],
  "name": "Min",
  "return": {
   "name": "<xMin>",
   "help": "The smaller numeric (or earlier date) value."
  }
 },
 {
  "label": "Mod( <nNumber>, <nNumber1> ) -->  <nRemainder>",
  "documentation": "Return the modulus of two numbers.",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "Numerator in a divisional expression."
   },
   {
    "label": "<nNumber1>",
    "documentation": "Denominator in a divisional expression."
   }
  ],
  "name": "Mod",
  "return": {
   "name": "<nRemainder>",
   "help": "The remainder after the division operation."
  }
 },
 {
  "label": "Month( <dDate> ) --> nMonth",
  "documentation": "Converts a date expression to a month value",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "Any valid date expression"
   }
  ],
  "name": "Month",
  "return": {
   "name": "<nMonth>",
   "help": "Corresponding number of the month in the year, ranging from 0 to 12"
  }
 },
 {
  "label": "MRow() --> nMouseRow",
  "documentation": "Returns the mouse cursor row position.",
  "arguments": [],
  "name": "MRow",
  "return": {
   "name": "<nMouseRow>",
   "help": "The mouse cursor row position."
  }
 },
 {
  "label": "NationMsg( <nMsg> ) --> cMessage",
  "documentation": "Returns international strings messages.",
  "arguments": [
   {
    "label": "<nMsg>",
    "documentation": "is the message number you want to get."
   }
  ],
  "name": "NationMsg",
  "return": {
   "name": "<cMessage>",
   "help": "if <nMsg> is a valid message selector, returns the message. If <nMsg> is NIL, it returns \"Invalid Argument\", and if <nMsg> is any other type it returns an empty string."
  }
 },
 {
  "label": "NetErr( [<lNewError>] ) --> lError",
  "documentation": "Tests the success of a network function",
  "arguments": [
   {
    "label": "<lNewError>",
    "documentation": "Is a logical Expression."
   }
  ],
  "name": "NetErr",
  "return": {
   "name": "<lError>",
   "help": "A value based on the success of a network operation or function."
  }
 },
 {
  "label": "NextKey( [<nInputMask>] ) --> nKey",
  "documentation": "Get the next key code in the buffer without extracting it.",
  "arguments": [
   {
    "label": "<nInputMask>",
    "documentation": "is an optional integer value composed of one or more INKEY_ or HB_INKEY_ constants. The sole purpose of this argument is to allow switching between using HB_INKEY_EXTENDED key codes and using the normal CA-Cl*pper-compatible key codes"
   }
  ],
  "name": "NextKey",
  "return": {
   "name": "<nKey>",
   "help": "The value of the next key in the Harbour keyboard buffer."
  }
 },
 {
  "label": "NToC( <xNumber>[, <nBase>][, <nLength>][, <cPadChar>] ) -> <cNumber>",
  "documentation": "",
  "arguments": [],
  "name": "NToC"
 },
 {
  "label": "NToCDoW( <nDay> ) -> cDay",
  "documentation": "(num of day) -> day name",
  "arguments": [],
  "name": "NToCDoW"
 },
 {
  "label": "NToCMonth( <nMonth> ) -> cMonth",
  "documentation": "(num of month ) -> Month Name",
  "arguments": [],
  "name": "NToCMonth"
 },
 {
  "label": "NToColor( <nAttr>, [<lColorCode>] ) -> <cAttr>",
  "documentation": "",
  "arguments": [
   {
    "label": "<nAttr>",
    "documentation": "Designates the value for the combined numeric color attributes."
   },
   {
    "label": "<lColorCode>",
    "documentation": "If designated as .F. or if the parameter is omitted, NToColor() returns a string with a numeric color code. When designated as .T., NToColor() returns a string with the CA-Cl*pper alpha color coding."
   }
  ],
  "name": "NToColor",
  "return": {
   "name": "",
   "help": "NToColor() returns the designated color attribute in the NN/NN or CC/CC form."
  }
 },
 {
  "label": "NumAt( <cStringToMatch>, <cString>, [<nIgnore>] ) --> nCount",
  "documentation": "Number of occurrences of a sequence in a string",
  "arguments": [],
  "name": "NumAt"
 },
 {
  "label": "NumToken( <cString>, [<cTokenizer>], [<nSkipWidth>] ) -> nTokenCount",
  "documentation": "Retrieves the number of tokens in a string",
  "arguments": [],
  "name": "NumToken"
 },
 {
  "label": "OctalToDec( <cN> ) --> <cNr>",
  "documentation": "Converts a Octal Value to Decimal",
  "arguments": [
   {
    "label": "<cN>",
    "documentation": "NUMBER TO BE CONVERTED"
   }
  ],
  "name": "OctalToDec",
  "return": {
   "name": "<cNr>",
   "help": "NUMBER CONVERTED"
  }
 },
 {
  "label": "ordBagExt() --> cBagExt",
  "documentation": "Returns the Order Bag extension",
  "arguments": [],
  "name": "ordBagExt",
  "return": {
   "name": "<cBagExt>",
   "help": "The RDD extension name."
  }
 },
 {
  "label": "ordBagName( <nOrder> | <cOrderName> ) --> cOrderBagName",
  "documentation": "Returns the Order Bag Name.",
  "arguments": [
   {
    "label": "<nOrder>",
    "documentation": "A numeric value representing the Order bag number."
   },
   {
    "label": "<cOrderName>",
    "documentation": "The character name of the Order Bag."
   }
  ],
  "name": "ordBagName",
  "return": {
   "name": "",
   "help": "ordBagName() returns the Order bag name"
  }
 },
 {
  "label": "ordCondSet( [<cForCondition>], [<bForCondition>], [<lAll>], [<bWhileCondition>], [<bEval>], [<nInterval>], [<nStart>], [<nNext>], [<nRecord>], [<lRest>], [<lDescend>], [<lAdditive>], [<lCurrent>], [<lCustom>], [<lNoOptimize>] )",
  "documentation": "Set the Condition and scope for an order",
  "arguments": [
   {
    "label": "<cForCondition>",
    "documentation": "is a string that specifies the FOR condition for the order."
   },
   {
    "label": "<bForCondition>",
    "documentation": "is a code block that defines a FOR condition that each record within the scope must meet in order to be processed. If a record does not meet the specified condition, it is ignored and the next  record is processed. Duplicate keys values are not added to the index file when a FOR condition is Used."
   }
  ],
  "name": "ordCondSet"
 },
 {
  "label": "ordCreate( <cOrderBagName>,[<cOrderName>], <cExpKey>, [<bExpKey>], [<lUnique>] )",
  "documentation": "Create an Order in an Order Bag",
  "arguments": [
   {
    "label": "<cOrderBagName>",
    "documentation": "Name of the file that contains one or more Orders."
   },
   {
    "label": "<cOrderName>",
    "documentation": "Name of the order to be created."
   },
   {
    "label": "<cExpKey>",
    "documentation": "Key value for order for each record in the current work area"
   },
   {
    "label": "<bExpKey>",
    "documentation": "Code block that evaluates to a key for the order for each record in the work area."
   },
   {
    "label": "<lUnique>",
    "documentation": "Toggle the unique status of the index."
   }
  ],
  "name": "ordCreate"
 },
 {
  "label": "ordDestroy( <cOrderName> [, <cOrderBagName> ] )",
  "documentation": "Remove an Order from an Order Bag",
  "arguments": [
   {
    "label": "<cOrderName>",
    "documentation": "Name of the order to remove"
   },
   {
    "label": "<cOrderBagName>",
    "documentation": "Name of the order bag from which order id to be removed"
   }
  ],
  "name": "ordDestroy"
 },
 {
  "label": "ordFor( <xOrder>[, <cOrderBagName>] ) --> cForExp",
  "documentation": "Return the FOR expression of an Order",
  "arguments": [
   {
    "label": "<xOrder>",
    "documentation": "It the name of the target order, or the numeric position of the order."
   },
   {
    "label": "<cOrderBagName>",
    "documentation": "Name of the order bag."
   }
  ],
  "name": "ordFor",
  "return": {
   "name": "",
   "help": "ordFor() returns a expression containing the FOR condition for an order."
  }
 },
 {
  "label": "ordKey( <cOrderName> | <nOrder> [, <cOrderBagName>] ) --> cExpKey",
  "documentation": "Return the key expression of an Order",
  "arguments": [
   {
    "label": "<xOrder>",
    "documentation": "It the name of the target order, or the numeric position of the order."
   },
   {
    "label": "<cOrderBagName>",
    "documentation": "Name of the order bag."
   }
  ],
  "name": "ordKey",
  "return": {
   "name": "<cExpKey>",
   "help": "Returns a character string, cExpKey."
  }
 },
 {
  "label": "OS() --> cOperatingSystem",
  "documentation": "Return the current operating system.",
  "arguments": [],
  "name": "OS",
  "return": {
   "name": "<cOperatinSystem>",
   "help": "The current operating system."
  }
 },
 {
  "label": "OutErr( <xExp,...> )",
  "documentation": "Write a list of values to the standard error device",
  "arguments": [
   {
    "label": "<xExp,...>",
    "documentation": "is a list of expressions to display. Expressions are any mixture of Harbour data types."
   }
  ],
  "name": "OutErr"
 },
 {
  "label": "OutStd( <xExp,...> )",
  "documentation": "Write a list of values to the standard output device",
  "arguments": [
   {
    "label": "<xExp,...>",
    "documentation": "is a list of expressions to display. Expressions are any mixture of Harbour data types."
   }
  ],
  "name": "OutStd"
 },
 {
  "label": "PadC( <xVal>, <nWidth>, <cFill> ) --> cString",
  "documentation": "Centers an expression for a given width",
  "arguments": [
   {
    "label": "<xVal>",
    "documentation": "A Number, Character or Date value to pad"
   },
   {
    "label": "<nWidth>",
    "documentation": "Width of output string"
   },
   {
    "label": "<cFill>",
    "documentation": "Character to fill in the string"
   }
  ],
  "name": "PadC",
  "return": {
   "name": "<cString>",
   "help": "The Center string of <xVal>"
  }
 },
 {
  "label": "PadL( <xVal>, <nWidth>, <cFill> ) --> cString",
  "documentation": "Left-justifies an expression for a given width",
  "arguments": [
   {
    "label": "<xVal>",
    "documentation": "An number, Character or date to pad"
   },
   {
    "label": "<nWidth>",
    "documentation": "Width of output string"
   },
   {
    "label": "<cFill>",
    "documentation": "Character to fill in the string"
   }
  ],
  "name": "PadL",
  "return": {
   "name": "<cString>",
   "help": "The left-justifies string of <xVal>"
  }
 },
 {
  "label": "PadLeft( <cString>, <nLength>, [<cChar|nChar>] ) -> cString",
  "documentation": "Fills string to a certain length on the left",
  "arguments": [],
  "name": "PadLeft"
 },
 {
  "label": "PadR( <xVal>, <nWidth>, <cFill> ) --> cString",
  "documentation": "Right-justifies an expression for a given width",
  "arguments": [
   {
    "label": "<xVal>",
    "documentation": "A Number, Character or Date value to pad"
   },
   {
    "label": "<nWidth>",
    "documentation": "Width of output string"
   },
   {
    "label": "<cFill>",
    "documentation": "Character to fill in the string"
   }
  ],
  "name": "PadR",
  "return": {
   "name": "<cString>",
   "help": "The right-justifies string of <xVal>"
  }
 },
 {
  "label": "PadRight( <cString>, <nLength>, [<cChar|nChar>] ) -> cString",
  "documentation": "Fills string to a certain length on the right",
  "arguments": [],
  "name": "PadRight"
 },
 {
  "label": "Payment( nLoan, nInterest, nPeriods ) --> nPayment",
  "documentation": "Payments for a loan",
  "arguments": [
   {
    "label": "<nLoan>",
    "documentation": "amount of money you get from the bank"
   },
   {
    "label": "<nInterest>",
    "documentation": "rate of interest per period, 1 == 100%"
   },
   {
    "label": "<nPeriods>",
    "documentation": "period count"
   }
  ],
  "name": "Payment",
  "return": {
   "name": "<nPayment>",
   "help": "Periodical payment one has to make to pay the loan <nLoan> back"
  }
 },
 {
  "label": "PCount() --> nArgs",
  "documentation": "Retrieves the number of arguments passed to a function.",
  "arguments": [],
  "name": "PCount",
  "return": {
   "name": "<nArgs>",
   "help": "A number that indicates the number of arguments passed to a function or procedure."
  }
 },
 {
  "label": "Periods( nLoan, nPayment, nInterest ) --> nPeriods",
  "documentation": "Number of periods for a loan",
  "arguments": [
   {
    "label": "<nLoan>",
    "documentation": "amount of money you get from the bank"
   },
   {
    "label": "<nPayment>",
    "documentation": "amount of money you pay back per period"
   },
   {
    "label": "<nInterest>",
    "documentation": "rate of interest per period, 1 == 100%"
   }
  ],
  "name": "Periods",
  "return": {
   "name": "<nPeriods>",
   "help": "number of periods you need to pay the loan back"
  }
 },
 {
  "label": "Pi() -> nPi",
  "documentation": "Returns Pi, the perimeter-to-diameter-ratio of a circle",
  "arguments": [],
  "name": "Pi",
  "return": {
   "name": "<nPi>",
   "help": "the math constant Pi with maximum precision available"
  }
 },
 {
  "label": "PosAlpha( <cString>, [<lMode>], [<nIgnore>] ) -> nPosition",
  "documentation": "Left-most position of a letter in a string",
  "arguments": [],
  "name": "PosAlpha"
 },
 {
  "label": "PosChar( <[@]cString>, <cCharacter|nCharacter>, [<nPosition>] ) -> cString",
  "documentation": "Replace character at a certain position within a string",
  "arguments": [],
  "name": "PosChar"
 },
 {
  "label": "PosDel( <cString>, [<nStartPosition>], <nLength> ) -> cString",
  "documentation": "Delete characters at a certain position within a string",
  "arguments": [],
  "name": "PosDel"
 },
 {
  "label": "PosDiff( <cString1>, <cString2>, [<nIgnore>] ) -> nPosition",
  "documentation": "The left-most position there two string differ",
  "arguments": [],
  "name": "PosDiff"
 },
 {
  "label": "PosEqual( <cString1>, <cString2>, [<nCompare>], [<nIgnore>] ) -> nPosition",
  "documentation": "The left-most position there two string begin to be equal",
  "arguments": [],
  "name": "PosEqual"
 },
 {
  "label": "PosIns( <cString>, <cInsert>, [<nPosition>] ) -> cString",
  "documentation": "Insert characters at a certain position within a string",
  "arguments": [],
  "name": "PosIns"
 },
 {
  "label": "PosLower( <cString>, [<lMode>], [<nIgnore>] ) -> nPosition",
  "documentation": "Left-most position of a lowercase letter in a string",
  "arguments": [],
  "name": "PosLower"
 },
 {
  "label": "PosRange( <cChar1>, <cChar2>, <cString>, [<lMode>], [<nIgnore>] ) -> nPosition",
  "documentation": "Left-most position of a character from a set in a string",
  "arguments": [],
  "name": "PosRange"
 },
 {
  "label": "PosRepl( <[@]cString>, <cReplacement>, [<nStartPosition>] ) -> cString",
  "documentation": "Replace characters at a certain position within a string",
  "arguments": [],
  "name": "PosRepl"
 },
 {
  "label": "PosUpper( <cString>, [<lMode>], [<nIgnore>] ) -> nPosition",
  "documentation": "Left-most position of an uppercase letter in a string",
  "arguments": [],
  "name": "PosUpper"
 },
 {
  "label": "PrintReady( [<nPrinter>] ) -> lPrinterReady",
  "documentation": "",
  "arguments": [],
  "name": "PrintReady"
 },
 {
  "label": "PrintStat( [<nPrinter>] ) -> nState",
  "documentation": "",
  "arguments": [],
  "name": "PrintStat"
 },
 {
  "label": "ProcFile( <xExp> ) --> cEmptyString",
  "documentation": "This function always returns an empty string.",
  "arguments": [
   {
    "label": "<xExp>",
    "documentation": "is any valid type."
   }
  ],
  "name": "ProcFile",
  "return": {
   "name": "<cEmptyString>",
   "help": "Return an empty string"
  }
 },
 {
  "label": "ProcLine( <nLevel> ) --> nLine",
  "documentation": "Gets the line number of the current function on the stack.",
  "arguments": [
   {
    "label": "<nLevel>",
    "documentation": "is the function level required."
   }
  ],
  "name": "ProcLine",
  "return": {
   "name": "<nLine>",
   "help": "The line number of the function that it is being executed."
  }
 },
 {
  "label": "ProcName( <nLevel> ) --> cProcName",
  "documentation": "Gets the name of the current function on the stack",
  "arguments": [
   {
    "label": "<nLevel>",
    "documentation": "is the function level required."
   }
  ],
  "name": "ProcName",
  "return": {
   "name": "<cProcName>",
   "help": "The name of the function that it is being executed."
  }
 },
 {
  "label": "PV( nPayment, nInterest, nPeriods ) --> nPresentValue",
  "documentation": "Present value of a loan",
  "arguments": [
   {
    "label": "<nPayment>",
    "documentation": "amount of money paid back per period"
   },
   {
    "label": "<nInterest>",
    "documentation": "rate of interest per period, 1 == 100%"
   },
   {
    "label": "<nPeriods>",
    "documentation": "period count"
   }
  ],
  "name": "PV",
  "return": {
   "name": "<nPresentValue>",
   "help": "Present value of a loan when one is paying back <nDeposit> per period at a rate of interest of <nInterest> per period"
  }
 },
 {
  "label": "Quarter( [<dDate>] ) -> nQuarter",
  "documentation": "Returns a number equal to the quarter in which a date falls",
  "arguments": [],
  "name": "Quarter"
 },
 {
  "label": "RangeRem( <cChar1|nChar1>, <cChar2|nChar2>, <cString> ) -> cString",
  "documentation": "Remove characters within a certain ASCII range from a string",
  "arguments": [],
  "name": "RangeRem"
 },
 {
  "label": "RangeRepl( <cChar1|nChar1>, <cChar2|nChar2>, <[@]cString>, <cReplacementChar|nReplacementChar> ) -> cString",
  "documentation": "Replace characters within a certain ASCII range from a string",
  "arguments": [],
  "name": "RangeRepl"
 },
 {
  "label": "RAt( <cSearch>, <cString> ) --> nPos",
  "documentation": "Searches for last occurrence a substring of a string.",
  "arguments": [
   {
    "label": "<cSearch>",
    "documentation": "Substring to search for"
   },
   {
    "label": "<cString>",
    "documentation": "Main string"
   }
  ],
  "name": "RAt",
  "return": {
   "name": "",
   "help": "RAt() return the location of beginning position of last occurrence a substring of a string."
  }
 },
 {
  "label": "Rate( nLoan, nPayment, nPeriods ) --> nRate",
  "documentation": "Estimate rate of interest for a loan",
  "arguments": [
   {
    "label": "<nLoan>",
    "documentation": "amount of money you get from the bank"
   },
   {
    "label": "<nPayment>",
    "documentation": "amount of money you pay back per period"
   },
   {
    "label": "<nPeriods>",
    "documentation": "number of periods you pay the loan back"
   }
  ],
  "name": "Rate",
  "return": {
   "name": "<nInterest>",
   "help": "estimated rate of interest per period, 1 == 100%"
  }
 },
 {
  "label": "RD( <cDir> ) --> <lSucess>",
  "documentation": "Remove a Directory",
  "arguments": [
   {
    "label": "<cDir>",
    "documentation": "DIR TO BE DELETED"
   }
  ],
  "name": "RD",
  "return": {
   "name": "<lSucess>",
   "help": ".T. IF SUCCESSFUL; otherwise .F."
  }
 },
 {
  "label": "ReadKey() --> nKeyCode",
  "documentation": "Determine which key terminated a READ.",
  "arguments": [],
  "name": "ReadKey",
  "return": {
   "name": "",
   "help": "ReadKey() returns a numeric code representing the key that caused READ to terminate."
  }
 },
 {
  "label": "ReadVar( [<cVarName>] ) --> cOldVarName",
  "documentation": "Return variable name of current GET or MENU",
  "arguments": [
   {
    "label": "<cVarName>",
    "documentation": "is a new variable name to set."
   }
  ],
  "name": "ReadVar",
  "return": {
   "name": "",
   "help": "ReadVar() return the old variable name. If no variable previously was set, ReadVar() return \"\"."
  }
 },
 {
  "label": "RecCount()* | LastRec() --> nRecords",
  "documentation": "Counts the number of records in a database.",
  "arguments": [],
  "name": "RecCount",
  "return": {
   "name": "<nRecords>",
   "help": "The number of records CRIPTION$* This function returns the number of records present in the database in the selected or designated work area. If no records are present the value of this function will be 0. Additionally, if no database is in use in the selected or designated work area, this function will return a 0 value as well."
  }
 },
 {
  "label": "RecNo() --> Identity",
  "documentation": "Returns the current record number or identity.",
  "arguments": [],
  "name": "RecNo",
  "return": {
   "name": "",
   "help": "RecNo() The record number or identity"
  }
 },
 {
  "label": "RecSize() --> nBytes",
  "documentation": "Returns the size of a single record in an active database.",
  "arguments": [],
  "name": "RecSize",
  "return": {
   "name": "<nBytes>",
   "help": "The record size."
  }
 },
 {
  "label": "RemAll( <cString>, [<cSearch|nSearch>] ) -> cString",
  "documentation": "Remove certain characters at the left and right of a string",
  "arguments": [],
  "name": "RemAll"
 },
 {
  "label": "RemLeft( <cString>, [<cSearch|nSearch>] ) -> cString",
  "documentation": "Remove certain characters at the left of a string",
  "arguments": [],
  "name": "RemLeft"
 },
 {
  "label": "RemRight( <cString>, [<cSearch|nSearch>] ) -> cString",
  "documentation": "Remove certain characters at the right of a string",
  "arguments": [],
  "name": "RemRight"
 },
 {
  "label": "ReplAll( <cString>, <cReplace|nReplace>, [<cSearch|nSearch>] ) -> cString",
  "documentation": "Replace certain characters at the left and right of a string",
  "arguments": [],
  "name": "ReplAll"
 },
 {
  "label": "Replicate( <cString>, <nSize> ) --> cReplicateString",
  "documentation": "Repeats a single character expression",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Character string to be replicated"
   },
   {
    "label": "<nSize>",
    "documentation": "Number of times to replicate <cString>"
   }
  ],
  "name": "Replicate",
  "return": {
   "name": "<cReplicateString>",
   "help": "A character expression contain the <cString> fill character."
  }
 },
 {
  "label": "ReplLeft( <cString>, <cReplace|nReplace>, [<cSearch|nSearch>] ) -> cString",
  "documentation": "Replace certain characters at the left of a string",
  "arguments": [],
  "name": "ReplLeft"
 },
 {
  "label": "ReplRight( <cString>, <cReplace|nReplace>, [<cSearch|nSearch>] ) -> cString",
  "documentation": "Replace certain characters at the right of a string",
  "arguments": [],
  "name": "ReplRight"
 },
 {
  "label": "RestToken( <cStaticTokenEnvironment> ) -> cOldStaticEnvironment",
  "documentation": "Restore global token environment",
  "arguments": [
   {
    "label": "<cStaticTokenEnvironment>",
    "documentation": "a binary string encoding a TE"
   }
  ],
  "name": "RestToken",
  "return": {
   "name": "<cOldStaticEnvironment>",
   "help": "a string encoding the old global TE"
  }
 },
 {
  "label": "Right( <cString>, <nLen> ) --> cReturn",
  "documentation": "Extract the rightmost substring of a character expression",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Character expression to be parsed"
   },
   {
    "label": "<nLen>",
    "documentation": "Number of bytes to return beginning at the rightmost position"
   }
  ],
  "name": "Right",
  "return": {
   "name": "<cReturn>",
   "help": "Substring of evaluation"
  }
 },
 {
  "label": "RLock() --> lSuccess",
  "documentation": "Lock a record in a work area",
  "arguments": [],
  "name": "RLock",
  "return": {
   "name": "",
   "help": "RLock() True (.T.) if record lock is successful; otherwise, it returns false (.F.)."
  }
 },
 {
  "label": "Round( <nNumber>, <nPlace> ) --> nResult",
  "documentation": "Rounds off a numeric expression.",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "Any numeric value."
   },
   {
    "label": "<nPlace>",
    "documentation": "The number of places to round to."
   }
  ],
  "name": "Round",
  "return": {
   "name": "<nResult>",
   "help": "The rounded number."
  }
 },
 {
  "label": "Row() --> nPosition",
  "documentation": "Returns the current screen row position",
  "arguments": [],
  "name": "Row",
  "return": {
   "name": "<nPosition>",
   "help": "Current screen row position"
  }
 },
 {
  "label": "RToD( nRadiant ) -> nDegree",
  "documentation": "Convert radiant to degree",
  "arguments": [
   {
    "label": "<nRadiant>",
    "documentation": "the size of an angle in radiant"
   }
  ],
  "name": "RToD",
  "return": {
   "name": "<nDegree>",
   "help": "the size of that angle in degree"
  }
 },
 {
  "label": "RTrim( <cExpression> ) --> cString",
  "documentation": "Remove trailing spaces from a string.",
  "arguments": [
   {
    "label": "<cExpression>",
    "documentation": "Any character expression"
   }
  ],
  "name": "RTrim",
  "return": {
   "name": "<cString>",
   "help": "A formatted string with out any blank spaced."
  }
 },
 {
  "label": "SaveToken() -> cStaticTokenEnvironment",
  "documentation": "Save the global token environment",
  "arguments": [],
  "name": "SaveToken",
  "return": {
   "name": "<cStaticTokenEnvironment>",
   "help": "a binary string encoding the global TE"
  }
 },
 {
  "label": "SayScreen( <cString>, [<nRow>], [<nCol>] ) -> <cEmptyString>",
  "documentation": "",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "- the string to output. Although undocumented, can be NIL."
   },
   {
    "label": "<nRow>",
    "documentation": "- row number, defaults to cursor row."
   },
   {
    "label": "<nCol>",
    "documentation": "- column number, defaults to cursor column."
   }
  ],
  "name": "SayScreen",
  "return": {
   "name": "",
   "help": "Returns an empty string."
  }
 },
 {
  "label": "ScreenAttr( [<nRow>], [<nColumn>] ) -> <nAttr>",
  "documentation": "",
  "arguments": [
   {
    "label": "<nRow>",
    "documentation": "Designates the line from which to determine the attribute. The default is the cursor line."
   },
   {
    "label": "<nColumn>",
    "documentation": "Designates the column from which to determine the attribute.  The default is the cursor column."
   }
  ],
  "name": "ScreenAttr",
  "return": {
   "name": "",
   "help": "ScreenAttr() returns the attribute at the designated position."
  }
 },
 {
  "label": "ScreenMix( <cCharString>, <cAttributeString>, [<nRow>], [<nCol>] ) -> <cEmptyString>",
  "documentation": "",
  "arguments": [],
  "name": "ScreenMix"
 },
 {
  "label": "ScreenText( <nTop>, <nLeft>, <nBottom>, <nRight> )",
  "documentation": "",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": "- top row number, default 0"
   },
   {
    "label": "<nLeft>",
    "documentation": "- left column number, default 0"
   },
   {
    "label": "<nBottom>",
    "documentation": "- top row number, default MaxRow()"
   },
   {
    "label": "<nRight>",
    "documentation": "- right column number, default MaxCol()"
   }
  ],
  "name": "ScreenText",
  "return": {
   "name": "",
   "help": "Returns string with characters taken from given screen region."
  }
 },
 {
  "label": "Seconds() --> nSeconds",
  "documentation": "Returns the number of elapsed seconds past midnight.",
  "arguments": [],
  "name": "Seconds",
  "return": {
   "name": "<nSeconds>",
   "help": "Number of seconds since midnight"
  }
 },
 {
  "label": "Secs( <cTime> ) --> nSeconds",
  "documentation": "Return the number of seconds from the system date.",
  "arguments": [
   {
    "label": "<cTime>",
    "documentation": "Character expression in a time string format"
   }
  ],
  "name": "Secs",
  "return": {
   "name": "<nSeconds>",
   "help": "Number of seconds"
  }
 },
 {
  "label": "Select( [<cAlias>] ) --> nWorkArea",
  "documentation": "Returns the work area number for a specified alias.",
  "arguments": [
   {
    "label": "<cAlias>",
    "documentation": "is the target work area alias name."
   }
  ],
  "name": "Select",
  "return": {
   "name": "",
   "help": "Select() returns the work area number."
  }
 },
 {
  "label": "Set( <nSet> [, <xNewSetting> [, <xOption> ] ] ) --> xPreviousSetting",
  "documentation": "Changes or evaluated environmental settings",
  "arguments": [
   {
    "label": "<nSet>",
    "documentation": "Set Number"
   },
   {
    "label": "<xNewSetting>",
    "documentation": "Any expression to assign a value to the setting"
   },
   {
    "label": "<xOption>",
    "documentation": "Logical expression"
   },
   {
    "label": "<nSet>",
    "documentation": "<xNewSetting>          <xOption> `_SET_ALTERNATE`   <lFlag> | <cOnOff> If enabled, QOut() and QQOut() write to the screen and to a file, provided that a file has been opened or created with `_SET_ALTFILE`. If disabled, which is the default, QOut() and QQOut() only write to the screen (and/or to the PRINTFILE). Defaults to disabled. `_SET_ALTFILE`     <cFileName>             <lAdditive> When set, creates or opens file to write QOut() and QQOut() output to. If <lAdditive> is TRUE and the file already exists, the file is opened and positioned at end of file. Otherwise, the file is created. If a file is already opened, it is closed before the new file is opened or created (even if it is the same file). The default file extension is `.txt`. There is no default file name. Call with an empty string to close the file. `_SET_AUTOPEN`     <lFlag> | <cOnOff> TODO: Document `_SET_AUTORDER`    <lFlag> | <cOnOff> TODO: Document `_SET_AUTOSHARE`   <lFlag> | <cOnOff> TODO: Document `_SET_BELL`        <lFlag> | <cOnOff> When enabled, the bell sounds when the last position of a GET is reached and/or when a GET validation fails. Disabled by default. `_SET_CANCEL`      <lFlag> | <cOnOff> When enabled, which is the default, pressing <Alt+C> or"
   },
   {
    "label": "<Ctrl+Break>",
    "documentation": "terminates the program. When disabled, both keystrokes can be read by Inkey(). Note: `SET KEY` has precedence over `SET CANCEL`. `_SET_COLOR`       <cColorSet> Sets the current color scheme, using color pairs in the sequence `\"<standard>, <enhanced>, <border>, <background>,"
   },
   {
    "label": "<unselected>",
    "documentation": "\"`. Each color pair uses the format `\"<foreground>/<background>\"`. The color codes are space or `\"N\"` for black, `\"B\"` for blue, `\"G\"` for green, `\"BG\"` for Cyan, `\"R\"` for red, `\"RB\"` for magenta, `\"GR\"` for brown, `\"W\"` for white, `\"N+\"` for gray, `\"B+\"` for bright blue, `\"G+\"` for bright green, `\"BG+\"` for bright cyan, `\"R+\"` for bright red, `\"RB+\"` for bright magenta, `\"GR+\"` for yellow, and `\"W+\"` for bright white. Special codes are `\"I\"` for inverse video, `\"U\"` for underline on a monochrome monitor (blue on a color monitor), and `\"X\"` for blank. The default color is `\"W/N,N/W,N,N,N/W\"`. `_SET_CONFIRM`     <lFlag> | <cOnOff> If enabled, an exit key must be pressed to leave a GET. If disabled, which is the default, typing past the end will leave a GET. `_SET_CONSOLE`     <lFlag> | <cOnOff> If enabled, which is the default, all screen output goes to the screen. When disabled, screen output is suppressed (Note: This setting does not affect OutStd() or OutErr()). `_SET_CURSOR`      <nCursorType> If enabled, which is the default, the cursor is displayed on screen. If disabled, the screen cursor is hidden. `_SET_DATEFORMAT`  <cDateFormat> Sets the default date format for display, date input, and date conversion. Defaults to American `mm/dd/yy`. Other formats include ANSI `yy.mm.dd`, British `dd/mm/yy`, French `dd/mm/yy`, German `dd.mm.yy`, Italian `dd-mm-yy`, Japan `yy/mm/dd`, and USA `mm-dd-yy`. `SET CENTURY` modifies the date format. `SET CENTURY ON` replaces the `y`s with `YYYY`. `SET CENTURY OFF` replaces the `y`s with `YY`. `_SET_DEBUG`       <lStatus> When set to .T., pressing <Alt+D> activates the debugger. When set to .F., which is the default, <Alt+D> can be read by Inkey(). (Also affected by `AltD( 1 )` and `AltD( 0 )`) `_SET_DECIMALS`    <nNumberOfDecimals> Sets the number of decimal digits to use when displaying printing numeric values when `SET FIXED` is ON. Defaults to 2. If `SET FIXED` is OFF, then `SET DECIMALS` is only used to determine the number of decimal digits to use after using Exp(), Log(), Sqrt(), or division. Other math operations may adjust the number of decimal digits that the result will display. Note: This never affects the precision of a number. Only the display format is affected. `_SET_DEFAULT`     <cDefaultDirectory> Sets the default directory in which to open, create and check for files. Defaults to current directory (blank). `_SET_DELETED`     <lFlag> | <cOnOff> If enabled, deleted records will be processed. If disabled, which is the default, deleted records will be ignored. `_SET_DELIMCHARS`  <cDelimiters> Sets the GET delimiter characters. Defaults to `\"::\"`. `_SET_DELIMITERS`  <lFlag> | <cOnOff> If enabled, GETs are delimited on screen. If disabled, which is the default, no GET delimiters are used. `_SET_DEVICE`      <cDeviceName> Selects the output device for DevOut(). When set to `\"PRINTER\"`, all output is sent to the printer device or file set by `_SET_PRINTFILE`. When set to anything else, all output is sent to the screen. Defaults to `\"SCREEN\"`. `_SET_EOF`         <lFlag> | <cOnOff> Defaults to FALSE on *nix, but defaults to TRUE on everything else. If set to FALSE, then `Chr( 26 )` does not get written when using `COPY TO DELIMITED`, `COPY TO SDF`, or when closing any of the various text files that are created using various SET values. [This is a Harbour extension] `_SET_EPOCH`       <nYear> Determines how to handle the conversion of 2-digit years to 4 digit years. When a 2-digit year is greater than or equal to the year part of the epoch, the century part of the epoch is added to the year. When a 2-digit year is less than the year part of the epoch, the century part of the epoch is incremented and added to the year. The default epoch is 1900, which converts all 2-digit years to 19xx. Example: If the epoch is set to 1950, 2-digit years in the range from 50 to 99 get converted to 19xx and 2-digit years in the range 00 to 49 get converted to 20xx. `_SET_ESCAPE`      <lFlag> | <cOnOff> When enabled, which is the default, pressing <Esc> will exit a READ. When disabled, pressing <Esc> during a READ is ignored, unless the <Esc> key has been assigned to a function using `SET KEY`. `_SET_EVENTMASK`   <nEventCodes> Determines which events Inkey() will respond to. INKEY_MOVE allows mouse movement events. INKEY_LDOWN allows the left mouse button down click. INKEY_LUP allows the left mouse button up click. INKEY_RDOWN allows the right mouse button down click. INKEY_RUP allows the right mouse button up clock. INKEY_KEYBOARD allows keyboard keystrokes. INKEY_ALL allows all of the preceding events. Events may be combined (e.g., using `INKEY_LDOWN + INKEY_RUP` will allow left mouse button down clicks and right mouse button up clicks). The default is INKEY_KEYBOARD. `_SET_EXACT`       <lFlag> | <cOnOff> When enabled, all string comparisons other than `==` exclude trailing spaces when checking for equality. When disabled, which is the default, all string comparisons other than `==` treat two strings as equal if the right hand string is \"\" or if the right hand string is shorter than or the same length as the left hand string and all of the characters in the right hand string match the corresponding characters in the left hand string. `_SET_EXCLUSIVE`   <lFlag> | <cOnOff> When enabled, which is the default, all database files are opened in exclusive mode. When disabled, all database files are opened in shared mode. Note: The EXCLUSIVE and SHARED clauses of the USE command can be used to override this setting. `_SET_EXIT`        <lFlag> | <cOnOff> Toggles the use of <Up> and <Down> as READ exit keys. Specifying true (.T.) enables them as exit keys, and false (.F.) disables them. Used internally by the ReadExit() function. `_SET_EXTRA`       <lFlag> | <cOnOff> QUESTION: What is this for? It does not affect `_SET_EXTRAFILE` in CA-Cl*pper! `_SET_EXTRAFILE`   <cFileName>             <lAdditive> When set, creates or opens file to write QOut() and QQOut() output to. If <lAdditive> is TRUE and the file already exists, the file is opened and positioned at end of file. Otherwise, the file is created. If a file is already opened, it is closed before the new file is opened or created (even if it is the same file). The default file extension is `.prn`. There is no default file name. Call with an empty string to close the file. `_SET_FIXED`       <lFlag> | <cOnOff> When enabled, all numeric values will be displayed and printed with the number of decimal digits set by `SET DECIMALS`, unless a PICTURE clause is used. When disabled, which is the default, the number of decimal digits that are displayed depends upon a variety of factors. See `_SET_DECIMALS` for more. `_SET_INSERT`      <lFlag> | <cOnOff> When enabled, characters typed in a GET or MemoEdit() are inserted. When disabled, which is the default, characters typed in a GET or MemoEdit() overwrite. Note: This setting can also be toggled between on and off by pressing the Insert key during a GET or MemoEdit(). `_SET_INTENSITY`   <lFlag> | <cOnOff> When enabled, which is the default, GETs and PROMPTs are displayed using the enhanced color setting. When disabled, GETs and PROMPTs are displayed using the standard color setting. `_SET_LANGUAGE`    <cLanguageID> Specifies the language to be used for Harbour messages. [This is a Harbour extension] `_SET_MARGIN`      <nColumns> Sets the left margin for all printed output. The default value is 0. Note: PCol() reflects the printer's column position including the margin (e.g., `SET MARGIN TO 5` followed by `DevPos( 5, 10 )` makes PCol() return 15). `_SET_MBLOCKSIZE` <nMemoBlockSize> TODO: Document `_SET_MCENTER`     <lFlag> | <cOnOff> If enabled, display PROMPTs centered on the MESSAGE row. If disabled, which is the default, display PROMPTS at column position 0 on the MESSAGE row. `_SET_MESSAGE`     <nRow> If set to 0, which is the default, PROMPTs are always suppressed. Otherwise, PROMPTs are displayed on the set row. Note: It is not possible to display prompts on the top-most screen row, because row 0 is reserved for the SCOREBOARD, if enabled. `_SET_MFILEEXT`    <cMemoFileExt> TODO: Document `_SET_OPTIMIZE`    <lFlag> | <cOnOff> TODO: Document `_SET_PATH`        <cDirectories> Specifies a path of directories to search through to locate a file that can't be located in the DEFAULT directory. Defaults to no path `\"\"`. Directories must be separated by a semicolon (e.g., `/hb/bin;/hb/tests`). `_SET_PRINTER`     <lFlag> | <cOnOff> If enabled, QOut() and QQOut() write to the screen and to a file, provided that a file has been opened or created with `_SET_ALTFILE`. If disabled, which is the default, QOut() and QQOut() only write to the screen (and/or to the ALTFILE). `_SET_PRINTFILE`   <cFileName>             <lAdditive> When set, creates or opens file to write QOut(), QQOut() and DevOut() output to. If <lAdditive> is TRUE and the file already exists, the file is opened and positioned at end of file. Otherwise, the file is created. If a file is already opened, it is closed before the new file is opened or created (even if it is the same file). The default file extension is `.prn`. The default file name is `PRN`, which maps to the default printer device. Call with an empty string to close the file. `_SET_SCOREBOARD`  <lFlag> | <cOnOff> When enabled, which is the default, READ and MemoEdit() display status messages on screen row 0. When disabled, READ and MemoEdit() status messages are suppressed. `_SET_SCROLLBREAK` <lFlag> | <cOnOff> QUESTION: What is this flag for? `_SET_SOFTSEEK`    <lFlag> | <cOnOff> When enabled, a SEEK that fails will position the record pointer to the first key that is higher than the sought after key or to `LastRec() + 1` if there is no higher key. When disabled, which is the default, a SEEK that fails will position the record pointer to `LastRec() + 1`. `_SET_STRICTREAD`  <lFlag> | <cOnOff> TODO: Document `_SET_TYPEAHEAD`   <nKeyStrokes> Sets the size of the keyboard typeahead buffer. Defaults to 50. The minimum is 16 and the maximum is 4096. `_SET_UNIQUE`      <lFlag> | <cOnOff> When enabled, indexes are not allowed to have duplicate keys. When disabled, indexes are allowed duplicate keys. `_SET_VIDEOMODE`   <nValue> TODO: Document `_SET_WRAP`        <lFlag> | <cOnOff> When enabled, lightbar menus can be navigated from the last position to the first and from the first position to the last. When disabled, which is the default, there is a hard stop at the first and last positions."
   }
  ],
  "name": "Set",
  "return": {
   "name": "",
   "help": "Set() The current or previous setting"
  }
 },
 {
  "label": "SetAtLike( [<nMode>] [, <[@]cWildcard>] ) --> nOldMode",
  "documentation": "Determine scan behaviour in some string functions",
  "arguments": [
   {
    "label": "<cWildcard>",
    "documentation": "."
   }
  ],
  "name": "SetAtLike",
  "return": {
   "name": "",
   "help": "nOldMode          old (if nMode is a numeric value) or current state of the switch"
  }
 },
 {
  "label": "SetDate( <dDate>, [<lMode>] ) --> lSet",
  "documentation": "Sets the system date",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "Designates which date to use to set the system date."
   },
   {
    "label": "<lMode>",
    "documentation": "Designates whether the date should also be set in the CMOS- RAM of an AT.  The default is do not write (.F.). Note that in Windows platform this adjust is automatic, therefore this parameter is without effect."
   }
  ],
  "name": "SetDate",
  "return": {
   "name": "",
   "help": "SetDate() RETURNs .T. when the date is successfully set."
  }
 },
 {
  "label": "SetFont( <cFontString>, [<nFontArea>], [<nOffset>], [<nCounter>] ) --> nError or: SetFont( <cFontString>, [<nFontArea>], [<lCompute>] ) --> nError",
  "documentation": "Loads font from a string.",
  "arguments": [
   {
    "label": "<cFontString>",
    "documentation": "Binary string containing a valid font definition."
   },
   {
    "label": "<nFontArea>",
    "documentation": "Number of a font area where the font must be loaded."
   },
   {
    "label": "<nOffset>",
    "documentation": "First character code to be loaded."
   },
   {
    "label": "<nCounter>",
    "documentation": "Number of characters to load."
   },
   {
    "label": "<lCompute>",
    "documentation": "When .T., the function computes font height automatically."
   }
  ],
  "name": "SetFont"
 },
 {
  "label": "SetKey( <anKey> [, <bAction> [, <bCondition> ] ] )",
  "documentation": "Assign an action block to a key",
  "arguments": [
   {
    "label": "<anKey>",
    "documentation": "is either a numeric key value, or an array of such values"
   },
   {
    "label": "<bAction>",
    "documentation": "is an optional code-block to be assigned"
   },
   {
    "label": "<bCondition>",
    "documentation": "is an optional condition code-block"
   }
  ],
  "name": "SetKey",
  "return": {
   "name": "",
   "help": "Current assigned action-block"
  }
 },
 {
  "label": "SetMode( <nRows>, <nCols> ) --> lSuccess",
  "documentation": "Change the video mode to a specified number of rows and columns",
  "arguments": [
   {
    "label": "<nRows>",
    "documentation": "is the number of rows for the video mode to set."
   },
   {
    "label": "<nCols>",
    "documentation": "is the number of columns for the video mode to set."
   }
  ],
  "name": "SetMode",
  "return": {
   "name": "",
   "help": "SetMode() returns true if the video mode change was successful; otherwise, it returns false."
  }
 },
 {
  "label": "SetPrec( <nPrecision> ) -> cEmptyString",
  "documentation": "Set precision of math functions",
  "arguments": [
   {
    "label": "<nPrecision>",
    "documentation": "digit count between 1 and 16, defaults to 16"
   }
  ],
  "name": "SetPrec",
  "return": {
   "name": "",
   "help": "cEmptyString    this function always returns an empty string"
  }
 },
 {
  "label": "SetTime( <cTime>, [<lMode>] ) --> lSet",
  "documentation": "Sets the system clock",
  "arguments": [
   {
    "label": "<cTime>",
    "documentation": "Designates a character string that contains the time that is to become the system time."
   },
   {
    "label": "<lMode>",
    "documentation": "Designates whether the time should also be set in the CMOS-RAM of an AT.  The default is do not write to CMOS-RAM. Note that in Windows platform this adjust is automatic, therefore this parameter is without effect."
   }
  ],
  "name": "SetTime",
  "return": {
   "name": "",
   "help": "The FUNCTION RETURNs .T. when the time is set successfully."
  }
 },
 {
  "label": "SetTypeahead( <nSize> ) --> nPreviousSize",
  "documentation": "Sets the typeahead buffer to given size.",
  "arguments": [
   {
    "label": "<nSize>",
    "documentation": "is a valid typeahead size."
   }
  ],
  "name": "SetTypeahead",
  "return": {
   "name": "<nPreviousSize>",
   "help": "The previous state of `_SET_TYPEAHEAD`"
  }
 },
 {
  "label": "Sign( <nNumber> ) -> nSign",
  "documentation": "Sign of a number",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "a number"
   }
  ],
  "name": "Sign",
  "return": {
   "name": "<nSign>",
   "help": "sign of <nNumber>"
  }
 },
 {
  "label": "Sinh( nArea ) -> nHyperbolicSine",
  "documentation": "Hyperbolic Sine of the argument",
  "arguments": [
   {
    "label": "<nArea>",
    "documentation": "the size of the area (see below)"
   }
  ],
  "name": "Sinh",
  "return": {
   "name": "<nHyperbolicSine>",
   "help": "the hyperbolic sine of <nArea>"
  }
 },
 {
  "label": "Space( <nSize> ) --> cString",
  "documentation": "Returns a string of blank spaces",
  "arguments": [
   {
    "label": "<nSize>",
    "documentation": "The length of the string"
   }
  ],
  "name": "Space",
  "return": {
   "name": "<cString>",
   "help": "A string containing blank spaces"
  }
 },
 {
  "label": "Sqrt( <nNumber> ) --> nSqrt",
  "documentation": "Calculates the square root of a number.",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "Any  numeric value."
   }
  ],
  "name": "Sqrt",
  "return": {
   "name": "<nSqrt>",
   "help": "The square root of <number>."
  }
 },
 {
  "label": "Standard() -> <cEmptyString>",
  "documentation": "Select the \"STANDARD\" color value for output",
  "arguments": [],
  "name": "Standard"
 },
 {
  "label": "Str( <nNumber>, [<nLength>], [<nDecimals>] ) --> cNumber",
  "documentation": "Convert a numeric expression to a character string.",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "is the numeric expression to be converted to a character string."
   },
   {
    "label": "<nLength>",
    "documentation": "is the length of the character string to return, including decimal digits, decimal point, and sign."
   },
   {
    "label": "<nDecimals>",
    "documentation": "is the number of decimal places to return."
   }
  ],
  "name": "Str",
  "return": {
   "name": "",
   "help": "Str() returns <nNumber> formatted as a character string. If the optional length and decimal arguments are not specified, Str() returns the character string according to the following rules: Results of Str() with No Optional Arguments <table> Expression               Return Value Length Field Variable           Field length plus decimals Expressions/constants    Minimum of 10 digits plus decimals Val()                    Minimum of 3 digits Month()/Day()            3 digits Year()                   5 digits RecNo()                  7 digits </table>"
  }
 },
 {
  "label": "StrDiff( <cString1>, <cString2>, [<nReplacementPenalty>], [<nDeletionPenalty>], [<nInsertionPenalty>] ) -> <nDistance>",
  "documentation": "Evaluate the \"Edit (Levensthein) Distance\" of two strings",
  "arguments": [
   {
    "label": "<cString1>",
    "documentation": "string at the \"starting point\" of the transformation process, default is \"\""
   },
   {
    "label": "<cString2>",
    "documentation": "string at the \"end point\" of the transformation process, default is \"\""
   },
   {
    "label": "<nReplacementPenalty>",
    "documentation": "penalty points for a replacement of one character, default is 3"
   },
   {
    "label": "<nDeletionPenalty>",
    "documentation": "penalty points for a deletion of one character, default is 6"
   },
   {
    "label": "<nInsertionPenalty>",
    "documentation": "penalty points for an insertion of one character, default is 1"
   }
  ],
  "name": "StrDiff",
  "return": {
   "name": "<nDistance>",
   "help": "penalty point sum of all operations needed to transform <cString1> to <cString2>"
  }
 },
 {
  "label": "StrFormat( <cMask>[, <cPar1>[, <cParn>[, ...]] ) --> cString",
  "documentation": "Format a string",
  "arguments": [
   {
    "label": "<cMask>",
    "documentation": "Holds the mask for the resulting string   </par>"
   },
   {
    "label": "<cParn>",
    "documentation": "Holds the strings to be inserted in the mask maximum 9 of them can be specified.   </par>"
   }
  ],
  "name": "StrFormat",
  "return": {
   "name": "<cString>",
   "help": "Return the mask with all the parameters inserted.   </par>"
  }
 },
 {
  "label": "StrSwap( <[@]cString1>, <[@]cString2> ) -> cString",
  "documentation": "Swap the contents of two strings",
  "arguments": [],
  "name": "StrSwap"
 },
 {
  "label": "StrTran( <cString>, <cLocString>, [<cRepString>], [<nPos>], [<nOccurrences>] ) --> cReturn",
  "documentation": "Translate substring value with a main string",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "The main string to search"
   },
   {
    "label": "<cLocString>",
    "documentation": "The string to locate in the main string"
   },
   {
    "label": "<cRepString>",
    "documentation": "The string to replace the <cLocString>"
   },
   {
    "label": "<nPos>",
    "documentation": "The first occurrence to be replaced"
   },
   {
    "label": "<nOccurrences>",
    "documentation": "Number of occurrence to replace"
   }
  ],
  "name": "StrTran",
  "return": {
   "name": "<cReturn>",
   "help": "Formatted string"
  }
 },
 {
  "label": "StrZero( <nNumber>, [<nLength>], [<nDecimals>] ) --> cNumber",
  "documentation": "Convert a numeric expression to a character string, zero padded.",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "is the numeric expression to be converted to a character string."
   },
   {
    "label": "<nLength>",
    "documentation": "is the length of the character string to return, including decimal digits, decimal point, and sign."
   },
   {
    "label": "<nDecimals>",
    "documentation": "is the number of decimal places to return."
   }
  ],
  "name": "StrZero",
  "return": {
   "name": "",
   "help": "StrZero() returns <nNumber> formatted as a character string. If the optional length and decimal arguments are not specified, StrZero() returns the character string according to the following rules: Results of StrZero() with No Optional Arguments <table> Expression               Return Value Length Field Variable           Field length plus decimals Expressions/constants    Minimum of 10 digits plus decimals Val()                    Minimum of 3 digits Month()/Day()            3 digits Year()                   5 digits RecNo()                  7 digits </table>"
  }
 },
 {
  "label": "SubStr( <cString>, <nStart>, [<nLen>] ) --> cReturn",
  "documentation": "Returns a substring from a main string",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Character expression to be parsed"
   },
   {
    "label": "<nStart>",
    "documentation": "Start position"
   },
   {
    "label": "<nLen>",
    "documentation": "Number of characters to return"
   }
  ],
  "name": "SubStr",
  "return": {
   "name": "<cReturn>",
   "help": "Substring of evaluation"
  }
 },
 {
  "label": "TabExpand( <cString>, [<nTabWidth>], [<cFillChar|nFillChar>], [<cNewLineCharacters>], [<cTabChar|nTabChar>], [<lIgnore141>] ) -> cExpandedString",
  "documentation": "Replace tabulator control characters with fill characters",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": ""
   },
   {
    "label": "<nTabWidth>",
    "documentation": ""
   },
   {
    "label": "<cFillChar|nFillChar>",
    "documentation": ""
   },
   {
    "label": "<cNewLineCharacters>",
    "documentation": "string indicating new line, default is the string returned by hb_eol()"
   },
   {
    "label": "<cTabChar|nTabChar>",
    "documentation": "character indicating a tab stop, default is Chr( 9 )"
   },
   {
    "label": "<lIgnore141>",
    "documentation": ".T., if the soft-CR used by MemoEdit() should be ignored as a newline indicator, default is .F. (functions uses hb_BChar( 141 ))"
   }
  ],
  "name": "TabExpand"
 },
 {
  "label": "TabPack( <cString>, [<nTabWidth>], [<cFillChar|nFillChar>], [<cNewLineCharacters>], [<cTabChar|nTabChar>], [<lIgnore141>] ) -> cPackedString",
  "documentation": "Pack fill characters to appropriate tab characters",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": ""
   },
   {
    "label": "<nTabWidth>",
    "documentation": ""
   },
   {
    "label": "<cFillChar|nFillChar>",
    "documentation": ""
   },
   {
    "label": "<cNewLineCharacters>",
    "documentation": "string indicating new line, default is the string returned by hb_eol()"
   },
   {
    "label": "<cTabChar|nTabChar>",
    "documentation": "character indicating a tab stop, default is Chr( 9 )"
   },
   {
    "label": "<lIgnore141>",
    "documentation": ".T., if the soft-CR used by MemoEdit() should be ignored as a newline indicator, default is .F. (functions uses hb_BChar( 141 ))"
   }
  ],
  "name": "TabPack"
 },
 {
  "label": "Tan( nRadiant ) -> nTangent",
  "documentation": "Tangent of the argument",
  "arguments": [
   {
    "label": "<nRadiant>",
    "documentation": "an angle size given in radiants"
   }
  ],
  "name": "Tan",
  "return": {
   "name": "<nTangent>",
   "help": "the tangent of <nRadiant>"
  }
 },
 {
  "label": "Tanh( nArea ) -> nHyperbolicTangent",
  "documentation": "Hyperbolic Tangent of the argument",
  "arguments": [
   {
    "label": "<nArea>",
    "documentation": "the size of the area (see below)"
   }
  ],
  "name": "Tanh",
  "return": {
   "name": "<nHyperbolicTangent>",
   "help": "the hyperbolic tangent of <nArea>"
  }
 },
 {
  "label": "TBrowseDB( [<nTop>], [<nLeft>], [<nBottom>], [<nRight>] ) --> oBrowse",
  "documentation": "Create a new TBrowse object to be used with database file",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": "coordinate for top row display."
   },
   {
    "label": "<nLeft>",
    "documentation": "coordinate for left column display."
   },
   {
    "label": "<nBottom>",
    "documentation": "coordinate for bottom row display."
   },
   {
    "label": "<nRight>",
    "documentation": "coordinate for right column display."
   }
  ],
  "name": "TBrowseDB",
  "return": {
   "name": "",
   "help": "TBrowseDB() return new TBrowse object with the specified coordinate and a default :SkipBlock, :GoTopBlock and :GoBottomBlock to browse a database file."
  }
 },
 {
  "label": "TBrowseNew( <nTop>, <nLeft>, <nBottom>, <nRight> ) --> oBrowse",
  "documentation": "Create a Browse Object",
  "arguments": [
   {
    "label": "<nTop>",
    "documentation": "Top Row"
   },
   {
    "label": "<nLeft>",
    "documentation": "Top Left Column"
   },
   {
    "label": "<nBottom>",
    "documentation": "Bottom Row"
   },
   {
    "label": "<nRight>",
    "documentation": "Bottom Right Column"
   }
  ],
  "name": "TBrowseNew",
  "return": {
   "name": "<oBrowse>",
   "help": "An new Browse Object"
  }
 },
 {
  "label": "Time() --> cTime",
  "documentation": "Returns the system time as a string",
  "arguments": [],
  "name": "Time",
  "return": {
   "name": "<cTime>",
   "help": "Character string representing time"
  }
 },
 {
  "label": "TimeValid( <cTime> ) --> lValid",
  "documentation": "Determines whether a specIFied time is valid",
  "arguments": [
   {
    "label": "<cTime>",
    "documentation": "Designates a character string that contains the time to test."
   }
  ],
  "name": "TimeValid",
  "return": {
   "name": "",
   "help": "TimeValid() RETURNs .T. when <cTime> is a valid time; or .F. when <cTime> is an invalid time."
  }
 },
 {
  "label": "Token( <cString>, [<cTokenizer>], [<nTokenCount], [<nSkipWidth>], [<@cPreTokenSep>], [<@cPostTokenSep>] ) -> cToken",
  "documentation": "Tokens of a string",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "is the processed string [<cTokenizer>]     is a list of characters separating the tokens in <cString> Default: Chr( 0 ) + Chr( 9 ) + Chr( 10 ) + Chr( 13 ) + Chr( 26 ) + hb_BChar( 138 ) + hb_BChar( 141 ) + Chr( 32 ) + \",.;:!\\?/\\\\<>()#&%+-*\" [<nTokenCount>]    specifies the count of the token that should be extracted Default: last token [<nSkipWidth>]     specifies the maximum number of successive tokenizing characters that are combined as ONE token stop, e.g. specifying 1 can yield to empty token Default: 0, any number of successive tokenizing characters are combined as ONE token stop [<@cPreTokenSep>]  If given by reference, the tokenizer before the actual token will be stored [<@cPostTokenSep>] If given by reference, the tokenizer after the actual token will be stored"
   }
  ],
  "name": "Token",
  "return": {
   "name": "<cToken>",
   "help": "the token specified by the parameters given above"
  }
 },
 {
  "label": "TokenAt( [<lSeparatorPositionBehindToken>], [<nToken>], [<@cTokenEnvironment>] ) -> nPosition",
  "documentation": "Get start and end positions of tokens in a token environment",
  "arguments": [
   {
    "label": "<lSeparatorPositionBehindToken>",
    "documentation": ".T., if TokenAt() should return the position of the separator character BEHIND the token. Default: .F., return start position of a token."
   },
   {
    "label": "<nToken>",
    "documentation": "a token number"
   },
   {
    "label": "<@cTokenEnvironment>",
    "documentation": "a token environment"
   }
  ],
  "name": "TokenAt",
  "return": {
   "name": "<nPosition>",
   "help": ""
  }
 },
 {
  "label": "TokenEnd( [<@cTokenEnvironment>] ) -> lTokenEnd",
  "documentation": "Check whether additional tokens are available with TokenNext()",
  "arguments": [
   {
    "label": "<@cTokenEnvironment>",
    "documentation": "a token environment"
   }
  ],
  "name": "TokenEnd",
  "return": {
   "name": "<lTokenEnd>",
   "help": ".T., if additional tokens are available"
  }
 },
 {
  "label": "TokenExit() -> lStaticEnvironmentReleased",
  "documentation": "Release global token environment",
  "arguments": [],
  "name": "TokenExit",
  "return": {
   "name": "<lStaticEnvironmentReleased>",
   "help": ".T., if global token environment is successfully released"
  }
 },
 {
  "label": "TokenInit( <[@]cString>], [<cTokenizer>], [<nSkipWidth>], [<@cTokenEnvironment>] ) -> lState",
  "documentation": "Initializes a token environment",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "is the processed string"
   },
   {
    "label": "<cTokenizer>",
    "documentation": "is a list of characters separating the tokens in <cString> Default: Chr( 0 ) + Chr( 9 ) + Chr( 10 ) + Chr( 13 ) + Chr( 26 ) + hb_BChar( 138 ) + hb_BChar( 141 ) + Chr( 32 ) + \",.;:!\\?/\\\\<>()#&%+-*\""
   },
   {
    "label": "<nSkipWidth>",
    "documentation": "specifies the maximum number of successive tokenizing characters that are combined as ONE token stop, e.g. specifying 1 can yield to empty token Default: 0, any number of successive tokenizing characters are combined as ONE token stop"
   },
   {
    "label": "<@cTokenEnvironment>",
    "documentation": "is a token environment stored in a binary encoded string"
   }
  ],
  "name": "TokenInit",
  "return": {
   "name": "<lState>",
   "help": "success of the initialization"
  }
 },
 {
  "label": "TokenLower( <[@]cString>, [<cTokenizer>], [<nTokenCount>], [<nSkipWidth>] ) -> cString",
  "documentation": "Change the first letter of tokens to lower case",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "is the processed string [<cTokenizer>]    is a list of characters separating the tokens in <cString> Default: Chr( 0 ) + Chr( 9 ) + Chr( 10 ) + Chr( 13 ) + Chr( 26 ) + hb_BChar( 138 ) + hb_BChar( 141 ) + Chr( 32 ) + \",.;:!\\?/\\\\<>()#&%+-*\" [<nTokenCount>]   specifies the number of tokens that should be processed Default: all tokens [<nSkipWidth>]    specifies the maximum number of successive tokenizing characters that are combined as ONE token stop, e.g. specifying 1 can yield to empty token Default: 0, any number of successive tokenizing characters are combined as ONE token stop"
   }
  ],
  "name": "TokenLower",
  "return": {
   "name": "<cString>",
   "help": "the string with the lowercased tokens"
  }
 },
 {
  "label": "TokenNext( <[@]cString>, [<nToken>], [<@cTokenEnvironment>] ) -> cToken",
  "documentation": "Successivly obtains tokens from a string",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "the processed string"
   },
   {
    "label": "<nToken>",
    "documentation": "a token number"
   },
   {
    "label": "<@cTokenEnvironment>",
    "documentation": "a token environment"
   }
  ],
  "name": "TokenNext",
  "return": {
   "name": "<cToken>",
   "help": "a token from <cString>"
  }
 },
 {
  "label": "TokenNum( [<@cTokenEnvironment>] ) -> nNumberofTokens",
  "documentation": "Get the total number of tokens in a token environment",
  "arguments": [
   {
    "label": "<@cTokenEnvironment>",
    "documentation": "a token environment"
   }
  ],
  "name": "TokenNum",
  "return": {
   "name": "<nNumberofTokens>",
   "help": "number of tokens in the token environment"
  }
 },
 {
  "label": "TokenSep( [<lMode>] ) -> cSeparator",
  "documentation": "Retrieves the token separators of the last Token() call",
  "arguments": [],
  "name": "TokenSep",
  "return": {
   "name": "",
   "help": "Depending on the setting of <lMode>, the separating character of the the token retrieved from the last Token() call will be returned. These separating characters can now also be retrieved with the Token() function."
  }
 },
 {
  "label": "TokenUpper( <[@]cString>, [<cTokenizer>], [<nTokenCount>], [<nSkipWidth>] ) -> cString",
  "documentation": "Change the first letter of tokens to upper case",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "is the processed string [<cTokenizer>]    is a list of characters separating the tokens in <cString> Default: Chr( 0 ) + Chr( 9 ) + Chr( 10 ) + Chr( 13 ) + Chr( 26 ) + hb_BChar( 138 ) + hb_BChar( 141 ) + Chr( 32 ) + \",.;:!\\?/\\\\<>()#&%+-*\" [<nTokenCount>]   specifies the number of tokens that should be processed Default: all tokens [<nSkipWidth>]    specifies the maximum number of successive tokenizing characters that are combined as ONE token stop, e.g. specifying 1 can yield to empty token Default: 0, any number of successive tokenizing characters are combined as ONE token stop"
   }
  ],
  "name": "TokenUpper",
  "return": {
   "name": "<cString>",
   "help": "the string with the uppercased tokens"
  }
 },
 {
  "label": "Tone( <nFrequency>, <nDuration> ) --> NIL",
  "documentation": "Sound a tone with a specified frequency and duration.",
  "arguments": [
   {
    "label": "<nFrequency>",
    "documentation": "A non-negative numeric value that specifies the frequency of the tone in hertz."
   },
   {
    "label": "<nDuration>",
    "documentation": "A positive numeric value which specifies the duration of the tone in 1/18 of a second units."
   }
  ],
  "name": "Tone",
  "return": {
   "name": "",
   "help": "Tone() always returns NIL."
  }
 },
 {
  "label": "Transform( <xExpression>, <cTemplate> ) --> cFormatted",
  "documentation": "Formats a value based on a specific picture template.",
  "arguments": [
   {
    "label": "<xExpression>",
    "documentation": "Any expression to be formatted."
   },
   {
    "label": "<cTemplate>",
    "documentation": "Character string with picture template"
   }
  ],
  "name": "Transform",
  "return": {
   "name": "<cFormatted>",
   "help": "Formatted expression in character format"
  }
 },
 {
  "label": "Trim( <cExpression> ) --> cString",
  "documentation": "Remove trailing spaces from a string.",
  "arguments": [
   {
    "label": "<cExpression>",
    "documentation": "Any character expression"
   }
  ],
  "name": "Trim",
  "return": {
   "name": "<cString>",
   "help": "A formatted string with out any blank spaced."
  }
 },
 {
  "label": "Type( <cExp> ) --> cRetType",
  "documentation": "Retrieves the type of an expression",
  "arguments": [
   {
    "label": "<cExp>",
    "documentation": "must be a character expression."
   }
  ],
  "name": "Type",
  "return": {
   "name": "<cRetType>",
   "help": "a string indicating the type of the passed expression. <table> <cRetType>   Meaning \"A\"          Array \"B\"          Block \"C\"          Character (string) \"D\"          Date \"L\"          Logical \"M\"          Memo \"N\"          Numeric \"O\"          Object \"P\"          Pointer \"S\"          Symbol \"U\"          NIL, local or static variable, or not linked-in function \"UE\"         syntax error in the expression or invalid arguments \"UI\"         function with non-reserved name was requested </table>"
  }
 },
 {
  "label": "U2Bin( <nNumber> ) --> cBuffer",
  "documentation": "Convert Harbour numeric into unsigned long encoded bytes",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "is a numeric value to convert (decimal digits are ignored)."
   }
  ],
  "name": "U2Bin",
  "return": {
   "name": "",
   "help": "U2Bin() return four bytes character string that contains 32-bit encoded unsigned long integer (least significant byte first)."
  }
 },
 {
  "label": "Unselected() -> <cEmptyString>",
  "documentation": "Select the \"UNSELECTED\" color value for output",
  "arguments": [],
  "name": "Unselected"
 },
 {
  "label": "UnTextWin( <nTopLine>, <nLeftColumn>, <nBottomLine>, <nRightColumn>, <cReplacementCharacter|nReplacementCharacter>, [<cInitialCharacter|nInitialCharacter>], [<cEndCharacter|nEndCharacter>] ) --> cNull",
  "documentation": "",
  "arguments": [
   {
    "label": "<nTopLine>",
    "documentation": "Designates the line for the upper-left corner of the area."
   },
   {
    "label": "<nLeftColumn>",
    "documentation": "Designates the column for the upper-left corner of the area."
   },
   {
    "label": "<nBottomLine>",
    "documentation": "Designates the line for the bottom-right corner of the area."
   },
   {
    "label": "<nRightColumn>",
    "documentation": "Designates the line for the bottom-right column of the area."
   },
   {
    "label": "<cReplacementCharacter|nReplacementCharacter>",
    "documentation": "Replaces each character within the window, with the exception of those within the range of <cInitialCharacter|nInitialCharacter> and"
   },
   {
    "label": "<cEndCharacter|nEndCharacter>",
    "documentation": "."
   },
   {
    "label": "<cInitialCharacter|nInitialCharacter>",
    "documentation": "Designates the beginning of the bracketed area.  The character can be number in the range of 0 to 255, or the character string type.  The default value is 176."
   },
   {
    "label": "<cEndCharacter|nEndCharacter>",
    "documentation": "Designates the end of the bracketed area.  The character can be number in the range of 0 to 255 or the character string type.  The default value is 223."
   }
  ],
  "name": "UnTextWin",
  "return": {
   "name": "",
   "help": "Returns a null string."
  }
 },
 {
  "label": "Upper( <cString> ) --> cUpperString",
  "documentation": "Converts a character expression to uppercase format",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "Any character expression."
   }
  ],
  "name": "Upper",
  "return": {
   "name": "<cUpperString>",
   "help": "Uppercased value of <cString>"
  }
 },
 {
  "label": "Used() --> lDbfOpen",
  "documentation": "Checks whether a database is in use in a work area",
  "arguments": [],
  "name": "Used",
  "return": {
   "name": "<lDbfOpen>",
   "help": "True is a database is Used;otherwise False"
  }
 },
 {
  "label": "Val( <cNumber> ) --> nNumber",
  "documentation": "Convert a number from a character type to numeric",
  "arguments": [
   {
    "label": "<cNumber>",
    "documentation": "Any valid character string of numbers."
   }
  ],
  "name": "Val",
  "return": {
   "name": "<nNumber>",
   "help": "The numeric value of <cNumber>"
  }
 },
 {
  "label": "ValPos( <cString>, [<nPosition>] ) --> nDigitValue",
  "documentation": "Numerical value of a character at a certain position",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "is the processed string [<nPosition>]  is an optional position within <cString> Default: last position in <cString>"
   }
  ],
  "name": "ValPos",
  "return": {
   "name": "<nDigitValue>",
   "help": "the numerical value of the character at the specified position"
  }
 },
 {
  "label": "ValType( <xExp> ) --> cRetType",
  "documentation": "Retrieves the data type of an expression",
  "arguments": [
   {
    "label": "<xExp>",
    "documentation": "is any valid expression."
   }
  ],
  "name": "ValType",
  "return": {
   "name": "<cRetType>",
   "help": "a character indicating the type of the passed expression. <table> <cRetType>   Meaning \"A\"          Array \"B\"          Block \"C\"          Character (string) \"D\"          Date \"L\"          Logical \"M\"          Memo \"N\"          Numeric \"O\"          Object \"P\"          Pointer \"S\"          Symbol \"U\"          NIL </table>"
  }
 },
 {
  "label": "Version() --> cReturn",
  "documentation": "Returns the version of Harbour compiler",
  "arguments": [],
  "name": "Version",
  "return": {
   "name": "<cReturn>",
   "help": "String containing the Harbour version"
  }
 },
 {
  "label": "VGAPalette( [<cColor|nColor>, [<nRedValue>, <nGreenValue>, <nBlueValue]] ) --> lValid",
  "documentation": "Changes VGA palette colors",
  "arguments": [
   {
    "label": "<cColor|nColor>",
    "documentation": "- the color to change in CA-Cl*pper color notation or as a number from 0 to 15."
   },
   {
    "label": "<nRedValue>",
    "documentation": ", <nGreenValue>, and <nBlueValue> specify the palette settings for the respective portions in the range from 0 to 63. If no RGB value is specified, the palette register is reset to its default value (currently unsupported). If the function is called without parameters, the palette registers for all colors are reset to their default values (currently unsupported)."
   }
  ],
  "name": "VGAPalette",
  "return": {
   "name": "",
   "help": "Returns .T. on success."
  }
 },
 {
  "label": "VideoType() --> nMask",
  "documentation": "Detects supported video adapter modes",
  "arguments": [],
  "name": "VideoType"
 },
 {
  "label": "W2Bin( <nNumber> ) --> cBuffer",
  "documentation": "Convert Harbour numeric into unsigned short encoded bytes",
  "arguments": [
   {
    "label": "<nNumber>",
    "documentation": "is a numeric value to convert (decimal digits are ignored)."
   }
  ],
  "name": "W2Bin",
  "return": {
   "name": "",
   "help": "W2Bin() return two bytes character string that contains 16-bit encoded unsigned short integer (least significant byte first)."
  }
 },
 {
  "label": "WaitPeriod( [<nDelay>] ) --> lNotElapsed",
  "documentation": "Pauses a specified time in increments of 1/100 seconds",
  "arguments": [
   {
    "label": "<nDelay>",
    "documentation": "Designates the waiting period at initialization in 1/100ths of seconds.  Values from 1 to 8, 640, 000 (one day) are possible."
   }
  ],
  "name": "WaitPeriod",
  "return": {
   "name": "",
   "help": "WaitPeriod() returns .T., if the time span designated at initialization has not elapsed."
  }
 },
 {
  "label": "Week( [<dDate>][, <lSWN>] ) -> nWeek",
  "documentation": "Returns the calendar week a number",
  "arguments": [],
  "name": "Week"
 },
 {
  "label": "Word( <nDouble> ) --> nInteger",
  "documentation": "Converts double to integer values.",
  "arguments": [
   {
    "label": "<nDouble>",
    "documentation": "is a numeric double value."
   }
  ],
  "name": "Word",
  "return": {
   "name": "",
   "help": "Word() return an integer in the range +-32767"
  }
 },
 {
  "label": "WordOne( [<cDoubleCharactersToReduce>,] <cString> ) -> cReducedString",
  "documentation": "Reduce multiple occurences of a double character to one",
  "arguments": [
   {
    "label": "<cString>",
    "documentation": "specifies the processed string"
   }
  ],
  "name": "WordOne",
  "return": {
   "name": "<cReducedString>",
   "help": "the string with the reduced occurences"
  }
 },
 {
  "label": "WordOnly( <cThisDoubleCharactersOnly>, <cString> ) -> cReducedString",
  "documentation": "Intersectional set of two strings based on double characters",
  "arguments": [
   {
    "label": "<cThisDoubleCharactersOnly>",
    "documentation": "specifies the double characters that must not be deleted in <cString>."
   },
   {
    "label": "<cString>",
    "documentation": "is the string that should be processed"
   }
  ],
  "name": "WordOnly",
  "return": {
   "name": "<cReducedString>",
   "help": "A string with all double characters deleted but those specified in <cThisCharactersOnly>."
  }
 },
 {
  "label": "WordRem( <cDeleteThisDoubleCharacters>, <cString> ) -> cReducedString",
  "documentation": "Removes characters from a string",
  "arguments": [
   {
    "label": "<cDeleteThisDoubleCharacters>",
    "documentation": "specifies the double characters that should be deleted in <cString>"
   },
   {
    "label": "<cString>",
    "documentation": ")                      is the string that should be processed"
   }
  ],
  "name": "WordRem",
  "return": {
   "name": "<cReducedString>",
   "help": "is a string where the double characters specified in <cDeleteThisDoubleCharacters> are deleted"
  }
 },
 {
  "label": "WordRepl( <cDoubleCharacterSearchString>, <[@]cString>, <cDoubleCharacterReplaceString>, [<lMode>] ) -> cString",
  "documentation": "Replacement of double characters",
  "arguments": [
   {
    "label": "<cDoubleCharacterSearchString>",
    "documentation": "is a string of double characters that should be replaced"
   },
   {
    "label": "<[@]cString>",
    "documentation": "is the processed string"
   },
   {
    "label": "<cDoubleCharacterReplaceString>",
    "documentation": "is a string of double characters that replace the one of <cSearchString> [<lMode>]                        sets the replacement method (see description) Default: .F."
   }
  ],
  "name": "WordRepl",
  "return": {
   "name": "",
   "help": "cString                          the processed string"
  }
 },
 {
  "label": "WordSwap( <[@]cString> [, <lSwapCharacters>] ) -> cSwappedString",
  "documentation": "Swap neighbouring double characters in a string",
  "arguments": [
   {
    "label": "<[@]cString>",
    "documentation": "is the string that should be processed [<lSwapCharacters>]  specifies whether an additional swap should be done within the double characters Default: .F., no additional swap"
   }
  ],
  "name": "WordSwap",
  "return": {
   "name": "<cSwappedString>",
   "help": "a string where neighbouring double characters are swapped"
  }
 },
 {
  "label": "WordToChar( <cDoubleCharacterSearchString>, <cString>, <cSingleCharacterReplaceString> ) -> cString",
  "documentation": "Replace double with single characters",
  "arguments": [],
  "name": "WordToChar"
 },
 {
  "label": "WoY( <dDate>, <lIso> ) --> nWeek",
  "documentation": "Gets the week number of the year.",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "A valid date."
   }
  ],
  "name": "WoY",
  "return": {
   "name": "<nWeek>",
   "help": "The week number <lIso>    Flag that indicates if <nWeek> is in ISO format."
  }
 },
 {
  "label": "XToC( <expValue> ) --> cValue ",
  "documentation": "",
  "arguments": [
   {
    "label": "<expValue>",
    "documentation": "Designate an expression of some of the following data type: NUMBER, CHARACTER, DATE, LOGICAL."
   }
  ],
  "name": "XToC",
  "return": {
   "name": "",
   "help": "XToC() return a string with the representation of data type of expValue."
  }
 },
 {
  "label": "xxx( <lMode> ) --> lPriorSetting",
  "documentation": "xxx",
  "arguments": [
   {
    "label": "<lMode>",
    "documentation": "xxx xxx"
   }
  ],
  "name": "xxx",
  "return": {
   "name": "<lPriorSetting>",
   "help": ""
  }
 },
 {
  "label": "Year( <dDate> ) --> nYear",
  "documentation": "Extracts the year designator of a given date as a numeric value",
  "arguments": [
   {
    "label": "<dDate>",
    "documentation": "Any valid date expression"
   }
  ],
  "name": "Year",
  "return": {
   "name": "<nYear>",
   "help": "The year portion of the date."
  }
 }
]